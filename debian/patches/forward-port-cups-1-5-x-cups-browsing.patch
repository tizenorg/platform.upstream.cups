Description: Forward-port CUPS 1.5.x CUPS Broadcasting/Browsing
Author: Till Kamppeter <till.kamppeter@gmail.com>
Bug-Ubuntu: https://bugs.launchpad.net/bugs/1061063

--- a/config.h.in
+++ b/config.h.in
@@ -62,8 +62,12 @@
  */
 
 #define CUPS_DEFAULT_BROWSING	1
-#define CUPS_DEFAULT_BROWSE_LOCAL_PROTOCOLS	""
+#define CUPS_DEFAULT_BROWSE_LOCAL_PROTOCOLS	"CUPS"
+#define CUPS_DEFAULT_BROWSE_REMOTE_PROTOCOLS	"CUPS"
+#define CUPS_DEFAULT_BROWSE_SHORT_NAMES	1
 #define CUPS_DEFAULT_DEFAULT_SHARED 1
+#define CUPS_DEFAULT_IMPLICIT_CLASSES	1
+#define CUPS_DEFAULT_USE_NETWORK_DEFAULT 1
 
 
 /*
--- a/templates/admin.tmpl
+++ b/templates/admin.tmpl
@@ -45,9 +45,15 @@
 <P><A HREF="/admin/">Advanced <SMALL>&#x25bc;</SMALL></A><BR>
 <INPUT TYPE="HIDDEN" NAME="OP" VALUE="config-server">
 <INPUT TYPE="HIDDEN" NAME="ADVANCEDSETTINGS" VALUE="YES">
+<INPUT TYPE="CHECKBOX" NAME="REMOTE_PRINTERS" {?remote_printers}> Show printers shared by other systems<BR>
+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Protocols\:
+<INPUT TYPE="CHECKBOX" NAME="BROWSE_REMOTE_CUPS" {?browse_remote_cups}> CUPS<BR>
 <INPUT TYPE="CHECKBOX" NAME="SHARE_PRINTERS" {?share_printers}> Share printers connected to this system<BR>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Max clients\:
 <INPUT TYPE="TEXT" NAME="MAX_CLIENTS" VALUE="{?max_clients}" SIZE="6"><BR>
+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Protocols\:
+<INPUT TYPE="CHECKBOX" NAME="BROWSE_LOCAL_CUPS" {?browse_local_cups}> CUPS
+{HAVE_DNSSD?<INPUT TYPE="CHECKBOX" NAME="BROWSE_LOCAL_DNSSD" {?browse_local_dnssd}> DNS-SD:}<BR>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<INPUT TYPE="CHECKBOX" NAME="REMOTE_ANY" {?remote_any}> Allow printing from the Internet<BR>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<INPUT TYPE="CHECKBOX" NAME="BROWSE_WEB_IF" {?browse_web_if}> Advertise web interface<BR>
 <INPUT TYPE="CHECKBOX" NAME="REMOTE_ADMIN" {?remote_admin}> Allow remote administration<BR>
@@ -68,6 +74,7 @@
 
 <P><A HREF="/admin/?ADVANCEDSETTINGS=YES">Advanced <SMALL>&#x25b6;</SMALL></A><BR>
 <INPUT TYPE="HIDDEN" NAME="OP" VALUE="config-server">
+<INPUT TYPE="CHECKBOX" NAME="REMOTE_PRINTERS" {?remote_printers}> Show printers shared by other systems<BR>
 <INPUT TYPE="CHECKBOX" NAME="SHARE_PRINTERS" {?share_printers}> Share printers connected to this system<BR>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<INPUT TYPE="CHECKBOX" NAME="REMOTE_ANY" {?remote_any}> Allow printing from the Internet<BR>
 <INPUT TYPE="CHECKBOX" NAME="REMOTE_ADMIN" {?remote_admin}> Allow remote administration<BR>
--- a/cgi-bin/admin.c
+++ b/cgi-bin/admin.c
@@ -586,7 +586,8 @@
     ippAddInteger(request, IPP_TAG_OPERATION, IPP_TAG_ENUM, "printer-type",
 		  CUPS_PRINTER_LOCAL);
     ippAddInteger(request, IPP_TAG_OPERATION, IPP_TAG_ENUM, "printer-type-mask",
-		  CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE);
+		  CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE |
+		      CUPS_PRINTER_IMPLICIT);
 
    /*
     * Do the request and get back a response...
@@ -1561,6 +1562,8 @@
 					/* PRESERVE_JOBS value */
 			*remote_admin,	/* REMOTE_ADMIN value */
 			*remote_any,	/* REMOTE_ANY value */
+			*remote_printers,
+					/* REMOTE_PRINTERS value */
 			*share_printers,/* SHARE_PRINTERS value */
 			*user_cancel_any,
 					/* USER_CANCEL_ANY value */
@@ -1576,6 +1579,10 @@
 					/* MaxJobs value */
 			*max_log_size = NULL;
 					/* MaxLogSize value */
+    char		local_protocols[255],
+					/* BrowseLocalProtocols */
+			remote_protocols[255];
+					/* BrowseRemoteProtocols */
     const char		*current_browse_web_if,
 					/* BrowseWebIF value */
 			*current_preserve_job_history,
@@ -1586,8 +1593,12 @@
 					/* MaxClients value */
 			*current_max_jobs,
 					/* MaxJobs value */
-			*current_max_log_size;
+			*current_max_log_size,
 					/* MaxLogSize value */
+			*current_local_protocols,
+					/* BrowseLocalProtocols */
+			*current_remote_protocols;
+					/* BrowseRemoteProtocols */
 #ifdef HAVE_GSSAPI
     char		default_auth_type[255];
 					/* DefaultAuthType value */
@@ -1602,6 +1613,7 @@
     debug_logging        = cgiGetVariable("DEBUG_LOGGING") ? "1" : "0";
     remote_admin         = cgiGetVariable("REMOTE_ADMIN") ? "1" : "0";
     remote_any           = cgiGetVariable("REMOTE_ANY") ? "1" : "0";
+    remote_printers      = cgiGetVariable("REMOTE_PRINTERS") ? "1" : "0";
     share_printers       = cgiGetVariable("SHARE_PRINTERS") ? "1" : "0";
     user_cancel_any      = cgiGetVariable("USER_CANCEL_ANY") ? "1" : "0";
 
@@ -1644,6 +1656,26 @@
 
       if (!max_log_size || atoi(max_log_size) <= 0.0)
 	max_log_size = "1m";
+
+      if (cgiGetVariable("BROWSE_LOCAL_CUPS"))
+	strcpy(local_protocols, "cups");
+      else
+	local_protocols[0] = '\0';
+
+#if defined(HAVE_DNSSD) || defined(HAVE_AVAHI)
+      if (cgiGetVariable("BROWSE_LOCAL_DNSSD"))
+      {
+	if (local_protocols[0])
+	  strcat(local_protocols, " dnssd");
+	else
+	  strcat(local_protocols, "dnssd");
+      }
+#endif /* HAVE_DNSSD || HAVE_AVAHI */
+
+      if (cgiGetVariable("BROWSE_REMOTE_CUPS"))
+	strcpy(remote_protocols, "cups");
+      else
+	remote_protocols[0] = '\0';
     }
 
    /*
@@ -1707,6 +1739,16 @@
                                               settings)) == NULL)
       current_max_log_size = "1m";
 
+    if ((current_local_protocols = cupsGetOption("BrowseLocalProtocols",
+                                                 num_settings,
+						settings)) == NULL)
+      current_local_protocols = CUPS_DEFAULT_BROWSE_LOCAL_PROTOCOLS;
+
+    if ((current_remote_protocols = cupsGetOption("BrowseRemoteProtocols",
+                                                  num_settings,
+						  settings)) == NULL)
+      current_remote_protocols = CUPS_DEFAULT_BROWSE_REMOTE_PROTOCOLS;
+
    /*
     * See if the settings have changed...
     */
@@ -1717,6 +1759,8 @@
 						 num_settings, settings)) ||
 	      strcmp(remote_any, cupsGetOption(CUPS_SERVER_REMOTE_ANY,
 					       num_settings, settings)) ||
+	      strcmp(remote_printers, cupsGetOption(CUPS_SERVER_REMOTE_PRINTERS,
+						    num_settings, settings)) ||
 	      strcmp(share_printers, cupsGetOption(CUPS_SERVER_SHARE_PRINTERS,
 						   num_settings, settings)) ||
 #ifdef HAVE_GSSAPI
@@ -1728,7 +1772,9 @@
 						    num_settings, settings));
 
     if (advanced && !changed)
-      changed = _cups_strcasecmp(browse_web_if, current_browse_web_if) ||
+      changed = _cups_strcasecmp(local_protocols, current_local_protocols) ||
+		_cups_strcasecmp(remote_protocols, current_remote_protocols) ||
+		_cups_strcasecmp(browse_web_if, current_browse_web_if) ||
 		_cups_strcasecmp(preserve_job_history, current_preserve_job_history) ||
 		_cups_strcasecmp(preserve_job_files, current_preserve_job_files) ||
 		_cups_strcasecmp(max_clients, current_max_clients) ||
@@ -1750,6 +1796,8 @@
                                    remote_admin, num_settings, &settings);
       num_settings = cupsAddOption(CUPS_SERVER_REMOTE_ANY,
                                    remote_any, num_settings, &settings);
+      num_settings = cupsAddOption(CUPS_SERVER_REMOTE_PRINTERS,
+                                   remote_printers, num_settings, &settings);
       num_settings = cupsAddOption(CUPS_SERVER_SHARE_PRINTERS,
                                    share_printers, num_settings, &settings);
       num_settings = cupsAddOption(CUPS_SERVER_USER_CANCEL_ANY,
@@ -1765,6 +1813,12 @@
         * Add advanced settings...
 	*/
 
+	if (_cups_strcasecmp(local_protocols, current_local_protocols))
+	  num_settings = cupsAddOption("BrowseLocalProtocols", local_protocols,
+				       num_settings, &settings);
+	if (_cups_strcasecmp(remote_protocols, current_remote_protocols))
+	  num_settings = cupsAddOption("BrowseRemoteProtocols", remote_protocols,
+				       num_settings, &settings);
 	if (_cups_strcasecmp(browse_web_if, current_browse_web_if))
 	  num_settings = cupsAddOption("BrowseWebIF", browse_web_if,
 				       num_settings, &settings);
@@ -2285,7 +2339,8 @@
                 "printer-type", 0);
 
   ippAddInteger(request, IPP_TAG_OPERATION, IPP_TAG_ENUM,
-                "printer-type-mask", CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE);
+                "printer-type-mask", CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE |
+		                     CUPS_PRINTER_IMPLICIT);
 
   ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_KEYWORD,
                "requested-attributes", NULL, "printer-name");
@@ -2621,6 +2676,10 @@
                            settings)) != NULL && atoi(val))
     cgiSetVariable("REMOTE_ANY", "CHECKED");
 
+  if ((val = cupsGetOption(CUPS_SERVER_REMOTE_PRINTERS, num_settings,
+                           settings)) != NULL && atoi(val))
+    cgiSetVariable("REMOTE_PRINTERS", "CHECKED");
+
   if ((val = cupsGetOption(CUPS_SERVER_SHARE_PRINTERS, num_settings,
                            settings)) != NULL && atoi(val))
     cgiSetVariable("SHARE_PRINTERS", "CHECKED");
@@ -2639,6 +2698,29 @@
 #endif /* HAVE_GSSAPI */
   cgiSetVariable("KERBEROS", "");
 
+  if ((val = cupsGetOption("BrowseRemoteProtocols", num_settings,
+                           settings)) == NULL)
+    if ((val = cupsGetOption("BrowseProtocols", num_settings,
+                           settings)) == NULL)
+      val = CUPS_DEFAULT_BROWSE_REMOTE_PROTOCOLS;
+
+  if (strstr(val, "cups") || strstr(val, "CUPS"))
+    cgiSetVariable("BROWSE_REMOTE_CUPS", "CHECKED");
+
+  if ((val = cupsGetOption("BrowseLocalProtocols", num_settings,
+                           settings)) == NULL)
+    if ((val = cupsGetOption("BrowseProtocols", num_settings,
+                           settings)) == NULL)
+      val = CUPS_DEFAULT_BROWSE_LOCAL_PROTOCOLS;
+
+  if (strstr(val, "cups") || strstr(val, "CUPS"))
+    cgiSetVariable("BROWSE_LOCAL_CUPS", "CHECKED");
+
+  if (strstr(val, "dnssd") || strstr(val, "DNSSD") ||
+      strstr(val, "dns-sd") || strstr(val, "DNS-SD") ||
+      strstr(val, "bonjour") || strstr(val, "BONJOUR"))
+    cgiSetVariable("BROWSE_LOCAL_DNSSD", "CHECKED");
+
   if ((val = cupsGetOption("BrowseWebIF", num_settings,
                            settings)) == NULL)
     val = "No";
--- a/systemv/lpadmin.c
+++ b/systemv/lpadmin.c
@@ -1090,7 +1090,8 @@
   *    option with deleteAttr tag
   */
 
-  if (get_printer_type(http, printer, uri, sizeof(uri)) & CUPS_PRINTER_CLASS)
+  if (get_printer_type(http, printer, uri, sizeof(uri)) &
+          (CUPS_PRINTER_CLASS | CUPS_PRINTER_IMPLICIT))
     request = ippNewRequest(CUPS_ADD_MODIFY_CLASS);
   else
     request = ippNewRequest(CUPS_ADD_MODIFY_PRINTER);
@@ -1144,7 +1145,8 @@
   *    printer-is-accepting-jobs
   */
 
-  if (get_printer_type(http, printer, uri, sizeof(uri)) & CUPS_PRINTER_CLASS)
+  if (get_printer_type(http, printer, uri, sizeof(uri)) &
+          (CUPS_PRINTER_CLASS | CUPS_PRINTER_IMPLICIT))
     request = ippNewRequest(CUPS_ADD_MODIFY_CLASS);
   else
     request = ippNewRequest(CUPS_ADD_MODIFY_PRINTER);
@@ -1222,7 +1224,7 @@
   {
     type = (cups_ptype_t)attr->values[0].integer;
 
-    if (type & CUPS_PRINTER_CLASS)
+    if (type & (CUPS_PRINTER_CLASS | CUPS_PRINTER_IMPLICIT))
       httpAssembleURIf(HTTP_URI_CODING_ALL, uri, urisize, "ipp", NULL,
 		       "localhost", ippPort(), "/classes/%s", printer);
   }
@@ -1281,7 +1283,8 @@
   *    other options
   */
 
-  if (get_printer_type(http, printer, uri, sizeof(uri)) & CUPS_PRINTER_CLASS)
+  if (get_printer_type(http, printer, uri, sizeof(uri)) &
+          (CUPS_PRINTER_CLASS | CUPS_PRINTER_IMPLICIT))
     request = ippNewRequest(CUPS_ADD_MODIFY_CLASS);
   else
     request = ippNewRequest(CUPS_ADD_MODIFY_PRINTER);
--- a/systemv/cupsctl.c
+++ b/systemv/cupsctl.c
@@ -83,6 +83,12 @@
         else if (!strcmp(argv[i], "--no-remote-any"))
 	  num_settings = cupsAddOption(CUPS_SERVER_REMOTE_ANY, "0",
 	                               num_settings, &settings);
+        else if (!strcmp(argv[i], "--remote-printers"))
+	  num_settings = cupsAddOption(CUPS_SERVER_REMOTE_PRINTERS, "1",
+	                               num_settings, &settings);
+        else if (!strcmp(argv[i], "--no-remote-printers"))
+	  num_settings = cupsAddOption(CUPS_SERVER_REMOTE_PRINTERS, "0",
+	                               num_settings, &settings);
         else if (!strcmp(argv[i], "--share-printers"))
 	  num_settings = cupsAddOption(CUPS_SERVER_SHARE_PRINTERS, "1",
 	                               num_settings, &settings);
@@ -213,6 +219,8 @@
                           "administration on/off."));
   _cupsLangPuts(stdout, _("  --[no-]remote-any       Allow/prevent access "
                           "from the Internet."));
+  _cupsLangPuts(stdout, _("  --[no-]remote-printers  Show/hide remote "
+                          "printers."));
   _cupsLangPuts(stdout, _("  --[no-]share-printers   Turn printer sharing "
                           "on/off."));
   _cupsLangPuts(stdout, _("  --[no-]user-cancel-any  Allow/prevent users to "
--- a/doc/help/ref-cupsd-conf.html.in
+++ b/doc/help/ref-cupsd-conf.html.in
@@ -341,6 +341,156 @@
 default setting is <CODE>No</CODE>.</P>
 
 
+<H2 CLASS="title"><A NAME="BrowseAddress">BrowseAddress</A></H2>
+
+<H3>Examples</H3>
+
+<PRE CLASS="command">
+BrowseAddress 255.255.255.255:631
+BrowseAddress 192.0.2.255:631
+BrowseAddress host.example.com:631
+BrowseAddress @LOCAL
+BrowseAddress @IF(name)
+</PRE>
+
+<H3>Description</H3>
+
+<P>The <CODE>BrowseAddress</CODE> directive specifies an address
+to send browsing information to. Multiple
+<CODE>BrowseAddress</CODE> directives can be specified to send
+browsing information to different networks or systems.</P>
+
+<P>The <CODE>@LOCAL</CODE> name will broadcast printer
+information to all local interfaces. The <CODE>@IF(name)</CODE>
+name will broadcast to the named interface.</P>
+
+<P>There is no default browse address.</P>
+
+<BLOCKQUOTE><B>Note:</B>
+
+<P>If you are using HP-UX 10.20 and a subnet that is not 24,
+16, or 8 bits, printer browsing (and in fact all broadcast
+reception) will not work. This problem appears to be fixed in
+HP-UX 11.0.</P>
+
+</BLOCKQUOTE>
+
+
+<H2 CLASS="title"><A NAME="BrowseAllow">BrowseAllow</A></H2>
+
+<H3>Examples</H3>
+
+<PRE CLASS="command">
+BrowseAllow from all
+BrowseAllow from none
+BrowseAllow from 192.0.2
+BrowseAllow from 192.0.2.0/24
+BrowseAllow from 192.0.2.0/255.255.255.0
+BrowseAllow from *.example.com
+BrowseAllow from @LOCAL
+BrowseAllow from @IF(name)
+</PRE>
+
+<H3>Description</H3>
+
+<P>The <CODE>BrowseAllow</CODE> directive specifies a system or
+network to accept browse packets from. The default is to accept
+browse packets from all hosts.</P>
+
+<P>Host and domain name matching require that you enable the <A
+HREF="#HostNameLookups"><CODE>HostNameLookups</CODE></A>
+directive.</P>
+
+<P>IP address matching supports exact matches, partial addresses that match
+networks using netmasks of 255.0.0.0, 255.255.0.0, and 255.255.255.0, or network
+addresses using the specified netmask or bit count. The <CODE>/mm</CODE>
+notation specifies a CIDR netmask, a shown in <A HREF="TABLE1">Table 1</A>.</P>
+
+<P>The <CODE>@LOCAL</CODE> name will allow browse data from all
+local interfaces. The <CODE>@IF(name)</CODE> name will allow
+browse data from the named interface. In both cases, CUPS only
+allows data from the network that the interface(s) are configured
+for - data arriving on the interface from a foreign network will
+<em>not</em> be allowed.</P>
+
+
+<H2 CLASS="title"><A NAME="BrowseDeny">BrowseDeny</A></H2>
+
+<H3>Examples</H3>
+
+<PRE CLASS="command">
+BrowseDeny from all
+BrowseDeny from none
+BrowseDeny from 192.0.2
+BrowseDeny from 192.0.2.0/24
+BrowseDeny from 192.0.2.0/255.255.255.0
+BrowseDeny from *.example.com
+BrowseDeny from @LOCAL
+BrowseDeny from @IF(name)
+</PRE>
+
+<H3>Description</H3>
+
+<P>The <CODE>BrowseDeny</CODE> directive specifies a system or
+network to reject browse packets from. The default is to not deny
+browse packets from any hosts.</P>
+
+<P>Host and domain name matching require that you enable the <A
+HREF="#HostNameLookups"><CODE>HostNameLookups</CODE></A>
+directive.</P>
+
+<P>IP address matching supports exact matches, partial addresses that match
+networks using netmasks of 255.0.0.0, 255.255.0.0, and 255.255.255.0, or network
+addresses using the specified netmask or bit count. The <CODE>/mm</CODE>
+notation specifies a CIDR netmask, a shown in <A HREF="TABLE1">Table 1</A>.</P>
+
+<P>The <CODE>@LOCAL</CODE> name will block browse data from all
+local interfaces. The <CODE>@IF(name)</CODE> name will block
+browse data from the named interface. In both cases, CUPS only
+blocks data from the network that the interface(s) are configured
+for - data arriving on the interface from a foreign network will
+<em>not</em> be blocked.</P>
+
+
+<H2 CLASS="title"><A NAME="BrowseInterval">BrowseInterval</A></H2>
+
+<H3>Examples</H3>
+
+<PRE CLASS="command">
+BrowseInterval 0
+BrowseInterval 30
+</PRE>
+
+<H3>Description</H3>
+
+<P>The <CODE>BrowseInterval</CODE> directive specifies the
+maximum amount of time between browsing updates. Specifying a
+value of 0 seconds disables outgoing browse updates but allows a
+server to receive printer information from other hosts.</P>
+
+<P>The <CODE>BrowseInterval</CODE> value should always be less
+than the <A HREF="#BrowseTimeout"><CODE>BrowseTimeout</CODE></A>
+value. Otherwise printers and classes will disappear from client
+systems between updates.</P>
+
+
+<H2 CLASS="title"><A NAME="BrowseLocalOptions">BrowseLocalOptions</A></H2>
+
+<H3>Examples</H3>
+
+<PRE CLASS="command">
+BrowseLocalOptions compression=yes
+BrowseLocalOptions encryption=required
+BrowseLocalOptions compression=yes&amp;encryption=required
+</PRE>
+
+<H3>Description</H3>
+
+<P>The <CODE>BrowseLocalOptions</CODE> directive specifies
+additional IPP backend options to advertise with local shared
+printers. The default is to not include any options.</P>
+
+
 <H2 CLASS="title"><SPAN CLASS="info">CUPS 1.2/OS X 10.5</SPAN><A NAME="BrowseLocalProtocols">BrowseLocalProtocols</A></H2>
 
 <H3>Examples</H3>
@@ -348,7 +498,9 @@
 <PRE CLASS="command">
 BrowseLocalProtocols all
 BrowseLocalProtocols none
+BrowseLocalProtocols cups
 BrowseLocalProtocols dnssd
+BrowseLocalProtocols cups dnssd
 </PRE>
 
 <H3>Description</H3>
@@ -359,6 +511,215 @@
 with spaces. The default is "<CODE>@CUPS_BROWSE_LOCAL_PROTOCOLS@</CODE>".</P>
 
 
+<H2 CLASS="title"><A NAME="BrowseOrder">BrowseOrder</A></H2>
+
+<H3>Examples</H3>
+
+<PRE CLASS="command">
+BrowseOrder allow,deny
+BrowseOrder deny,allow
+</PRE>
+
+<H3>Description</H3>
+
+<P>The <CODE>BrowseOrder</CODE> directive specifies the order of
+allow/deny processing. The default order is
+<CODE>deny,allow</CODE>:</P>
+
+<UL>
+
+	<LI><CODE>allow,deny</CODE> - Deny browse packets by
+	default, then check <CODE>BrowseAllow</CODE> lines
+	followed by <CODE>BrowseDeny</CODE> lines.</LI>
+
+	<LI><CODE>deny,allow</CODE> - Allow browse packets by
+	default, then check <CODE>BrowseDeny</CODE> lines
+	followed by <CODE>BrowseAllow</CODE> lines.</LI>
+
+</UL>
+
+
+<H2 CLASS="title"><A NAME="BrowsePoll">BrowsePoll</A></H2>
+
+<H3>Examples</H3>
+
+<PRE CLASS="command">
+BrowsePoll 192.0.2.2:631
+BrowsePoll host.example.com:631
+</PRE>
+
+<H3>Description</H3>
+
+<P>The <CODE>BrowsePoll</CODE> directive polls a server for
+available printers once every <A
+HREF="#BrowseInterval"><CODE>BrowseInterval</CODE></A> seconds.
+Multiple <CODE>BrowsePoll</CODE> directives can be specified to
+poll multiple servers.</P>
+
+<P>If <CODE>BrowseInterval</CODE> is set to 0 then the server is
+polled once every 30 seconds.</P>
+
+
+<H2 CLASS="title"><A NAME="BrowsePort">BrowsePort</A></H2>
+
+<H3>Examples</H3>
+
+<PRE CLASS="command">
+BrowsePort 631
+BrowsePort 9999
+</PRE>
+
+<H3>Description</H3>
+
+<P>The <CODE>BrowsePort</CODE> directive specifies the UDP port number
+used for browse packets. The default port number is 631.</P>
+
+<BLOCKQUOTE><B>Note:</B>
+
+<P>You must set the <CODE>BrowsePort</CODE> to the same value
+on all of the systems that you want to see.
+
+</BLOCKQUOTE>
+
+
+<H2 CLASS="title"><SPAN CLASS="info">CUPS 1.1.10</SPAN><A NAME="BrowseProtocols">BrowseProtocols</A></H2>
+
+<H3>Examples</H3>
+
+<PRE CLASS="command">
+BrowseProtocols all
+BrowseProtocols none
+BrowseProtocols cups
+BrowseProtocols dnssd
+BrowseProtocols cups dnssd
+</PRE>
+
+<H3>Description</H3>
+
+<P>The <CODE>BrowseProtocols</CODE> directive specifies the
+protocols to use when showing and advertising shared printers on
+the local network. Multiple protocols can be specified by
+separating them with spaces. The default protocol is
+"<CODE>@CUPS_BROWSE_LOCAL_PROTOCOLS@</CODE>" for
+<A HREF="#BrowseLocalProtocols"><CODE>BrowseLocalProtocols</CODE></A> and
+"<CODE>@CUPS_BROWSE_REMOTE_PROTOCOLS@</CODE>" for
+<A HREF="#BrowseRemoteProtocols"><CODE>BrowseRemoteProtocols</CODE></A>.</P>
+
+
+<H2 CLASS="title"><A NAME="BrowseRelay">BrowseRelay</A></H2>
+
+<H3>Examples</H3>
+
+<PRE CLASS="command">
+BrowseRelay 193.0.2.1 192.0.2.255
+BrowseRelay 193.0.2.0/255.255.255.0 192.0.2.255
+BrowseRelay 193.0.2.0/24 192.0.2.255
+BrowseRelay *.example.com 192.0.2.255
+BrowseRelay host.example.com 192.0.2.255
+</PRE>
+
+<H3>Description</H3>
+
+<P>The <CODE>BrowseRelay</CODE> directive specifies source and
+destination addresses for relaying browsing information from one
+host or network to another. Multiple <CODE>BrowseRelay</CODE>
+directives can be specified as needed.</P>
+
+<P><CODE>BrowseRelay</CODE> is typically used on systems that
+bridge multiple subnets using one or more network interfaces. It
+can also be used to relay printer information from polled servers
+with the line:</P>
+
+<PRE CLASS="command">
+BrowseRelay 127.0.0.1 192.0.2.255
+</PRE>
+
+<P>This effectively provides access to printers on a WAN for all
+clients on the LAN. Use multiple <CODE>BrowseRelay</CODE> lines to
+relay information to multiple subnets.</P>
+
+
+<H2 CLASS="title"><A NAME="BrowseRemoteOptions">BrowseRemoteOptions</A></H2>
+
+<H3>Examples</H3>
+
+<PRE CLASS="command">
+BrowseRemoteOptions compression=yes
+BrowseRemoteOptions encryption=required
+BrowseRemoteOptions ?compression=yes&amp;encryption=required
+</PRE>
+
+<H3>Description</H3>
+
+<P>The <CODE>BrowseRemoteOptions</CODE> directive specifies
+additional IPP backend options to include with remote shared
+printers. If the options string begins with a question mark (?),
+the options replace any options specified by the remote server.
+The default is to not include any options.</P>
+
+
+<H2 CLASS="title"><SPAN CLASS="info">CUPS 1.2/Mac OS X 10.5</SPAN><A NAME="BrowseRemoteProtocols">BrowseRemoteProtocols</A></H2>
+
+<H3>Examples</H3>
+
+<PRE CLASS="command">
+BrowseRemoteProtocols all
+BrowseRemoteProtocols none
+BrowseRemoteProtocols cups
+</PRE>
+
+<H3>Description</H3>
+
+<P>The <CODE>BrowseRemoteProtocols</CODE> directive specifies the
+protocols to use when finding remote shared printers on the
+network. Multiple protocols can be specified by separating them
+with spaces. The default is "<CODE>@CUPS_BROWSE_REMOTE_PROTOCOLS@</CODE>".</P>
+
+
+<H2 CLASS="title"><A NAME="BrowseShortNames">BrowseShortNames</A></H2>
+
+<H3>Examples</H3>
+
+<PRE CLASS="command">
+BrowseShortNames Yes
+BrowseShortNames No
+</PRE>
+
+<H3>Description</H3>
+
+<P>The <CODE>BrowseShortNames</CODE> directive specifies whether
+or not short names are used for remote printers when possible.
+Short names are just the remote printer name, without the server
+("printer"). If more than one remote printer is detected with the
+same name, the printers will have long names ("printer@server1",
+"printer@server2".)</P>
+
+<P>The default value for this option is <CODE>@CUPS_BROWSE_SHORT_NAMES@</CODE>.</P>
+
+
+<H2 CLASS="title"><A NAME="BrowseTimeout">BrowseTimeout</A></H2>
+
+<H3>Examples</H3>
+
+<PRE CLASS="command">
+BrowseTimeout 300
+BrowseTimeout 60
+</PRE>
+
+<H3>Description</H3>
+
+<P>The <CODE>BrowseTimeout</CODE> directive sets the timeout for
+printer or class information that is received in browse packets.
+Once a printer or class times out it is removed from the list of
+available destinations.</P>
+
+<P>The <CODE>BrowseTimeout</CODE> value should always be greater
+than the <A
+HREF="#BrowseInterval"><CODE>BrowseInterval</CODE></A> value.
+Otherwise printers and classes will disappear from client systems
+between updates.</P>
+
+
 <H2 CLASS="title"><A NAME="BrowseWebIF">BrowseWebIF</A></H2>
 
 <H3>Examples</H3>
@@ -387,9 +748,24 @@
 <H3>Description</H3>
 
 <P>The <CODE>Browsing</CODE> directive controls whether or not
-printer sharing is enabled. The default setting is
+network printer browsing is enabled. The default setting is
 <CODE>@CUPS_BROWSING@</CODE>.</P>
 
+<P>This directive does not enable sharing of local printers by
+itself; you must also use the <A
+HREF="#BrowseAddress"><CODE>BrowseAddress</CODE></A> or <A
+HREF="#BrowseProtocols"><CODE>BrowseProtocols</CODE></A>
+directives to advertise local printers to other systems.</P>
+
+<BLOCKQUOTE><B>Note:</B>
+
+<P>If you are using HP-UX 10.20 and a subnet that is not 24,
+16, or 8 bits, printer browsing (and in fact all broadcast
+reception) will not work. This problem appears to be fixed in
+HP-UX 11.0.</P>
+
+</BLOCKQUOTE>
+
 
 <H2 CLASS="title"><SPAN CLASS="info">CUPS 1.1.7</SPAN><A NAME="Classification">Classification</A></H2>
 
@@ -940,6 +1316,25 @@
 <P>The <CODE>GSSServiceName</CODE> directive sets the Kerberos service name to use. The default is <CODE>@CUPS_DEFAULT_GSSSERVICE_NAME@</CODE> for compatibility with Microsoft Windows.</P>
 
 
+<H2 CLASS="title"><SPAN CLASS="info">CUPS 1.1.10</SPAN><A NAME="HideImplicitMembers">HideImplicitMembers</A></H2>
+
+<H3>Examples</H3>
+
+<PRE CLASS="command">
+HideImplicitMembers Yes
+HideImplicitMembers No
+</PRE>
+
+<H3>Description</H3>
+
+<P>The <CODE>HideImplicitMembers</CODE> directive controls
+whether the individual printers in an implicit class are hidden
+from the user. The default is <CODE>Yes</CODE>.</P>
+
+<P><A HREF="#ImplicitClasses"><CODE>ImplicitClasses</CODE></A>
+must be enabled for this directive to have any effect.</P>
+
+
 <H2 CLASS="title"><A NAME="HostNameLookups">HostNameLookups</A></H2>
 
 <H3>Examples</H3>
@@ -966,6 +1361,25 @@
 required.</P>
 
 
+<H2 CLASS="title"><SPAN CLASS="info">CUPS 1.1.10</SPAN><A NAME="HideImplicitMembers">HideImplicitMembers</A></H2>
+
+<H3>Examples</H3>
+
+<PRE CLASS="command">
+HideImplicitMembers Yes
+HideImplicitMembers No
+</PRE>
+
+<H3>Description</H3>
+
+<P>The <CODE>HideImplicitMembers</CODE> directive controls
+whether the individual printers in an implicit class are hidden
+from the user. The default is <CODE>Yes</CODE>.</P>
+
+<P><A HREF="#ImplicitClasses"><CODE>ImplicitClasses</CODE></A>
+must be enabled for this directive to have any effect.</P>
+
+
 <H2 CLASS="title"><SPAN CLASS="info">CUPS 1.1.9</SPAN><A NAME="Include">Include</A></H2>
 
 <H3>Examples</H3>
--- a/man/cupsd.conf.man.in
+++ b/man/cupsd.conf.man.in
@@ -94,9 +94,101 @@
 Specifies whether to purge job history data automatically when
 it is no longer required for quotas.
 .TP 5
-BrowseLocalProtocols [All] [DNSSD]
+BrowseAddress ip-address
+.TP 5
+BrowseAddress @IF(name)
+.TP 5
+BrowseAddress @LOCAL
+.br
+Specifies a broadcast address for outgoing printer information packets.
+.TP 5
+BrowseAllow all
+.TP 5
+BrowseAllow none
+.TP 5
+BrowseAllow host.domain.com
+.TP 5
+BrowseAllow *.domain.com
+.TP 5
+BrowseAllow ip-address
+.TP 5
+BrowseAllow ip-address/netmask
+.TP 5
+BrowseAllow ip-address/mm
+.TP 5
+BrowseAllow @IF(name)
+.TP 5
+BrowseAllow @LOCAL
+.br
+Allows incoming printer information packets from the named host or address.
+.TP 5
+BrowseDeny all
+.TP 5
+BrowseDeny none
+.TP 5
+BrowseDeny host.domain.com
+.TP 5
+BrowseDeny *.domain.com
+.TP 5
+BrowseDeny ip-address
+.TP 5
+BrowseDeny ip-address/netmask
+.TP 5
+BrowseDeny ip-address/mm
+.TP 5
+BrowseDeny @IF(name)
+.TP 5
+BrowseDeny @LOCAL
+.br
+Denies incoming printer information packets from the named host or address.
+.TP 5
+BrowseInterval seconds
+.br
+Specifies the maximum interval between printer information broadcasts.
+.TP 5
+BrowseOrder allow,deny
+.TP 5
+BrowseOrder deny,allow
 .br
-Specifies the protocols to use for local printer sharing.
+Specifies the order of printer information access control (allow,deny or deny,allow)
+.TP 5
+BrowsePoll host-or-ip-address
+.br
+Specifies a server to poll for printer information.
+.TP 5
+BrowsePort port
+.br
+Specifies the port to listen to for printer information packets.
+.TP 5
+BrowseProtocols [All] [CUPS] [DNSSD]
+.br
+Specifies the protocols to use for printer browsing.
+.TP 5
+BrowseLocalProtocols [All] [CUPS] [DNSSD]
+.br
+Specifies the protocols to use for local printer browsing.
+.TP 5
+BrowseRemoteProtocols [All] [CUPS] [DNSSD]
+.br
+Specifies the protocols to use for remote printer browsing.
+.TP 5
+BrowseRelay from-address to-address
+.br
+Specifies that printer information packets should be relayed from one host or
+network to another.
+.TP 5
+BrowseShortNames Yes
+.TP 5
+BrowseShortNames No
+.br
+Specifies whether remote printers will use short names ("printer") or not
+("printer@server"). This option is ignored if more than one remote printer
+exists with the same name.
+.TP 5
+BrowseTimeout seconds
+.br
+Specifies the maximum interval between printer information updates before
+remote printers will be removed from the list of available printers.
 .TP 5
 BrowseWebIF Yes
 .TP 5
@@ -255,6 +347,12 @@
 Specifies the service name when using Kerberos authentication. The default
 service name is "@CUPS_DEFAULT_GSSSERVICENAME@".
 .TP 5
+HideImplicitMembers Yes
+.TP 5
+HideImplicitMembers No
+.br
+Specifies whether to hide members of implicit classes.
+.TP 5
 HostNameLookups On
 .TP 5
 HostNameLookups Off
@@ -263,6 +361,21 @@
 .br
 Specifies whether or not to do reverse lookups on client addresses.
 .TP 5
+ImplicitAnyClasses Yes
+.TP 5
+ImplicitAnyClasses No
+.br
+Specifies whether or not to create implicit classes for local and
+remote printers, e.g. "AnyPrinter" from "Printer", "Printer@server1",
+and "Printer@server2".
+.TP 5
+ImplicitClasses Yes
+.TP 5
+ImplicitClasses No
+.br
+Specifies whether or not to create implicit classes from identical
+remote printers.
+.TP 5
 Include filename
 .br
 Includes the named file.
--- a/man/cupsctl.man
+++ b/man/cupsctl.man
@@ -22,7 +22,7 @@
 ] [ -h
 .I server[:port]
 ] [ --[no-]debug-logging ] [ --[no-]remote-admin ] [ --[no-]remote-any ]
-[ --[no-]share-printers ] [ --[no-]user-cancel-any ]
+[ --[no-]remote-printers ] [ --[no-]share-printers ] [ --[no-]user-cancel-any ]
 [
 .I name=value
 ]
@@ -57,6 +57,11 @@
 .br
 Enables or disables printing from any address, e.g. the Internet.
 .TP 5
+--[no-]remote-printers
+.br
+Enables or disables the display of remote printers shared via the CUPS, LDAP,
+or SLP protocols.
+.TP 5
 --[no-]share-printers
 .br
 Enables or disables sharing of local printers with other computers.
--- /dev/null
+++ b/scheduler/testdirsvc.c
@@ -0,0 +1,324 @@
+/*
+ * "$Id$"
+ *
+ *   Browsing test program for CUPS.
+ *
+ *   Copyright 2007-2011 by Apple Inc.
+ *   Copyright 1997-2007 by Easy Software Products, all rights reserved.
+ *
+ *   These coded instructions, statements, and computer programs are the
+ *   property of Apple Inc. and are protected by Federal copyright
+ *   law.  Distribution and use rights are outlined in the file "LICENSE.txt"
+ *   which should have been included with this file.  If this file is
+ *   file is missing or damaged, see the license at "http://www.cups.org/".
+ *
+ * Contents:
+ *
+ *   main()  - Simulate one or more remote printers.
+ *   usage() - Show program usage...
+ */
+
+/*
+ * Include necessary headers...
+ */
+
+#include <cups/cups.h>
+#include <cups/string-private.h>
+
+
+/*
+ * Local functions...
+ */
+
+static void	usage(void) __attribute__((noreturn));
+
+
+/*
+ * 'main()' - Simulate one or more remote printers.
+ */
+
+int					/* O - Exit status */
+main(int  argc,				/* I - Number of command-line arguments */
+     char *argv[])			/* I - Command-line arguments */
+{
+  int		i,			/* Looping var */
+		printer,		/* Current printer */
+		num_printers,		/* Number of printers */
+		pclass,			/* Current printer class */
+		num_pclasses,		/* Number of printer classes */
+		server,			/* Current server */
+		num_servers,		/* Number of servers */
+		count,			/* Number of printers sent this cycle */
+		interval,		/* Browse Interval */
+		lease,			/* Browse lease-duration */
+		continuous,		/* Run continuously? */
+		port,			/* Browse port */
+		sock,			/* Browse socket */
+		val,			/* Socket option value */
+		seconds,		/* Seconds until next cycle */
+		verbose;		/* Verbose output? */
+  const char	*options;		/* Options for URIs */
+  time_t	curtime;		/* Current UNIX time */
+  struct tm	*curdate;		/* Current date and time */
+  struct sockaddr_in addr;		/* Broadcast address */
+  char		packet[1540];		/* Data packet */
+  static const char * const names[26] =	/* Printer names */
+		{
+		  "alpha",
+		  "bravo",
+		  "charlie",
+		  "delta",
+		  "echo",
+		  "foxtrot",
+		  "golf",
+		  "hotel",
+		  "india",
+		  "juliet",
+		  "kilo",
+		  "lima",
+		  "mike",
+		  "november",
+		  "oscar",
+		  "papa",
+		  "quebec",
+		  "romeo",
+		  "sierra",
+		  "tango",
+		  "uniform",
+		  "victor",
+		  "wiskey",
+		  "x-ray",
+		  "yankee",
+		  "zulu"
+		};
+
+
+ /*
+  * Process command-line arguments...
+  */
+
+  num_printers = 10;
+  num_pclasses = 5;
+  num_servers  = 1;
+  interval     = 30;
+  lease        = 60;
+  port         = 0;
+  verbose      = 0;
+  continuous   = 0;
+  options      = NULL;
+
+  for (i = 1; i < argc; i ++)
+  {
+    if (!strcmp(argv[i], "-c"))
+      continuous = 1;
+    else if (!strcmp(argv[i], "-i"))
+    {
+      i ++;
+      if (i < argc)
+        interval = atoi(argv[i]);
+      else
+        usage();
+
+      continuous = 1;
+    }
+    else if (!strcmp(argv[i], "-l"))
+    {
+      i ++;
+      if (i < argc)
+        lease = atoi(argv[i]);
+      else
+        usage();
+    }
+    else if (!strcmp(argv[i], "-o"))
+    {
+      i ++;
+      if (i < argc)
+        options = argv[i];
+      else
+        usage();
+    }
+    else if (!strcmp(argv[i], "-C"))
+    {
+      i ++;
+      if (i < argc)
+        num_pclasses = atoi(argv[i]);
+      else
+        usage();
+    }
+    else if (!strcmp(argv[i], "-p"))
+    {
+      i ++;
+      if (i < argc)
+        num_printers = atoi(argv[i]);
+      else
+        usage();
+    }
+    else if (!strcmp(argv[i], "-s"))
+    {
+      i ++;
+      if (i < argc)
+        num_servers = atoi(argv[i]);
+      else
+        usage();
+    }
+    else if (!strcmp(argv[i], "-v"))
+      verbose = 1;
+    else if (isdigit(argv[i][0] & 255))
+    {
+      port = atoi(argv[i]);
+    }
+    else
+      usage();
+  }
+
+  if ((num_printers <= 0 && num_pclasses <= 0) || num_servers <= 0 ||
+      interval <= 0 || lease < 1 || port <= 0)
+    usage();
+
+ /*
+  * Open a broadcast socket...
+  */
+
+  if ((sock = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
+  {
+    perror("Unable to open broadcast socket");
+    return (1);
+  }
+
+ /*
+  * Set the "broadcast" flag...
+  */
+
+  val = 1;
+  if (setsockopt(sock, SOL_SOCKET, SO_BROADCAST, &val, sizeof(val)))
+  {
+    perror("Unable to put socket in broadcast mode");
+
+    close(sock);
+    return (1);
+  }
+
+ /*
+  * Broadcast to 127.0.0.1 (localhost)
+  */
+
+  memset(&addr, 0, sizeof(addr));
+  addr.sin_addr.s_addr = htonl(0x7f000001);
+  addr.sin_family      = AF_INET;
+  addr.sin_port        = htons(port);
+
+ /*
+  * Send virtual printers continuously until we are stopped.
+  */
+
+  for (;;)
+  {
+   /*
+    * Start a new cycle of N printers...
+    */
+
+    printf("Sending %d printers from %d servers...\n", num_printers,
+           num_servers);
+
+    count   = num_servers * (num_printers + num_pclasses) / interval + 1;
+    curtime = time(NULL);
+    curdate = localtime(&curtime);
+    seconds = interval;
+
+    for (i = 0, printer = 0; printer < num_printers; printer ++)
+    {
+      for (server = 0; server < num_servers; server ++, i ++)
+      {
+        if (i == count)
+	{
+	  seconds --;
+	  i = 0;
+	  sleep(1);
+	  curtime = time(NULL);
+	  curdate = localtime(&curtime);
+	}
+
+        snprintf(packet, sizeof(packet),
+	         "%x %x ipp://testserver-%d/printers/%s-%d \"Server Room %d\" "
+		 "\"Test Printer %d\" \"Acme Blazer 2000\"%s%s "
+		 "lease-duration=%d\n",
+                 CUPS_PRINTER_REMOTE, IPP_PRINTER_IDLE, server + 1,
+		 names[printer % 26], printer / 26 + 1, server + 1,
+		 printer + 1, options ? " ipp-options=" : "",
+		 options ? options : "", lease);
+
+        if (verbose)
+	  printf("[%02d:%02d:%02d] %s", curdate->tm_hour, curdate->tm_min,
+	         curdate->tm_sec, packet);
+
+        if (sendto(sock, packet, strlen(packet), 0,
+	           (struct sockaddr *)&addr, sizeof(addr)) < 0)
+	  perror("Unabled to send packet");
+      }
+    }
+
+
+    for (i = 0, pclass = 0; pclass < num_pclasses; pclass ++)
+    {
+      for (server = 0; server < num_servers; server ++, i ++)
+      {
+        if (i == count)
+	{
+	  seconds --;
+	  i = 0;
+	  sleep(1);
+	  curtime = time(NULL);
+	  curdate = localtime(&curtime);
+	}
+
+        snprintf(packet, sizeof(packet),
+	         "%x %x ipp://testserver-%d/classes/class-%s-%d \"Server Room %d\" "
+		 "\"Test Class %d\" \"Acme Blazer 2000\"%s%s "
+		 "lease-duration=%d\n",
+                 CUPS_PRINTER_REMOTE | CUPS_PRINTER_CLASS, IPP_PRINTER_IDLE,
+		 server + 1, names[pclass % 26], pclass / 26 + 1, server + 1,
+		 pclass + 1, options ? " ipp-options=" : "",
+		 options ? options : "", lease);
+
+        if (verbose)
+	  printf("[%02d:%02d:%02d] %s", curdate->tm_hour, curdate->tm_min,
+	         curdate->tm_sec, packet);
+
+        if (sendto(sock, packet, strlen(packet), 0,
+	           (struct sockaddr *)&addr, sizeof(addr)) < 0)
+	  perror("Unabled to send packet");
+      }
+    }
+
+    if (!continuous)
+      break;
+
+   /*
+    * Sleep for any remaining time...
+    */
+
+    if (seconds > 0)
+      sleep(seconds);
+  }
+
+  return (0);
+}
+
+
+/*
+ * 'usage()' - Show program usage...
+ */
+
+static void
+usage(void)
+{
+  puts("Usage: testdirsvc [-c] [-i interval] [-l lease-duration] "
+       "[-o ipp-options] [-p printers] "
+       "[-C classes] [-s servers] [-v] port");
+  exit(0);
+}
+
+
+/*
+ * End of "$Id$".
+ */
--- /dev/null
+++ b/scheduler/cups-polld.c
@@ -0,0 +1,469 @@
+/*
+ * "$Id$"
+ *
+ *   Polling daemon for CUPS.
+ *
+ *   Copyright 2007-2011 by Apple Inc.
+ *   Copyright 1997-2006 by Easy Software Products, all rights reserved.
+ *
+ *   These coded instructions, statements, and computer programs are the
+ *   property of Apple Inc. and are protected by Federal copyright
+ *   law.  Distribution and use rights are outlined in the file "LICENSE.txt"
+ *   which should have been included with this file.  If this file is
+ *   file is missing or damaged, see the license at "http://www.cups.org/".
+ *
+ * Contents:
+ *
+ *   main()           - Open sockets and poll until we are killed...
+ *   dequote()        - Remote quotes from a string.
+ *   poll_server()    - Poll the server for the given set of printers or
+ *                      classes.
+ *   sighup_handler() - Handle 'hangup' signals to restart polling.
+ */
+
+/*
+ * Include necessary headers...
+ */
+
+#include <cups/cups-private.h>
+#include <signal.h>
+
+
+/*
+ * Local globals...
+ */
+
+static int	restart_polling = 1;
+
+
+/*
+ * Local functions...
+ */
+
+static char	*dequote(char *d, const char *s, int dlen);
+static int	poll_server(http_t *http, int sock, int port, int interval,
+			    const char *prefix);
+static void	sighup_handler(int sig);
+
+
+/*
+ * 'main()' - Open sockets and poll until we are killed...
+ */
+
+int					/* O - Exit status */
+main(int  argc,				/* I - Number of command-line args */
+     char *argv[])			/* I - Command-line arguments */
+{
+  http_t	*http;			/* HTTP connection */
+  int		interval;		/* Polling interval */
+  int		sock;			/* Browser sock */
+  int		port;			/* Browser port */
+  int		val;			/* Socket option value */
+  int		seconds,		/* Seconds left from poll */
+		remain;			/* Total remaining time to sleep */
+  char		prefix[1024];		/* Prefix for log messages */
+#if defined(HAVE_SIGACTION) && !defined(HAVE_SIGSET)
+  struct sigaction action;		/* Actions for POSIX signals */
+#endif /* HAVE_SIGACTION && !HAVE_SIGSET */
+
+
+ /*
+  * Catch hangup signals for when the network changes...
+  */
+
+#ifdef HAVE_SIGSET /* Use System V signals over POSIX to avoid bugs */
+  sigset(SIGHUP, sighup_handler);
+#elif defined(HAVE_SIGACTION)
+  memset(&action, 0, sizeof(action));
+
+  sigemptyset(&action.sa_mask);
+  sigaddset(&action.sa_mask, SIGHUP);
+  action.sa_handler = sighup_handler;
+  sigaction(SIGHUP, &action, NULL);
+#else
+  signal(SIGHUP, sighup_handler);
+#endif /* HAVE_SIGSET */
+
+ /*
+  * Don't buffer log messages...
+  */
+
+  setbuf(stderr, NULL);
+
+ /*
+  * The command-line must contain the following:
+  *
+  *    cups-polld server server-port interval port
+  */
+
+  if (argc != 5)
+  {
+    fputs("Usage: cups-polld server server-port interval port\n", stderr);
+    return (1);
+  }
+
+  interval = atoi(argv[3]);
+  port     = atoi(argv[4]);
+
+  if (interval < 2)
+    interval = 2;
+
+  snprintf(prefix, sizeof(prefix), "[cups-polld %s:%d]", argv[1], atoi(argv[2]));
+
+ /*
+  * Open a broadcast socket...
+  */
+
+  if ((sock = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
+  {
+    fprintf(stderr, "ERROR: %s Unable to open broadcast socket: %s\n", prefix,
+            strerror(errno));
+    return (1);
+  }
+
+ /*
+  * Set the "broadcast" flag...
+  */
+
+  val = 1;
+  if (setsockopt(sock, SOL_SOCKET, SO_BROADCAST, &val, sizeof(val)))
+  {
+    fprintf(stderr, "ERROR: %s Unable to put socket in broadcast mode: %s\n",
+            prefix, strerror(errno));
+
+    close(sock);
+    return (1);
+  }
+
+ /*
+  * Loop forever, asking for available printers and classes...
+  */
+
+  for (http = NULL; !ferror(stderr);)
+  {
+   /*
+    * Open a connection to the server...
+    */
+
+    if (restart_polling || !http)
+    {
+      restart_polling = 0;
+      httpClose(http);
+
+      if ((http = httpConnectEncrypt(argv[1], atoi(argv[2]),
+                                     cupsEncryption())) == NULL)
+      {
+	fprintf(stderr, "ERROR: %s Unable to connect to %s on port %s.\n",
+        	prefix, argv[1], argv[2]);
+      }
+    }
+
+   /*
+    * Get the printers and classes...
+    */
+
+    remain = interval;
+
+    if (http && (seconds = poll_server(http, sock, port, interval, prefix)) > 0)
+      remain -= seconds;
+
+   /*
+    * Sleep for any remaining time...
+    */
+
+    if (remain > 0 && !restart_polling)
+      sleep(remain);
+  }
+
+  return (1);
+}
+
+
+/*
+ * 'dequote()' - Remote quotes from a string.
+ */
+
+static char *				/* O - Dequoted string */
+dequote(char       *d,			/* I - Destination string */
+        const char *s,			/* I - Source string */
+	int        dlen)		/* I - Destination length */
+{
+  char	*dptr;				/* Pointer into destination */
+
+
+  if (s)
+  {
+    for (dptr = d, dlen --; *s && dlen > 0; s ++)
+      if (*s != '\"')
+      {
+	*dptr++ = *s;
+	dlen --;
+      }
+
+    *dptr = '\0';
+  }
+  else
+    *d = '\0';
+
+  return (d);
+}
+
+
+/*
+ * 'poll_server()' - Poll the server for the given set of printers or classes.
+ */
+
+static int				/* O - Number of seconds or -1 on error */
+poll_server(http_t      *http,		/* I - HTTP connection */
+	    int         sock,		/* I - Broadcast sock */
+	    int         port,		/* I - Broadcast port */
+	    int         interval,	/* I - Polling interval */
+	    const char	*prefix)	/* I - Prefix for log messages */
+{
+  int			seconds;	/* Number of seconds */
+  int			count,		/* Current number of printers/classes */
+			max_count;	/* Maximum printers/classes per second */
+  ipp_t			*request,	/* Request data */
+			*response;	/* Response data */
+  ipp_attribute_t	*attr;		/* Current attribute */
+  const char		*uri;		/* printer-uri */
+  char			info[1024],	/* printer-info */
+			job_sheets[1024],/* job-sheets-default */
+			location[1024],	/* printer-location */
+			make_model[1024];
+					/* printer-make-and-model */
+  cups_ptype_t		type;		/* printer-type */
+  ipp_pstate_t		state;		/* printer-state */
+  int			accepting;	/* printer-is-accepting-jobs */
+  struct sockaddr_in	addr;		/* Broadcast address */
+  char			packet[1540];	/* Data packet */
+  static const char * const attrs[] =	/* Requested attributes */
+			{
+			  "job-sheets-default",
+			  "printer-info",
+			  "printer-is-accepting-jobs",
+			  "printer-location",
+			  "printer-make-and-model",
+			  "printer-name",
+			  "printer-state",
+			  "printer-type",
+			  "printer-uri-supported"
+			};
+
+
+ /*
+  * Broadcast to 127.0.0.1 (localhost)
+  */
+
+  memset(&addr, 0, sizeof(addr));
+  addr.sin_addr.s_addr = htonl(0x7f000001);
+  addr.sin_family      = AF_INET;
+  addr.sin_port        = htons(port);
+
+ /*
+  * Build a CUPS_GET_PRINTERS request and pass along a list of the
+  * attributes we are interested in along with the types of printers
+  * (and classes) we want.
+  */
+
+  request = ippNewRequest(CUPS_GET_PRINTERS);
+
+  ippAddStrings(request, IPP_TAG_OPERATION, IPP_TAG_KEYWORD,
+               "requested-attributes", sizeof(attrs) / sizeof(attrs[0]),
+	       NULL, attrs);
+
+  ippAddInteger(request, IPP_TAG_OPERATION, IPP_TAG_ENUM,
+                "printer-type", 0);
+  ippAddInteger(request, IPP_TAG_OPERATION, IPP_TAG_ENUM,
+                "printer-type-mask",
+		CUPS_PRINTER_REMOTE | CUPS_PRINTER_IMPLICIT |
+		CUPS_PRINTER_NOT_SHARED);
+
+ /*
+  * Do the request and get back a response...
+  */
+
+  seconds  = time(NULL);
+  response = cupsDoRequest(http, request, "/");
+
+  if (cupsLastError() > IPP_OK_CONFLICT)
+  {
+    fprintf(stderr, "ERROR: %s CUPS-Get-Printers failed: %s\n", prefix,
+            cupsLastErrorString());
+    ippDelete(response);
+    return (-1);
+  }
+
+  if (response)
+  {
+   /*
+    * Figure out how many printers/classes we have...
+    */
+
+    for (attr = ippFindAttribute(response, "printer-name", IPP_TAG_NAME),
+             max_count = 0;
+	 attr != NULL;
+	 attr = ippFindNextAttribute(response, "printer-name", IPP_TAG_NAME),
+	     max_count ++);
+
+    fprintf(stderr, "DEBUG: %s Found %d printers.\n", prefix, max_count);
+
+    count     = 0;
+    max_count = 2 * max_count / interval + 1;
+
+   /*
+    * Loop through the printers or classes returned in the list...
+    */
+
+    for (attr = response->attrs; attr; attr = attr->next)
+    {
+     /*
+      * Skip leading attributes until we hit a printer...
+      */
+
+      while (attr && attr->group_tag != IPP_TAG_PRINTER)
+        attr = attr->next;
+
+      if (!attr)
+        break;
+
+     /*
+      * Pull the needed attributes from this printer...
+      */
+
+      uri           = NULL;
+      info[0]       = '\0';
+      job_sheets[0] = '\0';
+      location[0]   = '\0';
+      make_model[0] = '\0';
+      type          = CUPS_PRINTER_REMOTE;
+      accepting     = 1;
+      state         = IPP_PRINTER_IDLE;
+
+      while (attr != NULL && attr->group_tag == IPP_TAG_PRINTER)
+      {
+        if (!strcmp(attr->name, "job-sheets-default") &&
+	    (attr->value_tag == IPP_TAG_NAME ||
+	     attr->value_tag == IPP_TAG_KEYWORD))
+	{
+	  if (attr->num_values == 1)
+	    snprintf(job_sheets, sizeof(job_sheets), " job-sheets=%s",
+	             attr->values[0].string.text);
+          else
+	    snprintf(job_sheets, sizeof(job_sheets), " job-sheets=%s,%s",
+	             attr->values[0].string.text,
+	             attr->values[1].string.text);
+	}
+        else if (!strcmp(attr->name, "printer-uri-supported") &&
+	         attr->value_tag == IPP_TAG_URI)
+	  uri = attr->values[0].string.text;
+        else if (!strcmp(attr->name, "printer-info") &&
+		 attr->value_tag == IPP_TAG_TEXT)
+	  dequote(info, attr->values[0].string.text, sizeof(info));
+        else if (!strcmp(attr->name, "printer-is-accepting-jobs") &&
+	         attr->value_tag == IPP_TAG_BOOLEAN)
+	  accepting = attr->values[0].boolean;
+        else if (!strcmp(attr->name, "printer-location") &&
+	         attr->value_tag == IPP_TAG_TEXT)
+	  dequote(location, attr->values[0].string.text, sizeof(location));
+        else if (!strcmp(attr->name, "printer-make-and-model") &&
+	         attr->value_tag == IPP_TAG_TEXT)
+	  dequote(make_model, attr->values[0].string.text, sizeof(location));
+        else if (!strcmp(attr->name, "printer-state") &&
+	         attr->value_tag == IPP_TAG_ENUM)
+	  state = (ipp_pstate_t)attr->values[0].integer;
+        else if (!strcmp(attr->name, "printer-type") &&
+	         attr->value_tag == IPP_TAG_ENUM)
+	  type = (cups_ptype_t)attr->values[0].integer;
+
+        attr = attr->next;
+      }
+
+     /*
+      * See if we have everything needed...
+      */
+
+      if (uri == NULL)
+      {
+        if (attr == NULL)
+	  break;
+	else
+          continue;
+      }
+
+     /*
+      * Send the printer information...
+      */
+
+      type |= CUPS_PRINTER_REMOTE;
+
+      if (!accepting)
+	type |= CUPS_PRINTER_REJECTING;
+
+      snprintf(packet, sizeof(packet),
+               "%x %x %s \"%s\" \"%s\" \"%s\" lease-duration=%d%s\n",
+               type, state, uri, location, info, make_model, interval * 2,
+	       job_sheets);
+
+      fprintf(stderr, "DEBUG2: %s Sending %s", prefix, packet);
+
+      if (sendto(sock, packet, strlen(packet), 0,
+	         (struct sockaddr *)&addr, sizeof(addr)) <= 0)
+      {
+	ippDelete(response);
+	perror("cups-polld");
+	return (-1);
+      }
+
+     /*
+      * Throttle the local broadcasts as needed so that we don't
+      * overwhelm the local server...
+      */
+
+      count ++;
+      if (count >= max_count)
+      {
+       /*
+	* Sleep for a second...
+	*/
+
+	count = 0;
+
+	sleep(1);
+      }
+
+      if (!attr || restart_polling)
+        break;
+    }
+
+    ippDelete(response);
+  }
+
+ /*
+  * Return the number of seconds we used...
+  */
+
+  return (time(NULL) - seconds);
+}
+
+
+/*
+ * 'sighup_handler()' - Handle 'hangup' signals to restart polling.
+ */
+
+static void
+sighup_handler(int sig)			/* I - Signal number */
+{
+  (void)sig;
+
+  restart_polling = 1;
+
+#if !defined(HAVE_SIGSET) && !defined(HAVE_SIGACTION)
+  signal(SIGHUP, sighup_handler);
+#endif /* !HAVE_SIGSET && !HAVE_SIGACTION */
+}
+
+
+/*
+ * End of "$Id$".
+ */
--- a/scheduler/conf.c
+++ b/scheduler/conf.c
@@ -92,6 +92,12 @@
 #if defined(HAVE_DNSSD) || defined(HAVE_AVAHI)
   { "BrowseDNSSDSubTypes",	&DNSSDSubTypes,		CUPSD_VARTYPE_STRING },
 #endif /* HAVE_DNSSD || HAVE_AVAHI */
+  { "BrowseInterval",		&BrowseInterval,	CUPSD_VARTYPE_INTEGER },
+  { "BrowseLocalOptions",	&BrowseLocalOptions,	CUPSD_VARTYPE_STRING },
+  { "BrowsePort",		&BrowsePort,		CUPSD_VARTYPE_INTEGER },
+  { "BrowseRemoteOptions",	&BrowseRemoteOptions,	CUPSD_VARTYPE_STRING },
+  { "BrowseShortNames",		&BrowseShortNames,	CUPSD_VARTYPE_BOOLEAN },
+  { "BrowseTimeout",		&BrowseTimeout,		CUPSD_VARTYPE_INTEGER },
   { "BrowseWebIF",		&BrowseWebIF,		CUPSD_VARTYPE_BOOLEAN },
   { "Browsing",			&Browsing,		CUPSD_VARTYPE_BOOLEAN },
   { "CacheDir",			&CacheDir,		CUPSD_VARTYPE_STRING },
@@ -115,6 +121,9 @@
 #ifdef HAVE_GSSAPI
   { "GSSServiceName",		&GSSServiceName,	CUPSD_VARTYPE_STRING },
 #endif /* HAVE_GSSAPI */
+  { "HideImplicitMembers",	&HideImplicitMembers,	CUPSD_VARTYPE_BOOLEAN },
+  { "ImplicitClasses",		&ImplicitClasses,	CUPSD_VARTYPE_BOOLEAN },
+  { "ImplicitAnyClasses",	&ImplicitAnyClasses,	CUPSD_VARTYPE_BOOLEAN },
   { "JobKillDelay",		&JobKillDelay,		CUPSD_VARTYPE_TIME },
   { "JobRetryLimit",		&JobRetryLimit,		CUPSD_VARTYPE_INTEGER },
   { "JobRetryInterval",		&JobRetryInterval,	CUPSD_VARTYPE_TIME },
@@ -175,6 +184,7 @@
 #endif /* HAVE_AUTHORIZATION_H */
   { "TempDir",			&TempDir,		CUPSD_VARTYPE_PATHNAME },
   { "Timeout",			&Timeout,		CUPSD_VARTYPE_TIME },
+  { "UseNetworkDefault",	&UseNetworkDefault,	CUPSD_VARTYPE_BOOLEAN },
   { "WebInterface",		&WebInterface,		CUPSD_VARTYPE_BOOLEAN },
   { "PidFile",			&PidFile,		CUPSD_VARTYPE_STRING }
 };
@@ -555,6 +565,31 @@
 
   cupsdDeleteAllLocations();
 
+  if (NumBrowsers > 0)
+  {
+    free(Browsers);
+    Browsers = NULL;
+
+    NumBrowsers = 0;
+  }
+
+  if (NumPolled > 0)
+  {
+    free(Polled);
+
+    NumPolled = 0;
+  }
+
+  if (NumRelays > 0)
+  {
+    for (i = 0; i < NumRelays; i ++)
+      cupsArrayDelete(Relays[i].from);
+
+    free(Relays);
+
+    NumRelays = 0;
+  }
+
   cupsdDeleteAllListeners();
 
   old_remote_port = RemotePort;
@@ -713,6 +748,9 @@
   FilterLimit              = 0;
   FilterNice               = 0;
   HostNameLookups          = FALSE;
+  ImplicitClasses          = CUPS_DEFAULT_IMPLICIT_CLASSES;
+  ImplicitAnyClasses       = FALSE;
+  HideImplicitMembers      = TRUE;
   KeepAlive                = TRUE;
   KeepAliveTimeout         = DEFAULT_KEEPALIVE;
   ListenBackLog            = SOMAXCONN;
@@ -732,7 +770,12 @@
   Timeout                  = DEFAULT_TIMEOUT;
   WebInterface             = CUPS_DEFAULT_WEBIF;
 
+  BrowseInterval           = DEFAULT_INTERVAL;
+  BrowsePort               = ippPort();
   BrowseLocalProtocols     = parse_protocols(CUPS_DEFAULT_BROWSE_LOCAL_PROTOCOLS);
+  BrowseRemoteProtocols    = parse_protocols(CUPS_DEFAULT_BROWSE_REMOTE_PROTOCOLS);
+  BrowseShortNames         = CUPS_DEFAULT_BROWSE_SHORT_NAMES;
+  BrowseTimeout            = DEFAULT_TIMEOUT;
   BrowseWebIF              = FALSE;
   Browsing                 = CUPS_DEFAULT_BROWSING;
   DefaultShared            = CUPS_DEFAULT_DEFAULT_SHARED;
@@ -744,6 +787,9 @@
   cupsdSetString(&LPDConfigFile, CUPS_DEFAULT_LPD_CONFIG_FILE);
   cupsdSetString(&SMBConfigFile, CUPS_DEFAULT_SMB_CONFIG_FILE);
 
+  cupsdClearString(&BrowseLocalOptions);
+  cupsdClearString(&BrowseRemoteOptions);
+
   cupsdSetString(&ErrorPolicy, "stop-printer");
 
   JobHistory          = DEFAULT_HISTORY;
@@ -910,6 +956,12 @@
   }
 
  /*
+  * Get the access control list for browsing...
+  */
+
+  BrowseACL = cupsdFindLocation("CUPS_INTERNAL_BROWSE_ACL");
+
+ /*
   * Open the system log for cupsd if necessary...
   */
 
@@ -1229,6 +1281,24 @@
                   MaxClientsPerHost);
 
  /*
+  * Make sure that BrowseTimeout is at least twice the interval...
+  */
+
+  if (BrowseTimeout < (2 * BrowseInterval) || BrowseTimeout <= 0)
+  {
+    cupsdLogMessage(CUPSD_LOG_ALERT, "Invalid BrowseTimeout value %d.",
+                    BrowseTimeout);
+
+    if (BrowseInterval)
+      BrowseTimeout = BrowseInterval * 2;
+    else
+      BrowseTimeout = DEFAULT_TIMEOUT;
+
+    cupsdLogMessage(CUPSD_LOG_ALERT, "Reset BrowseTimeout to %d.",
+                    BrowseTimeout);
+  }
+
+ /*
   * Update the default policy, as needed...
   */
 
@@ -1532,6 +1602,7 @@
 
     cupsdLoadAllPrinters();
     cupsdLoadAllClasses();
+    cupsdLoadRemoteCache();
 
     cupsdCreateCommonData();
 
@@ -2534,9 +2605,11 @@
     * Add the protocol to the bitmask...
     */
 
-    if (!_cups_strcasecmp(valstart, "dnssd") ||
-	!_cups_strcasecmp(valstart, "dns-sd") ||
-	!_cups_strcasecmp(valstart, "bonjour"))
+    if (!_cups_strcasecmp(valstart, "cups"))
+      protocols |= BROWSE_CUPS;
+    else if (!_cups_strcasecmp(valstart, "dnssd") ||
+             !_cups_strcasecmp(valstart, "dns-sd") ||
+             !_cups_strcasecmp(valstart, "bonjour"))
       protocols |= BROWSE_DNSSD;
     else if (!_cups_strcasecmp(valstart, "all"))
       protocols |= BROWSE_ALL;
@@ -2566,12 +2639,18 @@
 					/* Line from file */
 			temp[HTTP_MAX_BUFFER],
 					/* Temporary buffer for value */
+			*ptr,		/* Pointer into line/temp */
 			*value,		/* Pointer to value */
 			*valueptr;	/* Pointer into value */
   int			valuelen;	/* Length of value */
   cupsd_var_t const	*var;		/* Current variable */
   http_addrlist_t	*addrlist,	/* Address list */
 			*addr;		/* Current address */
+  unsigned		ip[4],		/* Address value */
+			mask[4];	/* Netmask value */
+  cupsd_dirsvc_relay_t	*relay;		/* Relay data */
+  cupsd_dirsvc_poll_t	*pollp;		/* Polling data */
+  cupsd_location_t	*location;	/* Browse location */
   cups_file_t		*incfile;	/* Include file */
   char			incname[1024];	/* Include filename */
   struct group		*group;		/* Group */
@@ -2755,12 +2834,117 @@
 
       httpAddrFreeList(addrlist);
     }
+    else if (!_cups_strcasecmp(line, "BrowseAddress") && value)
+    {
+     /*
+      * Add a browse address to the list...
+      */
+
+      cupsd_dirsvc_addr_t	*dira;	/* New browse address array */
+
+
+      if (NumBrowsers == 0)
+        dira = malloc(sizeof(cupsd_dirsvc_addr_t));
+      else
+        dira = realloc(Browsers, (NumBrowsers + 1) * sizeof(cupsd_dirsvc_addr_t));
+
+      if (!dira)
+      {
+        cupsdLogMessage(CUPSD_LOG_ERROR,
+	                "Unable to allocate BrowseAddress at line %d - %s.",
+	                linenum, strerror(errno));
+        continue;
+      }
+
+      Browsers = dira;
+      dira     += NumBrowsers;
+
+      memset(dira, 0, sizeof(cupsd_dirsvc_addr_t));
+
+      if (!_cups_strcasecmp(value, "@LOCAL"))
+      {
+       /*
+	* Send browse data to all local interfaces...
+	*/
+
+	strcpy(dira->iface, "*");
+	NumBrowsers ++;
+      }
+      else if (!_cups_strncasecmp(value, "@IF(", 4))
+      {
+       /*
+	* Send browse data to the named interface...
+	*/
+
+	strlcpy(dira->iface, value + 4, sizeof(Browsers[0].iface));
+
+        ptr = dira->iface + strlen(dira->iface) - 1;
+        if (*ptr == ')')
+	  *ptr = '\0';
+
+	NumBrowsers ++;
+      }
+      else if ((addrlist = get_address(value, BrowsePort)) != NULL)
+      {
+       /*
+        * Only IPv4 addresses are supported...
+        */
+
+	for (addr = addrlist; addr; addr = addr->next)
+	  if (_httpAddrFamily(&(addr->addr)) == AF_INET)
+	    break;
+
+	if (addr)
+	{
+	  memcpy(&(dira->to), &(addrlist->addr), sizeof(dira->to));
+	  httpAddrString(&(dira->to), temp, sizeof(temp));
+
+	  cupsdLogMessage(CUPSD_LOG_INFO,
+	                  "Sending browsing info to %s:%d (IPv4)",
+			  temp, _httpAddrPort(&(dira->to)));
+
+	  NumBrowsers ++;
+	}
+	else
+	  cupsdLogMessage(CUPSD_LOG_ERROR, "Bad BrowseAddress %s at line %d.",
+			  value, linenum);
+
+	httpAddrFreeList(addrlist);
+      }
+      else
+        cupsdLogMessage(CUPSD_LOG_ERROR, "Bad BrowseAddress %s at line %d.",
+	                value, linenum);
+    }
+    else if (!_cups_strcasecmp(line, "BrowseOrder") && value)
+    {
+     /*
+      * "BrowseOrder Deny,Allow" or "BrowseOrder Allow,Deny"...
+      */
+
+      if ((location = cupsdFindLocation("CUPS_INTERNAL_BROWSE_ACL")) == NULL)
+        if ((location = cupsdNewLocation("CUPS_INTERNAL_BROWSE_ACL")) != NULL)
+	  cupsdAddLocation(location);
+
+      if (location == NULL)
+        cupsdLogMessage(CUPSD_LOG_ERROR,
+	                "Unable to initialize browse access control list.");
+      else if (!_cups_strncasecmp(value, "deny", 4))
+        location->order_type = CUPSD_AUTH_ALLOW;
+      else if (!_cups_strncasecmp(value, "allow", 5))
+        location->order_type = CUPSD_AUTH_DENY;
+      else
+        cupsdLogMessage(CUPSD_LOG_ERROR,
+	                "Unknown BrowseOrder value %s on line %d.",
+	                value, linenum);
+    }
     else if (!_cups_strcasecmp(line, "BrowseProtocols") ||
-             !_cups_strcasecmp(line, "BrowseLocalProtocols"))
+             !_cups_strcasecmp(line, "BrowseLocalProtocols") ||
+             !_cups_strcasecmp(line, "BrowseRemoteProtocols"))
     {
      /*
       * "BrowseProtocols name [... name]"
       * "BrowseLocalProtocols name [... name]"
+      * "BrowseRemoteProtocols name [... name]"
       */
 
       int protocols = parse_protocols(value);
@@ -2773,7 +2957,367 @@
         break;
       }
 
-      BrowseLocalProtocols = protocols;
+      if (_cups_strcasecmp(line, "BrowseLocalProtocols"))
+        BrowseRemoteProtocols = protocols;
+      if (_cups_strcasecmp(line, "BrowseRemoteProtocols"))
+        BrowseLocalProtocols = protocols;
+    }
+    else if ((!_cups_strcasecmp(line, "BrowseAllow") ||
+              !_cups_strcasecmp(line, "BrowseDeny")) && value)
+    {
+     /*
+      * BrowseAllow [From] host/ip...
+      * BrowseDeny [From] host/ip...
+      */
+
+      if ((location = cupsdFindLocation("CUPS_INTERNAL_BROWSE_ACL")) == NULL)
+        if ((location = cupsdNewLocation("CUPS_INTERNAL_BROWSE_ACL")) != NULL)
+	  cupsdAddLocation(location);
+
+
+      if (location == NULL)
+        cupsdLogMessage(CUPSD_LOG_ERROR,
+	                "Unable to initialize browse access control list.");
+      else
+      {
+	if (!_cups_strncasecmp(value, "from", 4))
+	{
+	 /*
+	  * Skip leading "from"...
+	  */
+
+	  value += 4;
+	}
+
+	while (*value)
+	{
+	 /*
+	  * Skip leading whitespace...
+	  */
+
+	  while (_cups_isspace(*value))
+	    value ++;
+
+	  if (!*value)
+	    break;
+
+	 /*
+	  * Find the end of the value...
+	  */
+
+	  for (valueptr = value;
+	       *valueptr && !_cups_isspace(*valueptr);
+	       valueptr ++);
+
+	  while (_cups_isspace(*valueptr))
+	    *valueptr++ = '\0';
+
+	 /*
+	  * Figure out what form the allow/deny address takes:
+	  *
+	  *    All
+	  *    None
+	  *    *.domain.com
+	  *    .domain.com
+	  *    host.domain.com
+	  *    nnn.*
+	  *    nnn.nnn.*
+	  *    nnn.nnn.nnn.*
+	  *    nnn.nnn.nnn.nnn
+	  *    nnn.nnn.nnn.nnn/mm
+	  *    nnn.nnn.nnn.nnn/mmm.mmm.mmm.mmm
+	  */
+
+	  if (!_cups_strcasecmp(value, "all"))
+	  {
+	   /*
+	    * All hosts...
+	    */
+
+	    if (!_cups_strcasecmp(line, "BrowseAllow"))
+	      cupsdAddIPMask(&(location->allow), zeros, zeros);
+	    else
+	      cupsdAddIPMask(&(location->deny), zeros, zeros);
+	  }
+	  else if (!_cups_strcasecmp(value, "none"))
+	  {
+	   /*
+	    * No hosts...
+	    */
+
+	    if (!_cups_strcasecmp(line, "BrowseAllow"))
+	      cupsdAddIPMask(&(location->allow), ones, zeros);
+	    else
+	      cupsdAddIPMask(&(location->deny), ones, zeros);
+	  }
+#ifdef AF_INET6
+	  else if (value[0] == '*' || value[0] == '.' ||
+		   (!isdigit(value[0] & 255) && value[0] != '['))
+#else
+	  else if (value[0] == '*' || value[0] == '.' ||
+	           !isdigit(value[0] & 255))
+#endif /* AF_INET6 */
+	  {
+	   /*
+	    * Host or domain name...
+	    */
+
+	    if (!_cups_strcasecmp(line, "BrowseAllow"))
+	      cupsdAddNameMask(&(location->allow), value);
+	    else
+	      cupsdAddNameMask(&(location->deny), value);
+	  }
+	  else
+	  {
+	   /*
+	    * One of many IP address forms...
+	    */
+
+	    if (!get_addr_and_mask(value, ip, mask))
+	    {
+	      cupsdLogMessage(CUPSD_LOG_ERROR, "Bad netmask value %s on line %d.",
+			      value, linenum);
+	      break;
+	    }
+
+	    if (!_cups_strcasecmp(line, "BrowseAllow"))
+	      cupsdAddIPMask(&(location->allow), ip, mask);
+	    else
+	      cupsdAddIPMask(&(location->deny), ip, mask);
+	  }
+
+	 /*
+	  * Advance to next value...
+	  */
+
+	  value = valueptr;
+	}
+      }
+    }
+    else if (!_cups_strcasecmp(line, "BrowseRelay") && value)
+    {
+     /*
+      * BrowseRelay [from] source [to] destination
+      */
+
+      if (NumRelays == 0)
+        relay = malloc(sizeof(cupsd_dirsvc_relay_t));
+      else
+        relay = realloc(Relays, (NumRelays + 1) * sizeof(cupsd_dirsvc_relay_t));
+
+      if (!relay)
+      {
+        cupsdLogMessage(CUPSD_LOG_ERROR,
+	                "Unable to allocate BrowseRelay at line %d - %s.",
+	                linenum, strerror(errno));
+        continue;
+      }
+
+      Relays = relay;
+      relay  += NumRelays;
+
+      memset(relay, 0, sizeof(cupsd_dirsvc_relay_t));
+
+      if (!_cups_strncasecmp(value, "from ", 5))
+      {
+       /*
+	* Skip leading "from"...
+	*/
+
+	value += 5;
+
+       /*
+        * Skip leading whitespace...
+	*/
+
+	while (_cups_isspace(*value))
+	  value ++;
+      }
+
+     /*
+      * Find the end of the from value...
+      */
+
+      for (valueptr = value;
+	   *valueptr && !_cups_isspace(*valueptr);
+	   valueptr ++);
+
+      while (_cups_isspace(*valueptr))
+	*valueptr++ = '\0';
+
+     /*
+      * Figure out what form the from address takes:
+      *
+      *    *.domain.com
+      *    .domain.com
+      *    host.domain.com
+      *    nnn.*
+      *    nnn.nnn.*
+      *    nnn.nnn.nnn.*
+      *    nnn.nnn.nnn.nnn
+      *    nnn.nnn.nnn.nnn/mm
+      *    nnn.nnn.nnn.nnn/mmm.mmm.mmm.mmm
+      */
+
+#ifdef AF_INET6
+      if (value[0] == '*' || value[0] == '.' ||
+          (!isdigit(value[0] & 255) && value[0] != '['))
+#else
+      if (value[0] == '*' || value[0] == '.' || !isdigit(value[0] & 255))
+#endif /* AF_INET6 */
+      {
+       /*
+        * Host or domain name...
+	*/
+
+        if (!cupsdAddNameMask(&(relay->from), value))
+	{
+	  cupsdLogMessage(CUPSD_LOG_ERROR,
+			  "Unable to allocate BrowseRelay name at line %d - %s.",
+			  linenum, strerror(errno));
+	  continue;
+	}
+      }
+      else
+      {
+       /*
+        * One of many IP address forms...
+	*/
+
+        if (!get_addr_and_mask(value, ip, mask))
+	{
+          cupsdLogMessage(CUPSD_LOG_ERROR, "Bad netmask value %s on line %d.",
+	                  value, linenum);
+	  break;
+	}
+
+        if (!cupsdAddIPMask(&(relay->from), ip, mask))
+	{
+	  cupsdLogMessage(CUPSD_LOG_ERROR,
+			  "Unable to allocate BrowseRelay IP at line %d - %s.",
+			  linenum, strerror(errno));
+	  continue;
+	}
+      }
+
+     /*
+      * Get "to" address and port...
+      */
+
+      if (!_cups_strncasecmp(valueptr, "to ", 3))
+      {
+       /*
+        * Strip leading "to"...
+	*/
+
+	valueptr += 3;
+
+	while (_cups_isspace(*valueptr))
+	  valueptr ++;
+      }
+
+      if ((addrlist = get_address(valueptr, BrowsePort)) != NULL)
+      {
+       /*
+        * Only IPv4 addresses are supported...
+        */
+
+	for (addr = addrlist; addr; addr = addr->next)
+	  if (addr->addr.addr.sa_family == AF_INET)
+	    break;
+
+	if (addr)
+	{
+	  memcpy(&(relay->to), &(addrlist->addr), sizeof(relay->to));
+
+	  httpAddrString(&(relay->to), temp, sizeof(temp));
+
+	  cupsdLogMessage(CUPSD_LOG_INFO, "Relaying from %s to %s:%d (IPv4)",
+			  value, temp, _httpAddrPort(&(relay->to)));
+
+	  NumRelays ++;
+	}
+	else
+	{
+	  cupsArrayDelete(relay->from);
+	  relay->from = NULL;
+
+	  cupsdLogMessage(CUPSD_LOG_ERROR, "Bad relay address %s at line %d.",
+	                  valueptr, linenum);
+	}
+
+	httpAddrFreeList(addrlist);
+      }
+      else
+      {
+	cupsArrayDelete(relay->from);
+	relay->from = NULL;
+
+        cupsdLogMessage(CUPSD_LOG_ERROR, "Bad relay address %s at line %d.",
+	                valueptr, linenum);
+      }
+    }
+    else if (!_cups_strcasecmp(line, "BrowsePoll") && value)
+    {
+     /*
+      * BrowsePoll address[:port]
+      */
+
+      char		*portname;	/* Port name */
+      int		portnum;	/* Port number */
+      struct servent	*service;	/* Service */
+
+
+     /*
+      * Extract the port name from the address...
+      */
+
+      if ((portname = strrchr(value, ':')) != NULL && !strchr(portname, ']'))
+      {
+        *portname++ = '\0';
+
+        if (isdigit(*portname & 255))
+	  portnum = atoi(portname);
+	else if ((service = getservbyname(portname, NULL)) != NULL)
+	  portnum = ntohs(service->s_port);
+	else
+	{
+	  cupsdLogMessage(CUPSD_LOG_ERROR, "Lookup of service \"%s\" failed.",
+	                  portname);
+          continue;
+	}
+      }
+      else
+        portnum = ippPort();
+
+     /*
+      * Add the poll entry...
+      */
+
+      if (NumPolled == 0)
+        pollp = malloc(sizeof(cupsd_dirsvc_poll_t));
+      else
+        pollp = realloc(Polled, (NumPolled + 1) * sizeof(cupsd_dirsvc_poll_t));
+
+      if (!pollp)
+      {
+        cupsdLogMessage(CUPSD_LOG_ERROR,
+	                "Unable to allocate BrowsePoll at line %d - %s.",
+	                linenum, strerror(errno));
+        continue;
+      }
+
+      Polled = pollp;
+      pollp   += NumPolled;
+
+      NumPolled ++;
+      memset(pollp, 0, sizeof(cupsd_dirsvc_poll_t));
+
+      strlcpy(pollp->hostname, value, sizeof(pollp->hostname));
+      pollp->port = portnum;
+
+      cupsdLogMessage(CUPSD_LOG_INFO, "Polling %s:%d", pollp->hostname,
+	              pollp->port);
     }
     else if (!_cups_strcasecmp(line, "default_auth_type") && value)
     {
--- a/scheduler/sysman.c
+++ b/scheduler/sysman.c
@@ -87,6 +87,9 @@
   if (DirtyFiles & CUPSD_DIRTY_CLASSES)
     cupsdSaveAllClasses();
 
+  if (DirtyFiles & CUPSD_DIRTY_REMOTE)
+    cupsdSaveRemoteCache();
+
   if (DirtyFiles & CUPSD_DIRTY_PRINTCAP)
     cupsdWritePrintcap();
 
@@ -120,9 +123,10 @@
 void
 cupsdMarkDirty(int what)		/* I - What file(s) are dirty? */
 {
-  cupsdLogMessage(CUPSD_LOG_DEBUG, "cupsdMarkDirty(%c%c%c%c%c)",
+  cupsdLogMessage(CUPSD_LOG_DEBUG, "cupsdMarkDirty(%c%c%c%c%c%c)",
 		  (what & CUPSD_DIRTY_PRINTERS) ? 'P' : '-',
 		  (what & CUPSD_DIRTY_CLASSES) ? 'C' : '-',
+-		  (what & CUPSD_DIRTY_REMOTE) ? 'R' : '-',
 		  (what & CUPSD_DIRTY_PRINTCAP) ? 'p' : '-',
 		  (what & CUPSD_DIRTY_JOBS) ? 'J' : '-',
 		  (what & CUPSD_DIRTY_SUBSCRIPTIONS) ? 'S' : '-');
@@ -861,9 +865,20 @@
            p;
 	   p = (cupsd_printer_t *)cupsArrayNext(Printers))
       {
-	cupsdLogMessage(CUPSD_LOG_DEBUG,
-			"Deregistering local printer \"%s\"", p->name);
-	cupsdDeregisterPrinter(p, 0);
+	if (p->type & CUPS_PRINTER_DISCOVERED)
+	{
+	  cupsdLogMessage(CUPSD_LOG_DEBUG,
+	                  "Deleting remote destination \"%s\"", p->name);
+	  cupsArraySave(Printers);
+	  cupsdDeletePrinter(p, 0);
+	  cupsArrayRestore(Printers);
+	}
+	else
+	{
+	  cupsdLogMessage(CUPSD_LOG_DEBUG,
+	                  "Deregistering local printer \"%s\"", p->name);
+	  cupsdDeregisterPrinter(p, 0);
+	}
       }
 
       cupsdCleanDirty();
@@ -950,8 +965,23 @@
     if (sysevent.event & SYSEVENT_NETCHANGED)
     {
       if (!Sleeping)
+      {
         cupsdLogMessage(CUPSD_LOG_DEBUG,
 	                "System network configuration changed");
+
+       /*
+        * Resetting browse_time before calling cupsdSendBrowseList causes
+	* browse packets to be sent for local shared printers.
+        */
+
+	for (p = (cupsd_printer_t *)cupsArrayFirst(Printers);
+	     p;
+	     p = (cupsd_printer_t *)cupsArrayNext(Printers))
+	  p->browse_time = 0;
+
+        cupsdSendBrowseList();
+	cupsdRestartPolling();
+      }
       else
         cupsdLogMessage(CUPSD_LOG_DEBUG,
 	                "System network configuration changed; "
@@ -989,7 +1019,10 @@
 	for (p = (cupsd_printer_t *)cupsArrayFirst(Printers);
 	     p;
 	     p = (cupsd_printer_t *)cupsArrayNext(Printers))
+	{
+	  p->browse_time = 0;
 	  cupsdRegisterPrinter(p);
+	}
       }
       else
         cupsdLogMessage(CUPSD_LOG_DEBUG,
--- a/scheduler/printers.c
+++ b/scheduler/printers.c
@@ -168,6 +168,9 @@
                   "cupsdAddPrinter: Adding %s to Printers", p->name);
   cupsArrayAdd(Printers, p);
 
+  if (!ImplicitPrinters)
+    ImplicitPrinters = cupsArrayNew(compare_printers, NULL);
+
  /*
   * Return the new printer...
   */
@@ -748,6 +751,16 @@
 		              "Job stopped.");
 
  /*
+  * If this printer is the next for browsing, point to the next one...
+  */
+
+  if (p == BrowseNext)
+  {
+    cupsArrayFind(Printers, p);
+    BrowseNext = (cupsd_printer_t *)cupsArrayNext(Printers);
+  }
+
+ /*
   * Remove the printer from the list...
   */
 
@@ -755,6 +768,14 @@
                   "cupsdDeletePrinter: Removing %s from Printers", p->name);
   cupsArrayRemove(Printers, p);
 
+  if (p->type & CUPS_PRINTER_IMPLICIT)
+  {
+    cupsdLogMessage(CUPSD_LOG_DEBUG2,
+		    "cupsdDeletePrinter: Removing %s from ImplicitPrinters",
+		    p->name);
+    cupsArrayRemove(ImplicitPrinters, p);
+  }
+
  /*
   * Remove the dummy interface/icon/option files under IRIX...
   */
@@ -785,19 +806,43 @@
   */
 
   if (p == DefaultPrinter)
+  {
     DefaultPrinter = NULL;
 
+    if (UseNetworkDefault)
+    {
+     /*
+      * Find the first network default printer and use it...
+      */
+
+      cupsd_printer_t	*dp;		/* New default printer */
+
+
+      for (dp = (cupsd_printer_t *)cupsArrayFirst(Printers);
+	   dp;
+	   dp = (cupsd_printer_t *)cupsArrayNext(Printers))
+	if (dp != p && (dp->type & CUPS_PRINTER_DEFAULT))
+	{
+	  DefaultPrinter = dp;
+	  break;
+	}
+    }
+  }
+
  /*
   * Remove this printer from any classes...
   */
 
-  changed = cupsdDeletePrinterFromClasses(p);
+  if (!(p->type & CUPS_PRINTER_IMPLICIT))
+  {
+    changed = cupsdDeletePrinterFromClasses(p);
 
- /*
-  * Deregister from any browse protocols...
-  */
+   /*
+    * Deregister from any browse protocols...
+    */
 
-  cupsdDeregisterPrinter(p, 1);
+    cupsdDeregisterPrinter(p, 1);
+  }
 
  /*
   * Free all memory used by the printer...
@@ -844,6 +889,9 @@
 
   cupsArrayDelete(p->filetypes);
 
+  if (p->browse_attrs)
+    free(p->browse_attrs);
+
   cupsFreeOptions(p->num_options, p->options);
 
   free(p);
@@ -1348,6 +1396,14 @@
                   "cupsdRenamePrinter: Removing %s from Printers", p->name);
   cupsArrayRemove(Printers, p);
 
+  if (p->type & CUPS_PRINTER_IMPLICIT)
+  {
+    cupsdLogMessage(CUPSD_LOG_DEBUG2,
+		    "cupsdRenamePrinter: Removing %s from ImplicitPrinters",
+		    p->name);
+    cupsArrayRemove(ImplicitPrinters, p);
+  }
+
  /*
   * Rename the printer type...
   */
@@ -1380,6 +1436,14 @@
   cupsdLogMessage(CUPSD_LOG_DEBUG2,
                   "cupsdRenamePrinter: Adding %s to Printers", p->name);
   cupsArrayAdd(Printers, p);
+
+  if (p->type & CUPS_PRINTER_IMPLICIT)
+  {
+    cupsdLogMessage(CUPSD_LOG_DEBUG2,
+		    "cupsdRenamePrinter: Adding %s to ImplicitPrinters",
+		    p->name);
+    cupsArrayAdd(ImplicitPrinters, p);
+  }
 }
 
 
@@ -1437,10 +1501,12 @@
        printer = (cupsd_printer_t *)cupsArrayNext(Printers))
   {
    /*
-    * Skip printer classes...
+    * Skip remote destinations and printer classes...
     */
 
-    if (printer->type & CUPS_PRINTER_CLASS)
+    if ((printer->type & CUPS_PRINTER_DISCOVERED) ||
+        (printer->type & CUPS_PRINTER_CLASS) ||
+	(printer->type & CUPS_PRINTER_IMPLICIT))
       continue;
 
    /*
@@ -2072,7 +2138,8 @@
 void
 cupsdSetPrinterAttrs(cupsd_printer_t *p)/* I - Printer to setup */
 {
-  int		i;			/* Looping var */
+  int		i,			/* Looping var */
+		length;			/* Length of browse attributes */
   char		resource[HTTP_MAX_URI];	/* Resource portion of URI */
   int		num_air;		/* Number of auth-info-required values */
   const char	* const *air;		/* auth-info-required values */
@@ -2080,6 +2147,7 @@
   const char	*auth_supported;	/* Authentication supported */
   ipp_t		*oldattrs;		/* Old printer attributes */
   ipp_attribute_t *attr;		/* Attribute data */
+  cups_option_t	*option;		/* Current printer option */
   char		*name,			/* Current user/group name */
 		*filter;		/* Current filter */
   static const char * const air_none[] =
@@ -2122,7 +2190,8 @@
     num_air = p->num_auth_info_required;
     air     = p->auth_info_required;
   }
-  else if (p->type & CUPS_PRINTER_AUTHENTICATED)
+  else if ((p->type & CUPS_PRINTER_AUTHENTICATED) &&
+           (p->type & CUPS_PRINTER_DISCOVERED))
   {
     num_air = 2;
     air     = air_userpass;
@@ -2154,12 +2223,15 @@
       auth_supported = "negotiate";
 #endif /* HAVE_GSSAPI */
 
-    if (auth_type != CUPSD_AUTH_NONE)
-      p->type |= CUPS_PRINTER_AUTHENTICATED;
-    else
-      p->type &= ~CUPS_PRINTER_AUTHENTICATED;
+    if (!(p->type & CUPS_PRINTER_DISCOVERED))
+    {
+      if (auth_type != CUPSD_AUTH_NONE)
+	p->type |= CUPS_PRINTER_AUTHENTICATED;
+      else
+	p->type &= ~CUPS_PRINTER_AUTHENTICATED;
+    }
   }
-  else
+  else if (!(p->type & CUPS_PRINTER_DISCOVERED))
     p->type &= ~CUPS_PRINTER_AUTHENTICATED;
 
  /*
@@ -2208,7 +2280,7 @@
   ippAddStrings(p->attrs, IPP_TAG_PRINTER, IPP_TAG_KEYWORD,
 		"auth-info-required", num_air, NULL, air);
 
-  if (cupsArrayCount(Banners) > 0)
+  if (cupsArrayCount(Banners) > 0 && !(p->type & CUPS_PRINTER_DISCOVERED))
   {
    /*
     * Setup the job-sheets-default attribute...
@@ -2229,117 +2301,163 @@
   p->raw    = 0;
   p->remote = 0;
 
- /*
-  * Assign additional attributes depending on whether this is a printer
-  * or class...
-  */
-
-  if (p->type & CUPS_PRINTER_CLASS)
+  if (p->type & CUPS_PRINTER_DISCOVERED)
   {
-    p->raw = 1;
-    p->type &= ~CUPS_PRINTER_OPTIONS;
-
    /*
-    * Add class-specific attributes...
+    * Tell the client this is a remote printer of some type...
     */
 
-    ippAddString(p->attrs, IPP_TAG_PRINTER, IPP_TAG_TEXT,
-		 "printer-make-and-model", NULL, "Local Printer Class");
-    ippAddString(p->attrs, IPP_TAG_PRINTER, IPP_TAG_URI, "device-uri", NULL,
-		 "file:///dev/null");
-
-    if (p->num_printers > 0)
+    if (strchr(p->uri, '?'))
     {
      /*
-      * Add a list of member names; URIs are added in copy_printer_attrs...
+      * Strip trailing "?options" from URI...
       */
 
-      attr    = ippAddStrings(p->attrs, IPP_TAG_PRINTER, IPP_TAG_NAME,
-			      "member-names", p->num_printers, NULL, NULL);
-      p->type |= CUPS_PRINTER_OPTIONS;
+      char *ptr;			/* Pointer into URI */
 
-      for (i = 0; i < p->num_printers; i ++)
-      {
-	if (attr != NULL)
-	  attr->values[i].string.text = _cupsStrRetain(p->printers[i]->name);
+      strlcpy(resource, p->uri, sizeof(resource));
+      if ((ptr = strchr(resource, '?')) != NULL)
+        *ptr = '\0';
 
-	p->type &= ~CUPS_PRINTER_OPTIONS | p->printers[i]->type;
-      }
+      ippAddString(p->attrs, IPP_TAG_PRINTER, IPP_TAG_URI,
+		   "printer-uri-supported", NULL, resource);
     }
+    else
+      ippAddString(p->attrs, IPP_TAG_PRINTER, IPP_TAG_URI,
+		   "printer-uri-supported", NULL, p->uri);
+
+    ippAddString(p->attrs, IPP_TAG_PRINTER, IPP_TAG_URI, "printer-more-info",
+		 NULL, p->uri);
+
+    if (p->make_model)
+      ippAddString(p->attrs, IPP_TAG_PRINTER, IPP_TAG_TEXT,
+                   "printer-make-and-model", NULL, p->make_model);
+
+    ippAddString(p->attrs, IPP_TAG_PRINTER, IPP_TAG_URI, "device-uri", NULL,
+        	 p->uri);
+
+    p->raw    = 1;
+    p->remote = 1;
   }
   else
   {
    /*
-    * Add printer-specific attributes...
+    * Assign additional attributes depending on whether this is a printer
+    * or class...
     */
 
-    ippAddString(p->attrs, IPP_TAG_PRINTER, IPP_TAG_URI, "device-uri", NULL,
-		 p->sanitized_device_uri);
+    if (p->type & (CUPS_PRINTER_CLASS | CUPS_PRINTER_IMPLICIT))
+    {
+      p->raw = 1;
+      p->type &= ~CUPS_PRINTER_OPTIONS;
 
-   /*
-    * Assign additional attributes from the PPD file (if any)...
-    */
+     /*
+      * Add class-specific attributes...
+      */
 
-    load_ppd(p);
+      if ((p->type & CUPS_PRINTER_IMPLICIT) && p->num_printers > 0 &&
+          p->printers[0]->make_model)
+	ippAddString(p->attrs, IPP_TAG_PRINTER, IPP_TAG_TEXT,
+                     "printer-make-and-model", NULL, p->printers[0]->make_model);
+      else
+	ippAddString(p->attrs, IPP_TAG_PRINTER, IPP_TAG_TEXT,
+                     "printer-make-and-model", NULL, "Local Printer Class");
 
-   /*
-    * Add filters for printer...
-    */
+      ippAddString(p->attrs, IPP_TAG_PRINTER, IPP_TAG_URI, "device-uri", NULL,
+        	   "file:///dev/null");
 
-    cupsdSetPrinterReasons(p, "-cups-missing-filter-warning,"
-			      "cups-insecure-filter-warning");
+      if (p->num_printers > 0)
+      {
+       /*
+	* Add a list of member names; URIs are added in copy_printer_attrs...
+	*/
 
-    if (p->pc && p->pc->filters)
-    {
-      for (filter = (char *)cupsArrayFirst(p->pc->filters);
-	   filter;
-	   filter = (char *)cupsArrayNext(p->pc->filters))
-	add_printer_filter(p, p->filetype, filter);
+	attr    = ippAddStrings(p->attrs, IPP_TAG_PRINTER, IPP_TAG_NAME,
+                                "member-names", p->num_printers, NULL, NULL);
+        p->type |= CUPS_PRINTER_OPTIONS;
+
+	for (i = 0; i < p->num_printers; i ++)
+	{
+          if (attr != NULL)
+            attr->values[i].string.text = _cupsStrRetain(p->printers[i]->name);
+
+	  p->type &= ~CUPS_PRINTER_OPTIONS | p->printers[i]->type;
+        }
+      }
     }
-    else if (!(p->type & CUPS_PRINTER_REMOTE))
+    else
     {
-      char	interface[1024];	/* Interface script */
+     /*
+      * Add printer-specific attributes...
+      */
 
+      ippAddString(p->attrs, IPP_TAG_PRINTER, IPP_TAG_URI, "device-uri", NULL,
+		   p->sanitized_device_uri);
 
-      snprintf(interface, sizeof(interface), "%s/interfaces/%s", ServerRoot,
-	       p->name);
-      if (!access(interface, X_OK))
-      {
-       /*
-	* Yes, we have a System V style interface script; use it!
-	*/
+     /*
+      * Assign additional attributes from the PPD file (if any)...
+      */
 
-	snprintf(interface, sizeof(interface), "*/* 0 %s/interfaces/%s",
-		 ServerRoot, p->name);
-	add_printer_filter(p, p->filetype, interface);
+      load_ppd(p);
+
+     /*
+      * Add filters for printer...
+      */
+
+      cupsdSetPrinterReasons(p, "-cups-missing-filter-warning,"
+                                "cups-insecure-filter-warning");
+
+      if (p->pc && p->pc->filters)
+      {
+	for (filter = (char *)cupsArrayFirst(p->pc->filters);
+	     filter;
+	     filter = (char *)cupsArrayNext(p->pc->filters))
+	  add_printer_filter(p, p->filetype, filter);
       }
-      else
+      else if (!(p->type & CUPS_PRINTER_REMOTE))
       {
-       /*
-	* Add a filter from application/vnd.cups-raw to printer/name to
-	* handle "raw" printing by users.
-	*/
+	char	interface[1024];	/* Interface script */
 
-	add_printer_filter(p, p->filetype, "application/vnd.cups-raw 0 -");
+	snprintf(interface, sizeof(interface), "%s/interfaces/%s", ServerRoot,
+		 p->name);
+	if (!access(interface, X_OK))
+	{
+	 /*
+	  * Yes, we have a System V style interface script; use it!
+	  */
 
-       /*
-	* Add a PostScript filter, since this is still possibly PS printer.
-	*/
+	  snprintf(interface, sizeof(interface), "*/* 0 %s/interfaces/%s",
+		   ServerRoot, p->name);
+	  add_printer_filter(p, p->filetype, interface);
+	}
+	else
+	{
+	 /*
+	  * Add a filter from application/vnd.cups-raw to printer/name to
+	  * handle "raw" printing by users.
+	  */
 
-	add_printer_filter(p, p->filetype,
-			   "application/vnd.cups-postscript 0 -");
+	  add_printer_filter(p, p->filetype, "application/vnd.cups-raw 0 -");
+
+	 /*
+	  * Add a PostScript filter, since this is still possibly PS printer.
+	  */
+
+	  add_printer_filter(p, p->filetype,
+	                     "application/vnd.cups-postscript 0 -");
+	}
       }
-    }
 
-    if (p->pc && p->pc->prefilters)
-    {
-      if (!p->prefiltertype)
-	p->prefiltertype = mimeAddType(MimeDatabase, "prefilter", p->name);
+      if (p->pc && p->pc->prefilters)
+      {
+        if (!p->prefiltertype)
+          p->prefiltertype = mimeAddType(MimeDatabase, "prefilter", p->name);
 
-      for (filter = (char *)cupsArrayFirst(p->pc->prefilters);
-	   filter;
-	   filter = (char *)cupsArrayNext(p->pc->prefilters))
-	add_printer_filter(p, p->prefiltertype, filter);
+        for (filter = (char *)cupsArrayFirst(p->pc->prefilters);
+	     filter;
+	     filter = (char *)cupsArrayNext(p->pc->prefilters))
+	  add_printer_filter(p, p->prefiltertype, filter);
+      }
     }
   }
 
@@ -2439,8 +2557,98 @@
   * Force sharing off for remote queues...
   */
 
-  if (p->type & CUPS_PRINTER_REMOTE)
+  if (p->type & (CUPS_PRINTER_REMOTE | CUPS_PRINTER_IMPLICIT))
     p->shared = 0;
+  else
+  {
+   /*
+    * Copy the printer options into a browse attributes string we can re-use.
+    */
+
+    const char	*valptr;		/* Pointer into value */
+    char	*attrptr;		/* Pointer into attribute string */
+
+
+   /*
+    * Free the old browse attributes as needed...
+    */
+
+    if (p->browse_attrs)
+      free(p->browse_attrs);
+
+   /*
+    * Compute the length of all attributes + job-sheets, lease-duration,
+    * and BrowseLocalOptions.
+    */
+
+    for (length = 1, i = p->num_options, option = p->options;
+         i > 0;
+	 i --, option ++)
+    {
+      length += strlen(option->name) + 2;
+
+      if (option->value)
+      {
+        for (valptr = option->value; *valptr; valptr ++)
+	  if (strchr(" \"\'\\", *valptr))
+	    length += 2;
+	  else
+	    length ++;
+      }
+    }
+
+    length += 13 + strlen(p->job_sheets[0]) + strlen(p->job_sheets[1]);
+    length += 32;
+    if (BrowseLocalOptions)
+      length += 12 + strlen(BrowseLocalOptions);
+
+   /*
+    * Allocate the new string...
+    */
+
+    if ((p->browse_attrs = calloc(1, length)) == NULL)
+      cupsdLogMessage(CUPSD_LOG_ERROR,
+                      "Unable to allocate %d bytes for browse data!",
+		      length);
+    else
+    {
+     /*
+      * Got the allocated string, now copy the options and attributes over...
+      */
+
+      sprintf(p->browse_attrs, "job-sheets=%s,%s lease-duration=%d",
+              p->job_sheets[0], p->job_sheets[1], BrowseTimeout);
+      attrptr = p->browse_attrs + strlen(p->browse_attrs);
+
+      if (BrowseLocalOptions)
+      {
+        sprintf(attrptr, " ipp-options=%s", BrowseLocalOptions);
+        attrptr += strlen(attrptr);
+      }
+
+      for (i = p->num_options, option = p->options;
+           i > 0;
+	   i --, option ++)
+      {
+        *attrptr++ = ' ';
+	strcpy(attrptr, option->name);
+	attrptr += strlen(attrptr);
+
+	if (option->value)
+	{
+	  *attrptr++ = '=';
+
+          for (valptr = option->value; *valptr; valptr ++)
+	  {
+	    if (strchr(" \"\'\\", *valptr))
+	      *attrptr++ = '\\';
+
+	    *attrptr++ = *valptr;
+	  }
+	}
+      }
+    }
+  }
 
  /*
   * Populate the document-format-supported attribute...
@@ -2634,6 +2842,13 @@
 
 
  /*
+  * Can't set status of remote printers...
+  */
+
+  if (p->type & CUPS_PRINTER_DISCOVERED)
+    return;
+
+ /*
   * Set the new state...
   */
 
@@ -2652,7 +2867,9 @@
     * Let the browse code know this needs to be updated...
     */
 
-    p->state_time = time(NULL);
+    BrowseNext     = p;
+    p->state_time  = time(NULL);
+    p->browse_time = 0;
 
 #ifdef __sgi
     write_irix_state(p);
@@ -2862,6 +3079,22 @@
        p = (cupsd_printer_t *)cupsArrayNext(Printers))
   {
    /*
+    * Remove remote printers if we are no longer browsing...
+    */
+
+    if (!Browsing &&
+        (p->type & (CUPS_PRINTER_IMPLICIT | CUPS_PRINTER_DISCOVERED)))
+    {
+      if (p->type & CUPS_PRINTER_IMPLICIT)
+        cupsArrayRemove(ImplicitPrinters, p);
+
+      cupsArraySave(Printers);
+      cupsdDeletePrinter(p, 0);
+      cupsArrayRestore(Printers);
+      continue;
+    }
+
+   /*
     * Update the operation policy pointer...
     */
 
@@ -2869,10 +3102,11 @@
       p->op_policy_ptr = DefaultPolicyPtr;
 
    /*
-    * Update printer attributes...
+    * Update printer attributes as needed...
     */
 
-    cupsdSetPrinterAttrs(p);
+    if (!(p->type & CUPS_PRINTER_DISCOVERED))
+      cupsdSetPrinterAttrs(p);
   }
 }
 
@@ -2965,7 +3199,8 @@
       *printer = p;
 
     if (dtype)
-      *dtype = p->type & (CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE);
+      *dtype = p->type & (CUPS_PRINTER_CLASS | CUPS_PRINTER_IMPLICIT |
+                          CUPS_PRINTER_REMOTE | CUPS_PRINTER_DISCOVERED);
 
     return (p->name);
   }
@@ -3023,7 +3258,8 @@
         *printer = p;
 
       if (dtype)
-	*dtype = p->type & (CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE);
+	*dtype = p->type & (CUPS_PRINTER_CLASS | CUPS_PRINTER_IMPLICIT |
+                            CUPS_PRINTER_REMOTE | CUPS_PRINTER_DISCOVERED);
 
       return (p->name);
     }
@@ -3708,7 +3944,9 @@
 static void
 dirty_printer(cupsd_printer_t *p)	/* I - Printer */
 {
-  if (p->type & CUPS_PRINTER_CLASS)
+  if (p->type & CUPS_PRINTER_DISCOVERED)
+    cupsdMarkDirty(CUPSD_DIRTY_REMOTE);
+  else if (p->type & CUPS_PRINTER_CLASS)
     cupsdMarkDirty(CUPSD_DIRTY_CLASSES);
   else
     cupsdMarkDirty(CUPSD_DIRTY_PRINTERS);
--- a/scheduler/classes.h
+++ b/scheduler/classes.h
@@ -28,6 +28,7 @@
 extern cupsd_printer_t	*cupsdFindClass(const char *name);
 extern void		cupsdLoadAllClasses(void);
 extern void		cupsdSaveAllClasses(void);
+extern void		cupsdUpdateImplicitClasses(void);
 
 
 /*
--- a/scheduler/dirsvc.c
+++ b/scheduler/dirsvc.c
@@ -17,16 +17,24 @@
  *   cupsdDeregisterPrinter()  - Stop sending broadcast information for a local
  *				 printer and remove any pending references to
  *				 remote printers.
+ *   cupsdLoadRemoteCache()    - Load the remote printer cache.
  *   cupsdRegisterPrinter()    - Start sending broadcast information for a
  *				 printer or update the broadcast contents.
+ *   cupsdRestartPolling()     - Restart polling servers as needed.
+ *   cupsdSaveRemoteCache()    - Save the remote printer cache.
+ *   cupsdSendBrowseList()     - Send new browsing information as necessary.
  *   cupsdStartBrowsing()      - Start sending and receiving broadcast
  *				 information.
+ *   cupsdStartPolling()       - Start polling servers as needed.
  *   cupsdStopBrowsing()       - Stop sending and receiving broadcast
  *				 information.
+ *   cupsdStopPolling()        - Stop polling servers as needed.
  *   cupsdUpdateDNSSDName()    - Update the computer name we use for
  *				 browsing...
+ *   dequote()                 - Remote quotes from a string.
  *   dnssdAddAlias()	       - Add a DNS-SD alias name.
  *   dnssdBuildTxtRecord()     - Build a TXT record from printer info.
+ *   dnssdComparePrinters()    - Compare the registered names of two printers.
  *   dnssdDeregisterInstance() - Deregister a DNS-SD service instance.
  *   dnssdDeregisterPrinter()  - Deregister all services for a printer.
  *   dnssdErrorString()        - Return an error string for an error code.
@@ -39,7 +47,16 @@
  *   dnssdUpdate()	       - Handle DNS-SD queries.
  *   get_auth_info_required()  - Get the auth-info-required value to advertise.
  *   get_hostconfig()	       - Get an /etc/hostconfig service setting.
+ *   is_local_queue()          - Determine whether the URI points at a local
+ *                               queue.
+ *   process_browse_data()     - Process new browse data.
+ *   process_implicit_classes()- Create/update implicit classes as needed.
+ *   send_cups_browse()        - Send new browsing information using the CUPS
+ *                               protocol.
+ *   update_cups_browse()      - Update the browse lists using the CUPS
+ *                               protocol.
  *   update_lpd()	       - Update the LPD configuration as needed.
+ *   update_polling()	       - Read status messages from the poll daemons.
  *   update_smb()	       - Update the SMB configuration as needed.
  */
 
@@ -61,15 +78,25 @@
  * Local functions...
  */
 
-#if defined(HAVE_DNSSD) || defined(HAVE_AVAHI)
-static char		*get_auth_info_required(cupsd_printer_t *p,
+static char	*dequote(char *d, const char *s, int dlen);
+static char	*get_auth_info_required(cupsd_printer_t *p,
 			                        char *buffer, size_t bufsize);
-#endif /* HAVE_DNSSD || HAVE_AVAHI */
 #ifdef __APPLE__
-static int		get_hostconfig(const char *name);
+static int	get_hostconfig(const char *name);
 #endif /* __APPLE__ */
-static void		update_lpd(int onoff);
-static void		update_smb(int onoff);
+static int	is_local_queue(const char *uri, char *host, int hostlen,
+		               char *resource, int resourcelen);
+static void	process_browse_data(const char *uri, const char *host,
+		                    const char *resource, cups_ptype_t type,
+				    ipp_pstate_t state, const char *location,
+				    const char *info, const char *make_model,
+				    int num_attrs, cups_option_t *attrs);
+static void	process_implicit_classes(void);
+static void	send_cups_browse(cupsd_printer_t *p);
+static void	update_cups_browse(void);
+static void	update_lpd(int onoff);
+static void	update_polling(void);
+static void	update_smb(int onoff);
 
 
 #if defined(HAVE_DNSSD) || defined(HAVE_AVAHI)
@@ -78,6 +105,7 @@
 			              void *context);
 #  endif /* __APPLE__ */
 static cupsd_txt_t	dnssdBuildTxtRecord(cupsd_printer_t *p, int for_lpd);
+static int		dnssdComparePrinters(cupsd_printer_t *a, cupsd_printer_t *b);
 static void		dnssdDeregisterInstance(cupsd_srv_t *srv);
 static void		dnssdDeregisterPrinter(cupsd_printer_t *p,
 			                       int clear_name);
@@ -129,13 +157,25 @@
 		  removeit);
 
   if (!Browsing || !p->shared ||
-      (p->type & (CUPS_PRINTER_REMOTE | CUPS_PRINTER_SCANNER)))
+      (p->type & (CUPS_PRINTER_REMOTE | CUPS_PRINTER_IMPLICIT |
+                  CUPS_PRINTER_SCANNER)))
     return;
 
  /*
   * Announce the deletion...
   */
 
+  if ((BrowseLocalProtocols & BROWSE_CUPS) && BrowseSocket >= 0)
+  {
+    cups_ptype_t savedtype = p->type;	/* Saved printer type */
+
+    p->type |= CUPS_PRINTER_DELETE;
+
+    send_cups_browse(p);
+
+    p->type = savedtype;
+  }
+
 #if defined(HAVE_DNSSD) || defined(HAVE_AVAHI)
   if (removeit && (BrowseLocalProtocols & BROWSE_DNSSD) && DNSSDMaster)
     dnssdDeregisterPrinter(p, 1);
@@ -144,1367 +184,3531 @@
 
 
 /*
- * 'cupsdRegisterPrinter()' - Start sending broadcast information for a
- *                            printer or update the broadcast contents.
+ * 'cupsdLoadRemoteCache()' - Load the remote printer cache.
  */
 
 void
-cupsdRegisterPrinter(cupsd_printer_t *p)/* I - Printer */
+cupsdLoadRemoteCache(void)
 {
-  cupsdLogMessage(CUPSD_LOG_DEBUG, "cupsdRegisterPrinter(p=%p(%s))", p,
-                  p->name);
+  int			i;		/* Looping var */
+  cups_file_t		*fp;		/* remote.cache file */
+  int			linenum;	/* Current line number */
+  char			line[4096],	/* Line from file */
+			*value,		/* Pointer to value */
+			*valueptr,	/* Pointer into value */
+			scheme[32],	/* Scheme portion of URI */
+			username[64],	/* Username portion of URI */
+			host[HTTP_MAX_HOST],
+					/* Hostname portion of URI */
+			resource[HTTP_MAX_URI];
+					/* Resource portion of URI */
+  int			port;		/* Port number */
+  cupsd_printer_t	*p;		/* Current printer */
+  time_t		now;		/* Current time */
 
-  if (!Browsing || !BrowseLocalProtocols ||
-      (p->type & (CUPS_PRINTER_REMOTE | CUPS_PRINTER_SCANNER)))
-    return;
 
-#if defined(HAVE_DNSSD) || defined(HAVE_AVAHI)
-  if ((BrowseLocalProtocols & BROWSE_DNSSD) && DNSSDMaster)
-    dnssdRegisterPrinter(p);
-#endif /* HAVE_DNSSD || HAVE_AVAHI */
-}
+ /*
+  * Don't load the cache if the remote protocols are disabled...
+  */
 
+  if (!Browsing)
+  {
+    cupsdLogMessage(CUPSD_LOG_DEBUG,
+                    "cupsdLoadRemoteCache: Not loading remote cache.");
+    return;
+  }
 
-/*
- * 'cupsdStartBrowsing()' - Start sending and receiving broadcast information.
- */
+ /*
+  * Open the remote.cache file...
+  */
 
-void
-cupsdStartBrowsing(void)
-{
-  cupsd_printer_t	*p;		/* Current printer */
+  snprintf(line, sizeof(line), "%s/remote.cache", CacheDir);
+  if ((fp = cupsdOpenConfFile(line)) == NULL)
+    return;
 
+ /*
+  * Read printer configurations until we hit EOF...
+  */
 
-  if (!Browsing || !BrowseLocalProtocols)
-    return;
+  linenum = 0;
+  p       = NULL;
+  now     = time(NULL);
 
-#if defined(HAVE_DNSSD) || defined(HAVE_AVAHI)
-  if (BrowseLocalProtocols & BROWSE_DNSSD)
+  while (cupsFileGetConf(fp, line, sizeof(line), &value, &linenum))
   {
-    cupsd_listener_t	*lis;		/* Current listening socket */
-#  ifdef HAVE_DNSSD
-    DNSServiceErrorType error;		/* Error from service creation */
-
    /*
-    * First create a "master" connection for all registrations...
+    * Decode the directive...
     */
 
-    if ((error = DNSServiceCreateConnection(&DNSSDMaster))
-	    != kDNSServiceErr_NoError)
+    if (!_cups_strcasecmp(line, "<Printer") ||
+        !_cups_strcasecmp(line, "<DefaultPrinter"))
     {
-      cupsdLogMessage(CUPSD_LOG_ERROR,
-		      "Unable to create master DNS-SD reference: %d", error);
+     /*
+      * <Printer name> or <DefaultPrinter name>
+      */
 
-      if (FatalErrors & CUPSD_FATAL_BROWSE)
-	cupsdEndProcess(getpid(), 0);
+      if (p == NULL && value)
+      {
+       /*
+        * Add the printer and a base file type...
+	*/
+
+        cupsdLogMessage(CUPSD_LOG_DEBUG,
+	                "cupsdLoadRemoteCache: Loading printer %s...", value);
+
+        if ((p = cupsdFindDest(value)) != NULL)
+	{
+	  if (p->type & CUPS_PRINTER_CLASS)
+	  {
+	    cupsdLogMessage(CUPSD_LOG_WARN,
+	                    "Cached remote printer \"%s\" conflicts with "
+			    "existing class!",
+	                    value);
+	    p = NULL;
+	    continue;
+	  }
+	}
+	else
+          p = cupsdAddPrinter(value);
+
+	p->accepting     = 1;
+	p->state         = IPP_PRINTER_IDLE;
+	p->type          |= CUPS_PRINTER_REMOTE | CUPS_PRINTER_DISCOVERED;
+	p->browse_time   = now;
+	p->browse_expire = now + BrowseTimeout;
+
+       /*
+        * Set the default printer as needed...
+	*/
+
+        if (!_cups_strcasecmp(line, "<DefaultPrinter"))
+	  DefaultPrinter = p;
+      }
+      else
+      {
+        cupsdLogMessage(CUPSD_LOG_ERROR,
+	                "Syntax error on line %d of remote.cache.", linenum);
+        break;
+      }
     }
-    else
+    else if (!_cups_strcasecmp(line, "<Class") ||
+             !_cups_strcasecmp(line, "<DefaultClass"))
     {
      /*
-      * Add the master connection to the select list...
+      * <Class name> or <DefaultClass name>
       */
 
-      int fd = DNSServiceRefSockFD(DNSSDMaster);
+      if (p == NULL && value)
+      {
+       /*
+        * Add the printer and a base file type...
+	*/
 
-      fcntl(fd, F_SETFD, fcntl(fd, F_GETFD) | FD_CLOEXEC);
+        cupsdLogMessage(CUPSD_LOG_DEBUG,
+	                "cupsdLoadRemoteCache: Loading class %s...", value);
 
-      cupsdAddSelect(fd, (cupsd_selfunc_t)dnssdUpdate, NULL, NULL);
-    }
+        if ((p = cupsdFindDest(value)) != NULL)
+	  p->type = CUPS_PRINTER_CLASS;
+	else
+          p = cupsdAddClass(value);
+
+	p->accepting     = 1;
+	p->state         = IPP_PRINTER_IDLE;
+	p->type          |= CUPS_PRINTER_REMOTE | CUPS_PRINTER_DISCOVERED;
+	p->browse_time   = now;
+	p->browse_expire = now + BrowseTimeout;
 
-#  else /* HAVE_AVAHI */
-    if ((DNSSDMaster = avahi_threaded_poll_new()) == NULL)
-    {
-      cupsdLogMessage(CUPSD_LOG_ERROR, "Unable to create DNS-SD thread.");
+       /*
+        * Set the default printer as needed...
+	*/
 
-      if (FatalErrors & CUPSD_FATAL_BROWSE)
-	cupsdEndProcess(getpid(), 0);
+        if (!_cups_strcasecmp(line, "<DefaultClass"))
+	  DefaultPrinter = p;
+      }
+      else
+      {
+        cupsdLogMessage(CUPSD_LOG_ERROR,
+	                "Syntax error on line %d of remote.cache.", linenum);
+        break;
+      }
     }
-    else
+    else if (!_cups_strcasecmp(line, "</Printer>") ||
+             !_cups_strcasecmp(line, "</Class>"))
     {
-      int error;			/* Error code, if any */
+      if (p != NULL)
+      {
+       /*
+        * Close out the current printer...
+	*/
 
-      DNSSDClient = avahi_client_new(avahi_threaded_poll_get(DNSSDMaster), 0,
-                                     NULL, NULL, &error);
+        cupsdSetPrinterAttrs(p);
 
-      if (DNSSDClient == NULL)
-      {
+        p = NULL;
+      }
+      else
         cupsdLogMessage(CUPSD_LOG_ERROR,
-                        "Unable to communicate with avahi-daemon: %s",
-                        dnssdErrorString(error));
+	                "Syntax error on line %d of remote.cache.", linenum);
+    }
+    else if (!p)
+    {
+      cupsdLogMessage(CUPSD_LOG_ERROR,
+                      "Syntax error on line %d of remote.cache.", linenum);
+    }
+    else if (!_cups_strcasecmp(line, "UUID"))
+    {
+      if (value && !strncmp(value, "urn:uuid:", 9))
+        cupsdSetString(&(p->uuid), value);
+      else
+        cupsdLogMessage(CUPSD_LOG_ERROR,
+	                "Bad UUID on line %d of remote.cache.", linenum);
+    }
+    else if (!_cups_strcasecmp(line, "Info"))
+    {
+      if (value)
+	cupsdSetString(&p->info, value);
+    }
+    else if (!_cups_strcasecmp(line, "MakeModel"))
+    {
+      if (value)
+	cupsdSetString(&p->make_model, value);
+    }
+    else if (!_cups_strcasecmp(line, "Location"))
+    {
+      if (value)
+	cupsdSetString(&p->location, value);
+    }
+    else if (!_cups_strcasecmp(line, "DeviceURI"))
+    {
+      if (value)
+      {
+	httpSeparateURI(HTTP_URI_CODING_ALL, value, scheme, sizeof(scheme),
+	                username, sizeof(username), host, sizeof(host), &port,
+			resource, sizeof(resource));
+
+	cupsdSetString(&p->hostname, host);
+	cupsdSetString(&p->uri, value);
+	cupsdSetDeviceURI(p, value);
+      }
+      else
+	cupsdLogMessage(CUPSD_LOG_ERROR,
+	                "Syntax error on line %d of remote.cache.", linenum);
+    }
+    else if (!_cups_strcasecmp(line, "Option") && value)
+    {
+     /*
+      * Option name value
+      */
 
-        if (FatalErrors & CUPSD_FATAL_BROWSE)
-	  cupsdEndProcess(getpid(), 0);
+      for (valueptr = value; *valueptr && !isspace(*valueptr & 255); valueptr ++);
 
-        avahi_threaded_poll_free(DNSSDMaster);
-        DNSSDMaster = NULL;
+      if (!*valueptr)
+        cupsdLogMessage(CUPSD_LOG_ERROR,
+	                "Syntax error on line %d of remote.cache.", linenum);
+      else
+      {
+        for (; *valueptr && isspace(*valueptr & 255); *valueptr++ = '\0');
+
+        p->num_options = cupsAddOption(value, valueptr, p->num_options,
+	                               &(p->options));
+      }
+    }
+    else if (!_cups_strcasecmp(line, "Reason"))
+    {
+      if (value)
+      {
+        for (i = 0 ; i < p->num_reasons; i ++)
+	  if (!strcmp(value, p->reasons[i]))
+	    break;
+
+        if (i >= p->num_reasons &&
+	    p->num_reasons < (int)(sizeof(p->reasons) / sizeof(p->reasons[0])))
+	{
+	  p->reasons[p->num_reasons] = _cupsStrAlloc(value);
+	  p->num_reasons ++;
+	}
       }
       else
-	avahi_threaded_poll_start(DNSSDMaster);
+	cupsdLogMessage(CUPSD_LOG_ERROR,
+	                "Syntax error on line %d of remote.cache.", linenum);
     }
-#  endif /* HAVE_DNSSD */
+    else if (!_cups_strcasecmp(line, "State"))
+    {
+     /*
+      * Set the initial queue state...
+      */
 
-   /*
-    * Then get the port we use for registrations.  If we are not listening
-    * on any non-local ports, there is no sense sharing local printers via
-    * Bonjour...
-    */
+      if (value && !_cups_strcasecmp(value, "idle"))
+        p->state = IPP_PRINTER_IDLE;
+      else if (value && !_cups_strcasecmp(value, "stopped"))
+      {
+        p->state = IPP_PRINTER_STOPPED;
+	cupsdSetPrinterReasons(p, "+paused");
+      }
+      else
+	cupsdLogMessage(CUPSD_LOG_ERROR,
+	                "Syntax error on line %d of remote.cache.", linenum);
+    }
+    else if (!_cups_strcasecmp(line, "StateMessage"))
+    {
+     /*
+      * Set the initial queue state message...
+      */
 
-    DNSSDPort = 0;
+      if (value)
+	strlcpy(p->state_message, value, sizeof(p->state_message));
+    }
+    else if (!_cups_strcasecmp(line, "Accepting"))
+    {
+     /*
+      * Set the initial accepting state...
+      */
 
-    for (lis = (cupsd_listener_t *)cupsArrayFirst(Listeners);
-	 lis;
-	 lis = (cupsd_listener_t *)cupsArrayNext(Listeners))
+      if (value &&
+          (!_cups_strcasecmp(value, "yes") ||
+           !_cups_strcasecmp(value, "on") ||
+           !_cups_strcasecmp(value, "true")))
+        p->accepting = 1;
+      else if (value &&
+               (!_cups_strcasecmp(value, "no") ||
+        	!_cups_strcasecmp(value, "off") ||
+        	!_cups_strcasecmp(value, "false")))
+        p->accepting = 0;
+      else
+	cupsdLogMessage(CUPSD_LOG_ERROR,
+	                "Syntax error on line %d of remote.cache.", linenum);
+    }
+    else if (!_cups_strcasecmp(line, "Type"))
     {
-      if (httpAddrLocalhost(&(lis->address)))
-	continue;
+      if (value)
+        p->type = atoi(value);
+      else
+	cupsdLogMessage(CUPSD_LOG_ERROR,
+	                "Syntax error on line %d of remote.cache.", linenum);
+    }
+    else if (!_cups_strcasecmp(line, "BrowseTime"))
+    {
+      if (value)
+      {
+        time_t t = atoi(value);
 
-      DNSSDPort = _httpAddrPort(&(lis->address));
-      break;
+	if (t > p->browse_expire)
+          p->browse_expire = t;
+      }
+      else
+	cupsdLogMessage(CUPSD_LOG_ERROR,
+	                "Syntax error on line %d of remote.cache.", linenum);
     }
+    else if (!_cups_strcasecmp(line, "JobSheets"))
+    {
+     /*
+      * Set the initial job sheets...
+      */
 
-   /*
-    * Set the computer name and register the web interface...
-    */
+      if (value)
+      {
+	for (valueptr = value; *valueptr && !isspace(*valueptr & 255); valueptr ++);
 
-    cupsdUpdateDNSSDName();
-  }
-#endif /* HAVE_DNSSD || HAVE_AVAHI */
+	if (*valueptr)
+          *valueptr++ = '\0';
 
- /*
-  * Enable LPD and SMB printer sharing as needed through external programs...
-  */
+	cupsdSetString(&p->job_sheets[0], value);
 
-  if (BrowseLocalProtocols & BROWSE_LPD)
-    update_lpd(1);
+	while (isspace(*valueptr & 255))
+          valueptr ++;
 
-  if (BrowseLocalProtocols & BROWSE_SMB)
-    update_smb(1);
+	if (*valueptr)
+	{
+          for (value = valueptr; *valueptr && !isspace(*valueptr & 255); valueptr ++);
+
+	  if (*valueptr)
+            *valueptr = '\0';
+
+	  cupsdSetString(&p->job_sheets[1], value);
+	}
+      }
+      else
+	cupsdLogMessage(CUPSD_LOG_ERROR,
+	                "Syntax error on line %d of remote.cache.", linenum);
+    }
+    else if (!_cups_strcasecmp(line, "AllowUser"))
+    {
+      if (value)
+      {
+        p->deny_users = 0;
+        cupsdAddString(&(p->users), value);
+      }
+      else
+	cupsdLogMessage(CUPSD_LOG_ERROR,
+	                "Syntax error on line %d of remote.cache.", linenum);
+    }
+    else if (!_cups_strcasecmp(line, "DenyUser"))
+    {
+      if (value)
+      {
+        p->deny_users = 1;
+        cupsdAddString(&(p->users), value);
+      }
+      else
+	cupsdLogMessage(CUPSD_LOG_ERROR,
+	                "Syntax error on line %d of remote.cache.", linenum);
+    }
+    else
+    {
+     /*
+      * Something else we don't understand...
+      */
+
+      cupsdLogMessage(CUPSD_LOG_ERROR,
+                      "Unknown configuration directive %s on line %d of remote.cache.",
+	              line, linenum);
+    }
+  }
+
+  cupsFileClose(fp);
 
  /*
-  * Register the individual printers
+  * Do auto-classing if needed...
   */
 
-  for (p = (cupsd_printer_t *)cupsArrayFirst(Printers);
-       p;
-       p = (cupsd_printer_t *)cupsArrayNext(Printers))
-    if (!(p->type & (CUPS_PRINTER_REMOTE | CUPS_PRINTER_SCANNER)))
-      cupsdRegisterPrinter(p);
+  process_implicit_classes();
 }
 
 
 /*
- * 'cupsdStopBrowsing()' - Stop sending and receiving broadcast information.
+ * 'cupsdRegisterPrinter()' - Start sending broadcast information for a
+ *                            printer or update the broadcast contents.
  */
 
 void
-cupsdStopBrowsing(void)
+cupsdRegisterPrinter(cupsd_printer_t *p)/* I - Printer */
 {
-  cupsd_printer_t	*p;		/* Current printer */
-
+  cupsdLogMessage(CUPSD_LOG_DEBUG, "cupsdRegisterPrinter(p=%p(%s))", p,
+                  p->name);
 
-  if (!Browsing || !BrowseLocalProtocols)
+  if (!Browsing || !BrowseLocalProtocols ||
+      (p->type & (CUPS_PRINTER_REMOTE | CUPS_PRINTER_IMPLICIT |
+                  CUPS_PRINTER_SCANNER)))
     return;
 
- /*
-  * De-register the individual printers
-  */
-
-  for (p = (cupsd_printer_t *)cupsArrayFirst(Printers);
-       p;
-       p = (cupsd_printer_t *)cupsArrayNext(Printers))
-    if (!(p->type & (CUPS_PRINTER_REMOTE | CUPS_PRINTER_SCANNER)))
-      cupsdDeregisterPrinter(p, 1);
-
- /*
-  * Shut down browsing sockets...
-  */
-
 #if defined(HAVE_DNSSD) || defined(HAVE_AVAHI)
   if ((BrowseLocalProtocols & BROWSE_DNSSD) && DNSSDMaster)
-    dnssdStop();
+    dnssdRegisterPrinter(p);
 #endif /* HAVE_DNSSD || HAVE_AVAHI */
+}
 
- /*
-  * Disable LPD and SMB printer sharing as needed through external programs...
-  */
 
-  if (BrowseLocalProtocols & BROWSE_LPD)
-    update_lpd(0);
+/*
+ * 'cupsdRestartPolling()' - Restart polling servers as needed.
+ */
 
-  if (BrowseLocalProtocols & BROWSE_SMB)
-    update_smb(0);
+void
+cupsdRestartPolling(void)
+{
+  int			i;		/* Looping var */
+  cupsd_dirsvc_poll_t	*pollp;		/* Current polling server */
+
+
+  for (i = 0, pollp = Polled; i < NumPolled; i ++, pollp ++)
+    if (pollp->pid)
+      kill(pollp->pid, SIGHUP);
 }
 
 
-#if defined(HAVE_DNSSD) || defined(HAVE_AVAHI)
 /*
- * 'cupsdUpdateDNSSDName()' - Update the computer name we use for browsing...
+ * 'cupsdSaveRemoteCache()' - Save the remote printer cache.
  */
 
 void
-cupsdUpdateDNSSDName(void)
+cupsdSaveRemoteCache(void)
 {
-  char		webif[1024];		/* Web interface share name */
-#  ifdef __APPLE__
-  SCDynamicStoreRef sc;			/* Context for dynamic store */
-  CFDictionaryRef btmm;			/* Back-to-My-Mac domains */
-  CFStringEncoding nameEncoding;	/* Encoding of computer name */
-  CFStringRef	nameRef;		/* Host name CFString */
-  char		nameBuffer[1024];	/* C-string buffer */
-#  endif /* __APPLE__ */
+  int			i;		/* Looping var */
+  cups_file_t		*fp;		/* remote.cache file */
+  char			filename[1024],	/* remote.cache filename */
+			temp[1024],	/* Temporary string */
+			value[2048],	/* Value string */
+			*name;		/* Current user name */
+  cupsd_printer_t	*printer;	/* Current printer class */
+  time_t		curtime;	/* Current time */
+  struct tm		*curdate;	/* Current date */
+  cups_option_t		*option;	/* Current option */
 
 
  /*
-  * Only share the web interface and printers when non-local listening is
-  * enabled...
+  * Create the remote.cache file...
   */
 
-  if (!DNSSDPort)
+  snprintf(filename, sizeof(filename), "%s/remote.cache", CacheDir);
+
+  if ((fp = cupsdCreateConfFile(filename, ConfigFilePerm)) == NULL)
     return;
 
+  cupsdLogMessage(CUPSD_LOG_DEBUG, "Saving remote.cache...");
+
  /*
-  * Get the computer name as a c-string...
+  * Write a small header to the file...
   */
 
-#  ifdef __APPLE__
-  sc = SCDynamicStoreCreate(kCFAllocatorDefault, CFSTR("cupsd"), NULL, NULL);
+  curtime = time(NULL);
+  curdate = localtime(&curtime);
+  strftime(temp, sizeof(temp) - 1, "%Y-%m-%d %H:%M", curdate);
 
-  if (sc)
+  cupsFilePuts(fp, "# Remote cache file for " CUPS_SVERSION "\n");
+  cupsFilePrintf(fp, "# Written by cupsd on %s\n", temp);
+
+ /*
+  * Write each local printer known to the system...
+  */
+
+  for (printer = (cupsd_printer_t *)cupsArrayFirst(Printers);
+       printer;
+       printer = (cupsd_printer_t *)cupsArrayNext(Printers))
   {
    /*
-    * Get the computer name from the dynamic store...
+    * Skip local destinations...
     */
 
-    cupsdClearString(&DNSSDComputerName);
+    if (!(printer->type & CUPS_PRINTER_DISCOVERED))
+      continue;
 
-    if ((nameRef = SCDynamicStoreCopyComputerName(sc, &nameEncoding)) != NULL)
-    {
-      if (CFStringGetCString(nameRef, nameBuffer, sizeof(nameBuffer),
-			     kCFStringEncodingUTF8))
-      {
-        cupsdLogMessage(CUPSD_LOG_DEBUG,
-	                "Dynamic store computer name is \"%s\".", nameBuffer);
-	cupsdSetString(&DNSSDComputerName, nameBuffer);
-      }
+   /*
+    * Write printers as needed...
+    */
 
-      CFRelease(nameRef);
-    }
+    if (printer == DefaultPrinter)
+      cupsFilePuts(fp, "<Default");
+    else
+      cupsFilePutChar(fp, '<');
 
-    if (!DNSSDComputerName)
-    {
-     /*
-      * Use the ServerName instead...
-      */
+    if (printer->type & CUPS_PRINTER_CLASS)
+      cupsFilePrintf(fp, "Class %s>\n", printer->name);
+    else
+      cupsFilePrintf(fp, "Printer %s>\n", printer->name);
 
-      cupsdLogMessage(CUPSD_LOG_DEBUG,
-                      "Using ServerName \"%s\" as computer name.", ServerName);
-      cupsdSetString(&DNSSDComputerName, ServerName);
-    }
+    cupsFilePrintf(fp, "BrowseTime %d\n", (int)printer->browse_expire);
 
-   /*
-    * Get the local hostname from the dynamic store...
-    */
+    cupsFilePrintf(fp, "UUID %s\n", printer->uuid);
 
-    cupsdClearString(&DNSSDHostName);
+    if (printer->info)
+      cupsFilePutConf(fp, "Info", printer->info);
 
-    if ((nameRef = SCDynamicStoreCopyLocalHostName(sc)) != NULL)
-    {
-      if (CFStringGetCString(nameRef, nameBuffer, sizeof(nameBuffer),
-			     kCFStringEncodingUTF8))
-      {
-        cupsdLogMessage(CUPSD_LOG_DEBUG,
-	                "Dynamic store host name is \"%s\".", nameBuffer);
-	cupsdSetString(&DNSSDHostName, nameBuffer);
-      }
+    if (printer->location)
+      cupsFilePutConf(fp, "Location", printer->location);
 
-      CFRelease(nameRef);
-    }
+    if (printer->make_model)
+      cupsFilePutConf(fp, "MakeModel", printer->make_model);
 
-    if (!DNSSDHostName)
-    {
-     /*
-      * Use the ServerName instead...
-      */
+    cupsFilePutConf(fp, "DeviceURI", printer->device_uri);
 
-      cupsdLogMessage(CUPSD_LOG_DEBUG,
-                      "Using ServerName \"%s\" as host name.", ServerName);
-      cupsdSetString(&DNSSDHostName, ServerName);
-    }
+    if (printer->state == IPP_PRINTER_STOPPED)
+      cupsFilePuts(fp, "State Stopped\n");
+    else
+      cupsFilePuts(fp, "State Idle\n");
 
-   /*
-    * Get any Back-to-My-Mac domains and add them as aliases...
-    */
+    for (i = 0; i < printer->num_reasons; i ++)
+      cupsFilePutConf(fp, "Reason", printer->reasons[i]);
 
-    cupsdFreeAliases(DNSSDAlias);
-    DNSSDAlias = NULL;
+    cupsFilePrintf(fp, "Type %d\n", printer->type);
 
-    btmm = SCDynamicStoreCopyValue(sc, CFSTR("Setup:/Network/BackToMyMac"));
-    if (btmm && CFGetTypeID(btmm) == CFDictionaryGetTypeID())
-    {
-      cupsdLogMessage(CUPSD_LOG_DEBUG, "%d Back to My Mac aliases to add.",
-		      (int)CFDictionaryGetCount(btmm));
-      CFDictionaryApplyFunction(btmm, dnssdAddAlias, NULL);
-    }
-    else if (btmm)
-      cupsdLogMessage(CUPSD_LOG_ERROR,
-		      "Bad Back to My Mac data in dynamic store!");
+    if (printer->accepting)
+      cupsFilePuts(fp, "Accepting Yes\n");
     else
-      cupsdLogMessage(CUPSD_LOG_DEBUG, "No Back to My Mac aliases to add.");
+      cupsFilePuts(fp, "Accepting No\n");
 
-    if (btmm)
-      CFRelease(btmm);
+    snprintf(value, sizeof(value), "%s %s", printer->job_sheets[0],
+             printer->job_sheets[1]);
+    cupsFilePutConf(fp, "JobSheets", value);
 
-    CFRelease(sc);
-  }
-  else
-#  endif /* __APPLE__ */
-#  ifdef HAVE_AVAHI
-  if (DNSSDClient)
-  {
-    const char	*host_name = avahi_client_get_host_name(DNSSDClient);
-    const char	*host_fqdn = avahi_client_get_host_name_fqdn(DNSSDClient);
+    for (name = (char *)cupsArrayFirst(printer->users);
+	 name;
+	 name = (char *)cupsArrayNext(printer->users))
+      cupsFilePutConf(fp, printer->deny_users ? "DenyUser" : "AllowUser", name);
 
-    cupsdSetString(&DNSSDComputerName, host_name ? host_name : ServerName);
+    for (i = printer->num_options, option = printer->options;
+         i > 0;
+	 i --, option ++)
+    {
+      snprintf(value, sizeof(value), "%s %s", option->name, option->value);
+      cupsFilePutConf(fp, "Option", value);
+    }
 
-    if (host_fqdn)
-      cupsdSetString(&DNSSDHostName, host_fqdn);
-    else if (strchr(ServerName, '.'))
-      cupsdSetString(&DNSSDHostName, ServerName);
+    if (printer->type & CUPS_PRINTER_CLASS)
+      cupsFilePuts(fp, "</Class>\n");
     else
-      cupsdSetStringf(&DNSSDHostName, "%s.local", ServerName);
+      cupsFilePuts(fp, "</Printer>\n");
   }
-  else
-#  endif /* HAVE_AVAHI */
-  {
-    cupsdSetString(&DNSSDComputerName, ServerName);
 
-    if (strchr(ServerName, '.'))
-      cupsdSetString(&DNSSDHostName, ServerName);
-    else
-      cupsdSetStringf(&DNSSDHostName, "%s.local", ServerName);
-  }
+  cupsdCloseCreatedConfFile(fp, filename);
+}
+
+
+/*
+ * 'cupsdSendBrowseList()' - Send new browsing information as necessary.
+ */
+
+void
+cupsdSendBrowseList(void)
+{
+  int			count;		/* Number of dests to update */
+  cupsd_printer_t	*p;		/* Current printer */
+  time_t		ut,		/* Minimum update time */
+			to;		/* Timeout time */
+
+
+  if (!Browsing || !Printers)
+    return;
 
  /*
-  * Then (re)register the web interface if enabled...
+  * Compute the update and timeout times...
   */
 
-  if (BrowseWebIF)
+  to = time(NULL);
+  ut = to - BrowseInterval;
+
+ /*
+  * Figure out how many printers need an update...
+  */
+
+  if (BrowseInterval > 0 && BrowseLocalProtocols)
   {
-    if (DNSSDComputerName)
-      snprintf(webif, sizeof(webif), "CUPS @ %s", DNSSDComputerName);
+    int	max_count;			/* Maximum number to update */
+
+
+   /*
+    * Throttle the number of printers we'll be updating this time
+    * around based on the number of queues that need updating and
+    * the maximum number of queues to update each second...
+    */
+
+    max_count = 2 * cupsArrayCount(Printers) / BrowseInterval + 1;
+
+    for (count = 0, p = (cupsd_printer_t *)cupsArrayFirst(Printers);
+         count < max_count && p != NULL;
+	 p = (cupsd_printer_t *)cupsArrayNext(Printers))
+      if (!(p->type & (CUPS_PRINTER_REMOTE | CUPS_PRINTER_IMPLICIT |
+                       CUPS_PRINTER_SCANNER)) &&
+          p->shared && p->browse_time < ut)
+        count ++;
+
+   /*
+    * Loop through all of the printers and send local updates as needed...
+    */
+
+    if (BrowseNext)
+      p = (cupsd_printer_t *)cupsArrayFind(Printers, BrowseNext);
     else
-      strlcpy(webif, "CUPS", sizeof(webif));
+      p = (cupsd_printer_t *)cupsArrayFirst(Printers);
 
-    dnssdDeregisterInstance(&WebIFSrv);
-    dnssdRegisterInstance(&WebIFSrv, NULL, webif, "_http._tcp", "_printer",
-                          DNSSDPort, NULL, 1);
-  }
-}
+    for (;
+         count > 0;
+	 p = (cupsd_printer_t *)cupsArrayNext(Printers))
+    {
+     /*
+      * Check for wraparound...
+      */
 
+      if (!p)
+        p = (cupsd_printer_t *)cupsArrayFirst(Printers);
 
-#  ifdef __APPLE__
-/*
- * 'dnssdAddAlias()' - Add a DNS-SD alias name.
- */
+      if (!p)
+        break;
+      else if ((p->type & (CUPS_PRINTER_REMOTE | CUPS_PRINTER_IMPLICIT |
+                           CUPS_PRINTER_SCANNER)) ||
+               !p->shared)
+        continue;
+      else if (p->browse_time < ut)
+      {
+       /*
+	* Need to send an update...
+	*/
 
-static void
-dnssdAddAlias(const void *key,		/* I - Key */
-              const void *value,	/* I - Value (domain) */
-	      void       *context)	/* I - Unused */
-{
-  char	valueStr[1024],			/* Domain string */
-	hostname[1024],			/* Complete hostname */
-	*hostptr;			/* Pointer into hostname */
+	count --;
 
+	p->browse_time = time(NULL);
 
-  (void)key;
-  (void)context;
+	if ((BrowseLocalProtocols & BROWSE_CUPS) && BrowseSocket >= 0)
+          send_cups_browse(p);
+      }
+    }
 
-  if (CFGetTypeID((CFStringRef)value) == CFStringGetTypeID() &&
-      CFStringGetCString((CFStringRef)value, valueStr, sizeof(valueStr),
-                         kCFStringEncodingUTF8))
+   /*
+    * Save where we left off so that all printers get updated...
+    */
+
+    BrowseNext = p;
+  }
+
+ /*
+  * Loop through all of the printers and timeout old printers as needed...
+  */
+
+  for (p = (cupsd_printer_t *)cupsArrayFirst(Printers);
+       p;
+       p = (cupsd_printer_t *)cupsArrayNext(Printers))
   {
-    snprintf(hostname, sizeof(hostname), "%s.%s", DNSSDHostName, valueStr);
-    hostptr = hostname + strlen(hostname) - 1;
-    if (*hostptr == '.')
-      *hostptr = '\0';			/* Strip trailing dot */
+   /*
+    * If this is a remote queue, see if it needs to be timed out...
+    */
 
-    if (!DNSSDAlias)
-      DNSSDAlias = cupsArrayNew(NULL, NULL);
+    if ((p->type & CUPS_PRINTER_DISCOVERED) &&
+        !(p->type & CUPS_PRINTER_IMPLICIT) &&
+	p->browse_expire < to)
+    {
+      cupsdAddEvent(CUPSD_EVENT_PRINTER_DELETED, p, NULL,
+		    "%s \'%s\' deleted by directory services (timeout).",
+		    (p->type & CUPS_PRINTER_CLASS) ? "Class" : "Printer",
+		    p->name);
 
-    cupsdAddAlias(DNSSDAlias, hostname);
-    cupsdLogMessage(CUPSD_LOG_DEBUG, "Added Back to My Mac ServerAlias %s",
-		    hostname);
+      cupsdLogMessage(CUPSD_LOG_DEBUG,
+		      "Remote destination \"%s\" has timed out; "
+		      "deleting it...",
+		      p->name);
+
+      cupsArraySave(Printers);
+      cupsdDeletePrinter(p, 1);
+      cupsArrayRestore(Printers);
+      cupsdMarkDirty(CUPSD_DIRTY_PRINTCAP | CUPSD_DIRTY_REMOTE);
+    }
   }
-  else
-    cupsdLogMessage(CUPSD_LOG_ERROR,
-                    "Bad Back to My Mac domain in dynamic store!");
 }
-#  endif /* __APPLE__ */
 
 
 /*
- * 'dnssdBuildTxtRecord()' - Build a TXT record from printer info.
+ * 'cupsdStartBrowsing()' - Start sending and receiving broadcast information.
  */
 
-static cupsd_txt_t			/* O - TXT record */
-dnssdBuildTxtRecord(
-    cupsd_printer_t *p,			/* I - Printer information */
-    int             for_lpd)		/* I - 1 = LPD, 0 = IPP */
+void
+cupsdStartBrowsing(void)
 {
-  int		i,			/* Looping var */
-		count;			/* Count of key/value pairs */
-  char		admin_hostname[256],	/* .local hostname for admin page */
-		adminurl_str[256],	/* URL for the admin page */
-		type_str[32],		/* Type to string buffer */
-		state_str[32],		/* State to string buffer */
-		rp_str[1024],		/* Queue name string buffer */
-		air_str[1024],		/* auth-info-required string buffer */
-		*keyvalue[32][2];	/* Table of key/value pairs */
-  cupsd_txt_t	txt;			/* TXT record */
+  int			val;		/* Socket option value */
+  struct sockaddr_in	addr;		/* Broadcast address */
+  cupsd_printer_t	*p;		/* Current printer */
 
 
- /*
-  * Load up the key value pairs...
-  */
+  BrowseNext = NULL;
 
-  count = 0;
+  if (!Browsing || !(BrowseLocalProtocols | BrowseRemoteProtocols))
+    return;
 
-  if (!for_lpd || (BrowseLocalProtocols & BROWSE_LPD))
+  if ((BrowseLocalProtocols | BrowseRemoteProtocols) & BROWSE_CUPS)
   {
-    keyvalue[count  ][0] = "txtvers";
-    keyvalue[count++][1] = "1";
+    if (BrowseSocket < 0)
+    {
+     /*
+      * Create the broadcast socket...
+      */
 
-    keyvalue[count  ][0] = "qtotal";
-    keyvalue[count++][1] = "1";
+      if ((BrowseSocket = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
+      {
+	cupsdLogMessage(CUPSD_LOG_ERROR,
+			"Unable to create broadcast socket - %s.",
+			strerror(errno));
+	BrowseLocalProtocols &= ~BROWSE_CUPS;
+	BrowseRemoteProtocols &= ~BROWSE_CUPS;
 
-    keyvalue[count  ][0] = "rp";
-    keyvalue[count++][1] = rp_str;
-    if (for_lpd)
-      strlcpy(rp_str, p->name, sizeof(rp_str));
-    else
-      snprintf(rp_str, sizeof(rp_str), "%s/%s",
-	       (p->type & CUPS_PRINTER_CLASS) ? "classes" : "printers",
-	       p->name);
+	if (FatalErrors & CUPSD_FATAL_BROWSE)
+	  cupsdEndProcess(getpid(), 0);
+      }
+    }
 
-    keyvalue[count  ][0] = "ty";
-    keyvalue[count++][1] = p->make_model ? p->make_model : "Unknown";
+    if (BrowseSocket >= 0)
+    {
+     /*
+      * Bind the socket to browse port...
+      */
 
-    if (strstr(DNSSDHostName, ".local"))
-      strlcpy(admin_hostname, DNSSDHostName, sizeof(admin_hostname));
-    else
-      snprintf(admin_hostname, sizeof(admin_hostname), "%s.local.",
-               DNSSDHostName);
-    httpAssembleURIf(HTTP_URI_CODING_ALL, adminurl_str, sizeof(adminurl_str),
-#  ifdef HAVE_SSL
-		     "https",
-#  else
-		     "http",
-#  endif /* HAVE_SSL */
-		     NULL, admin_hostname, DNSSDPort, "/%s/%s",
-		     (p->type & CUPS_PRINTER_CLASS) ? "classes" : "printers",
-		     p->name);
-    keyvalue[count  ][0] = "adminurl";
-    keyvalue[count++][1] = adminurl_str;
+      memset(&addr, 0, sizeof(addr));
+      addr.sin_addr.s_addr = htonl(INADDR_ANY);
+      addr.sin_family      = AF_INET;
+      addr.sin_port        = htons(BrowsePort);
 
-    if (p->location)
-    {
-      keyvalue[count  ][0] = "note";
-      keyvalue[count++][1] = p->location;
+      if (bind(BrowseSocket, (struct sockaddr *)&addr, sizeof(addr)))
+      {
+	cupsdLogMessage(CUPSD_LOG_ERROR,
+			"Unable to bind broadcast socket - %s.",
+			strerror(errno));
+
+#ifdef WIN32
+	closesocket(BrowseSocket);
+#else
+	close(BrowseSocket);
+#endif /* WIN32 */
+
+	BrowseSocket = -1;
+	BrowseLocalProtocols &= ~BROWSE_CUPS;
+	BrowseRemoteProtocols &= ~BROWSE_CUPS;
+
+	if (FatalErrors & CUPSD_FATAL_BROWSE)
+	  cupsdEndProcess(getpid(), 0);
+      }
     }
 
-    keyvalue[count  ][0] = "priority";
-    keyvalue[count++][1] = for_lpd ? "100" : "0";
+    if (BrowseSocket >= 0)
+    {
+     /*
+      * Set the "broadcast" flag...
+      */
 
-    keyvalue[count  ][0] = "product";
-    keyvalue[count++][1] = p->pc && p->pc->product ? p->pc->product : "Unknown";
+      val = 1;
+      if (setsockopt(BrowseSocket, SOL_SOCKET, SO_BROADCAST, &val, sizeof(val)))
+      {
+	cupsdLogMessage(CUPSD_LOG_ERROR, "Unable to set broadcast mode - %s.",
+			strerror(errno));
 
-    keyvalue[count  ][0] = "pdl";
-    keyvalue[count++][1] = p->pdl ? p->pdl : "application/postscript";
+#ifdef WIN32
+	closesocket(BrowseSocket);
+#else
+	close(BrowseSocket);
+#endif /* WIN32 */
+
+	BrowseSocket = -1;
+	BrowseLocalProtocols &= ~BROWSE_CUPS;
+	BrowseRemoteProtocols &= ~BROWSE_CUPS;
 
-    /* iOS 6 does not accept this printer as AirPrint printer if there is
-       no URF txt record or "URF=none", "DM3" is the minimum needed found
-       by try and error */
-    keyvalue[count  ][0] = "URF";
-    keyvalue[count++][1] = "DM3";
+	if (FatalErrors & CUPSD_FATAL_BROWSE)
+	  cupsdEndProcess(getpid(), 0);
+      }
+    }
 
-    if (get_auth_info_required(p, air_str, sizeof(air_str)))
+    if (BrowseSocket >= 0)
     {
-      keyvalue[count  ][0] = "air";
-      keyvalue[count++][1] = air_str;
+     /*
+      * Close the socket on exec...
+      */
+
+      fcntl(BrowseSocket, F_SETFD, fcntl(BrowseSocket, F_GETFD) | FD_CLOEXEC);
+
+     /*
+      * Finally, add the socket to the input selection set as needed...
+      */
+
+      if (BrowseRemoteProtocols & BROWSE_CUPS)
+      {
+       /*
+	* We only listen if we want remote printers...
+	*/
+
+	cupsdAddSelect(BrowseSocket, (cupsd_selfunc_t)update_cups_browse,
+		       NULL, NULL);
+      }
     }
+  }
+  else
+    BrowseSocket = -1;
 
-    keyvalue[count  ][0] = "UUID";
-    keyvalue[count++][1] = p->uuid + 9;
+#if defined(HAVE_DNSSD) || defined(HAVE_AVAHI)
+  if ((BrowseLocalProtocols | BrowseRemoteProtocols) & BROWSE_DNSSD)
+  {
+    cupsd_listener_t	*lis;		/* Current listening socket */
+#  ifdef HAVE_DNSSD
+    DNSServiceErrorType error;		/* Error from service creation */
 
-  #ifdef HAVE_SSL
-    keyvalue[count  ][0] = "TLS";
-    keyvalue[count++][1] = "1.2";
-  #endif /* HAVE_SSL */
+   /*
+    * First create a "master" connection for all registrations...
+    */
 
-    if (p->type & CUPS_PRINTER_FAX)
+    if ((error = DNSServiceCreateConnection(&DNSSDMaster))
+	    != kDNSServiceErr_NoError)
     {
-      keyvalue[count  ][0] = "Fax";
-      keyvalue[count++][1] = (p->type & CUPS_PRINTER_FAX) ? "T" : "F";
-    }
+      cupsdLogMessage(CUPSD_LOG_ERROR,
+		      "Unable to create master DNS-SD reference: %d", error);
 
-    if (p->type & CUPS_PRINTER_COLOR)
+      if (FatalErrors & CUPSD_FATAL_BROWSE)
+	cupsdEndProcess(getpid(), 0);
+    }
+    else
     {
-      keyvalue[count  ][0] = "Color";
-      keyvalue[count++][1] = (p->type & CUPS_PRINTER_COLOR) ? "T" : "F";
+     /*
+      * Add the master connection to the select list...
+      */
+
+      int fd = DNSServiceRefSockFD(DNSSDMaster);
+
+      fcntl(fd, F_SETFD, fcntl(fd, F_GETFD) | FD_CLOEXEC);
+
+      cupsdAddSelect(fd, (cupsd_selfunc_t)dnssdUpdate, NULL, NULL);
     }
 
-    if (p->type & CUPS_PRINTER_DUPLEX)
+#  else /* HAVE_AVAHI */
+    if ((DNSSDMaster = avahi_threaded_poll_new()) == NULL)
     {
-      keyvalue[count  ][0] = "Duplex";
-      keyvalue[count++][1] = (p->type & CUPS_PRINTER_DUPLEX) ? "T" : "F";
+      cupsdLogMessage(CUPSD_LOG_ERROR, "Unable to create DNS-SD thread.");
+
+      if (FatalErrors & CUPSD_FATAL_BROWSE)
+	cupsdEndProcess(getpid(), 0);
     }
+    else
+    {
+      int error;			/* Error code, if any */
 
-    if (p->type & CUPS_PRINTER_STAPLE)
+      DNSSDClient = avahi_client_new(avahi_threaded_poll_get(DNSSDMaster), 0,
+                                     NULL, NULL, &error);
+
+      if (DNSSDClient == NULL)
+      {
+        cupsdLogMessage(CUPSD_LOG_ERROR,
+                        "Unable to communicate with avahi-daemon: %s",
+                        dnssdErrorString(error));
+
+        if (FatalErrors & CUPSD_FATAL_BROWSE)
+	  cupsdEndProcess(getpid(), 0);
+
+        avahi_threaded_poll_free(DNSSDMaster);
+        DNSSDMaster = NULL;
+      }
+      else
+	avahi_threaded_poll_start(DNSSDMaster);
+    }
+#  endif /* HAVE_DNSSD */
+
+   /*
+    * Then get the port we use for registrations.  If we are not listening
+    * on any non-local ports, there is no sense sharing local printers via
+    * Bonjour...
+    */
+
+    DNSSDPort = 0;
+
+    for (lis = (cupsd_listener_t *)cupsArrayFirst(Listeners);
+	 lis;
+	 lis = (cupsd_listener_t *)cupsArrayNext(Listeners))
     {
-      keyvalue[count  ][0] = "Staple";
-      keyvalue[count++][1] = (p->type & CUPS_PRINTER_STAPLE) ? "T" : "F";
+      if (httpAddrLocalhost(&(lis->address)))
+	continue;
+
+      DNSSDPort = _httpAddrPort(&(lis->address));
+      break;
     }
 
-    if (p->type & CUPS_PRINTER_COPIES)
+   /*
+    * Create an array to track the printers we share...
+    */
+
+    if (BrowseRemoteProtocols & BROWSE_DNSSD)
+      DNSSDPrinters = cupsArrayNew((cups_array_func_t)dnssdComparePrinters,
+				   NULL);
+
+   /*
+    * Set the computer name and register the web interface...
+    */
+
+    cupsdUpdateDNSSDName();
+  }
+#endif /* HAVE_DNSSD || HAVE_AVAHI */
+
+ /*
+  * Enable LPD and SMB printer sharing as needed through external programs...
+  */
+
+  if (BrowseLocalProtocols & BROWSE_LPD)
+    update_lpd(1);
+
+  if (BrowseLocalProtocols & BROWSE_SMB)
+    update_smb(1);
+
+ /*
+  * Register the individual printers
+  */
+
+  for (p = (cupsd_printer_t *)cupsArrayFirst(Printers);
+       p;
+       p = (cupsd_printer_t *)cupsArrayNext(Printers))
+    if (!(p->type & (CUPS_PRINTER_REMOTE | CUPS_PRINTER_IMPLICIT |
+                     CUPS_PRINTER_SCANNER)))
+      cupsdRegisterPrinter(p);
+}
+
+
+/*
+ * 'cupsdStartPolling()' - Start polling servers as needed.
+ */
+
+void
+cupsdStartPolling(void)
+{
+  int			i;		/* Looping var */
+  cupsd_dirsvc_poll_t	*pollp;		/* Current polling server */
+  char			polld[1024];	/* Poll daemon path */
+  char			sport[255];	/* Server port */
+  char			bport[255];	/* Browser port */
+  char			interval[255];	/* Poll interval */
+  int			statusfds[2];	/* Status pipe */
+  char			*argv[6];	/* Arguments */
+  char			*envp[100];	/* Environment */
+
+
+ /*
+  * Don't do anything if we aren't polling...
+  */
+
+  if (NumPolled == 0 || BrowseSocket < 0)
+  {
+    PollPipe         = -1;
+    PollStatusBuffer = NULL;
+    return;
+  }
+
+ /*
+  * Setup string arguments for polld, port and interval options.
+  */
+
+  snprintf(polld, sizeof(polld), "%s/daemon/cups-polld", ServerBin);
+
+  sprintf(bport, "%d", BrowsePort);
+
+  if (BrowseInterval)
+    sprintf(interval, "%d", BrowseInterval);
+  else
+    strcpy(interval, "30");
+
+  argv[0] = "cups-polld";
+  argv[2] = sport;
+  argv[3] = interval;
+  argv[4] = bport;
+  argv[5] = NULL;
+
+  cupsdLoadEnv(envp, (int)(sizeof(envp) / sizeof(envp[0])));
+
+ /*
+  * Create a pipe that receives the status messages from each
+  * polling daemon...
+  */
+
+  if (cupsdOpenPipe(statusfds))
+  {
+    cupsdLogMessage(CUPSD_LOG_ERROR,
+                    "Unable to create polling status pipes - %s.",
+	            strerror(errno));
+    PollPipe         = -1;
+    PollStatusBuffer = NULL;
+    return;
+  }
+
+  PollPipe         = statusfds[0];
+  PollStatusBuffer = cupsdStatBufNew(PollPipe, "[Poll]");
+
+ /*
+  * Run each polling daemon, redirecting stderr to the polling pipe...
+  */
+
+  for (i = 0, pollp = Polled; i < NumPolled; i ++, pollp ++)
+  {
+    sprintf(sport, "%d", pollp->port);
+
+    argv[1] = pollp->hostname;
+
+    if (cupsdStartProcess(polld, argv, envp, -1, -1, statusfds[1], -1, -1,
+                          0, DefaultProfile, NULL, &(pollp->pid)) < 0)
     {
-      keyvalue[count  ][0] = "Copies";
-      keyvalue[count++][1] = (p->type & CUPS_PRINTER_COPIES) ? "T" : "F";
+      cupsdLogMessage(CUPSD_LOG_ERROR,
+                      "cupsdStartPolling: Unable to fork polling daemon - %s",
+                      strerror(errno));
+      pollp->pid = 0;
+      break;
     }
+    else
+      cupsdLogMessage(CUPSD_LOG_DEBUG,
+                      "cupsdStartPolling: Started polling daemon for %s:%d, pid = %d",
+                      pollp->hostname, pollp->port, pollp->pid);
+  }
+
+  close(statusfds[1]);
+
+ /*
+  * Finally, add the pipe to the input selection set...
+  */
+
+  cupsdAddSelect(PollPipe, (cupsd_selfunc_t)update_polling, NULL, NULL);
+}
+
+
+/*
+ * 'cupsdStopBrowsing()' - Stop sending and receiving broadcast information.
+ */
+
+void
+cupsdStopBrowsing(void)
+{
+  cupsd_printer_t	*p;		/* Current printer */
+
+
+  if (!Browsing || !(BrowseLocalProtocols | BrowseRemoteProtocols))
+    return;
+
+ /*
+  * De-register the individual printers
+  */
+
+  for (p = (cupsd_printer_t *)cupsArrayFirst(Printers);
+       p;
+       p = (cupsd_printer_t *)cupsArrayNext(Printers))
+    if (!(p->type & (CUPS_PRINTER_REMOTE | CUPS_PRINTER_IMPLICIT |
+                     CUPS_PRINTER_SCANNER)))
+      cupsdDeregisterPrinter(p, 1);
+
+ /*
+  * Shut down browsing sockets...
+  */
+
+  if (((BrowseLocalProtocols | BrowseRemoteProtocols) & BROWSE_CUPS) &&
+      BrowseSocket >= 0)
+  {
+   /*
+    * Close the socket and remove it from the input selection set.
+    */
+
+#ifdef WIN32
+    closesocket(BrowseSocket);
+#else
+    close(BrowseSocket);
+#endif /* WIN32 */
+
+    cupsdRemoveSelect(BrowseSocket);
+    BrowseSocket = -1;
+  }
+
+#if defined(HAVE_DNSSD) || defined(HAVE_AVAHI)
+  if ((BrowseLocalProtocols & BROWSE_DNSSD) && DNSSDMaster)
+    dnssdStop();
+#endif /* HAVE_DNSSD || HAVE_AVAHI */
+
+ /*
+  * Disable LPD and SMB printer sharing as needed through external programs...
+  */
+
+  if (BrowseLocalProtocols & BROWSE_LPD)
+    update_lpd(0);
+
+  if (BrowseLocalProtocols & BROWSE_SMB)
+    update_smb(0);
+}
+
+
+/*
+ * 'cupsdStopPolling()' - Stop polling servers as needed.
+ */
+
+void
+cupsdStopPolling(void)
+{
+  int			i;		/* Looping var */
+  cupsd_dirsvc_poll_t	*pollp;		/* Current polling server */
+
+
+  if (PollPipe >= 0)
+  {
+    cupsdStatBufDelete(PollStatusBuffer);
+    close(PollPipe);
+
+    cupsdRemoveSelect(PollPipe);
+
+    PollPipe         = -1;
+    PollStatusBuffer = NULL;
+  }
+
+  for (i = 0, pollp = Polled; i < NumPolled; i ++, pollp ++)
+    if (pollp->pid)
+      cupsdEndProcess(pollp->pid, 0);
+}
+
+
+#if defined(HAVE_DNSSD) || defined(HAVE_AVAHI)
+/*
+ * 'cupsdUpdateDNSSDName()' - Update the computer name we use for browsing...
+ */
+
+void
+cupsdUpdateDNSSDName(void)
+{
+  char		webif[1024];		/* Web interface share name */
+#  ifdef __APPLE__
+  SCDynamicStoreRef sc;			/* Context for dynamic store */
+  CFDictionaryRef btmm;			/* Back-to-My-Mac domains */
+  CFStringEncoding nameEncoding;	/* Encoding of computer name */
+  CFStringRef	nameRef;		/* Host name CFString */
+  char		nameBuffer[1024];	/* C-string buffer */
+#  endif /* __APPLE__ */
+
+
+ /*
+  * Only share the web interface and printers when non-local listening is
+  * enabled...
+  */
+
+  if (!DNSSDPort)
+    return;
+
+ /*
+  * Get the computer name as a c-string...
+  */
+
+#  ifdef __APPLE__
+  sc = SCDynamicStoreCreate(kCFAllocatorDefault, CFSTR("cupsd"), NULL, NULL);
+
+  if (sc)
+  {
+   /*
+    * Get the computer name from the dynamic store...
+    */
+
+    cupsdClearString(&DNSSDComputerName);
+
+    if ((nameRef = SCDynamicStoreCopyComputerName(sc, &nameEncoding)) != NULL)
+    {
+      if (CFStringGetCString(nameRef, nameBuffer, sizeof(nameBuffer),
+			     kCFStringEncodingUTF8))
+      {
+        cupsdLogMessage(CUPSD_LOG_DEBUG,
+	                "Dynamic store computer name is \"%s\".", nameBuffer);
+	cupsdSetString(&DNSSDComputerName, nameBuffer);
+      }
+
+      CFRelease(nameRef);
+    }
+
+    if (!DNSSDComputerName)
+    {
+     /*
+      * Use the ServerName instead...
+      */
+
+      cupsdLogMessage(CUPSD_LOG_DEBUG,
+                      "Using ServerName \"%s\" as computer name.", ServerName);
+      cupsdSetString(&DNSSDComputerName, ServerName);
+    }
+
+   /*
+    * Get the local hostname from the dynamic store...
+    */
+
+    cupsdClearString(&DNSSDHostName);
+
+    if ((nameRef = SCDynamicStoreCopyLocalHostName(sc)) != NULL)
+    {
+      if (CFStringGetCString(nameRef, nameBuffer, sizeof(nameBuffer),
+			     kCFStringEncodingUTF8))
+      {
+        cupsdLogMessage(CUPSD_LOG_DEBUG,
+	                "Dynamic store host name is \"%s\".", nameBuffer);
+	cupsdSetString(&DNSSDHostName, nameBuffer);
+      }
+
+      CFRelease(nameRef);
+    }
+
+    if (!DNSSDHostName)
+    {
+     /*
+      * Use the ServerName instead...
+      */
+
+      cupsdLogMessage(CUPSD_LOG_DEBUG,
+                      "Using ServerName \"%s\" as host name.", ServerName);
+      cupsdSetString(&DNSSDHostName, ServerName);
+    }
+
+   /*
+    * Get any Back-to-My-Mac domains and add them as aliases...
+    */
+
+    cupsdFreeAliases(DNSSDAlias);
+    DNSSDAlias = NULL;
+
+    btmm = SCDynamicStoreCopyValue(sc, CFSTR("Setup:/Network/BackToMyMac"));
+    if (btmm && CFGetTypeID(btmm) == CFDictionaryGetTypeID())
+    {
+      cupsdLogMessage(CUPSD_LOG_DEBUG, "%d Back to My Mac aliases to add.",
+		      (int)CFDictionaryGetCount(btmm));
+      CFDictionaryApplyFunction(btmm, dnssdAddAlias, NULL);
+    }
+    else if (btmm)
+      cupsdLogMessage(CUPSD_LOG_ERROR,
+		      "Bad Back to My Mac data in dynamic store!");
+    else
+      cupsdLogMessage(CUPSD_LOG_DEBUG, "No Back to My Mac aliases to add.");
+
+    if (btmm)
+      CFRelease(btmm);
+
+    CFRelease(sc);
+  }
+  else
+#  endif /* __APPLE__ */
+#  ifdef HAVE_AVAHI
+  if (DNSSDClient)
+  {
+    const char	*host_name = avahi_client_get_host_name(DNSSDClient);
+    const char	*host_fqdn = avahi_client_get_host_name_fqdn(DNSSDClient);
+
+    cupsdSetString(&DNSSDComputerName, host_name ? host_name : ServerName);
+
+    if (host_fqdn)
+      cupsdSetString(&DNSSDHostName, host_fqdn);
+    else if (strchr(ServerName, '.'))
+      cupsdSetString(&DNSSDHostName, ServerName);
+    else
+      cupsdSetStringf(&DNSSDHostName, "%s.local", ServerName);
+  }
+  else
+#  endif /* HAVE_AVAHI */
+  {
+    cupsdSetString(&DNSSDComputerName, ServerName);
+
+    if (strchr(ServerName, '.'))
+      cupsdSetString(&DNSSDHostName, ServerName);
+    else
+      cupsdSetStringf(&DNSSDHostName, "%s.local", ServerName);
+  }
+
+ /*
+  * Then (re)register the web interface if enabled...
+  */
+
+  if (BrowseWebIF)
+  {
+    if (DNSSDComputerName)
+      snprintf(webif, sizeof(webif), "CUPS @ %s", DNSSDComputerName);
+    else
+      strlcpy(webif, "CUPS", sizeof(webif));
+
+    dnssdDeregisterInstance(&WebIFSrv);
+    dnssdRegisterInstance(&WebIFSrv, NULL, webif, "_http._tcp", "_printer",
+                          DNSSDPort, NULL, 1);
+  }
+}
+#endif /* HAVE_DNSSD || HAVE_AVAHI */
+
+
+/*
+ * 'dequote()' - Remote quotes from a string.
+ */
+
+static char *				/* O - Dequoted string */
+dequote(char       *d,			/* I - Destination string */
+        const char *s,			/* I - Source string */
+	int        dlen)		/* I - Destination length */
+{
+  char	*dptr;				/* Pointer into destination */
+
+
+  if (s)
+  {
+    for (dptr = d, dlen --; *s && dlen > 0; s ++)
+      if (*s != '\"')
+      {
+	*dptr++ = *s;
+	dlen --;
+      }
+
+    *dptr = '\0';
+  }
+  else
+    *d = '\0';
+
+  return (d);
+}
+
+
+#if defined(HAVE_DNSSD) || defined(HAVE_AVAHI)
+#  ifdef __APPLE__
+/*
+ * 'dnssdAddAlias()' - Add a DNS-SD alias name.
+ */
+
+static void
+dnssdAddAlias(const void *key,		/* I - Key */
+              const void *value,	/* I - Value (domain) */
+	      void       *context)	/* I - Unused */
+{
+  char	valueStr[1024],			/* Domain string */
+	hostname[1024],			/* Complete hostname */
+	*hostptr;			/* Pointer into hostname */
+
+
+  (void)key;
+  (void)context;
+
+  if (CFGetTypeID((CFStringRef)value) == CFStringGetTypeID() &&
+      CFStringGetCString((CFStringRef)value, valueStr, sizeof(valueStr),
+                         kCFStringEncodingUTF8))
+  {
+    snprintf(hostname, sizeof(hostname), "%s.%s", DNSSDHostName, valueStr);
+    hostptr = hostname + strlen(hostname) - 1;
+    if (*hostptr == '.')
+      *hostptr = '\0';			/* Strip trailing dot */
+
+    if (!DNSSDAlias)
+      DNSSDAlias = cupsArrayNew(NULL, NULL);
+
+    cupsdAddAlias(DNSSDAlias, hostname);
+    cupsdLogMessage(CUPSD_LOG_DEBUG, "Added Back to My Mac ServerAlias %s",
+		    hostname);
+  }
+  else
+    cupsdLogMessage(CUPSD_LOG_ERROR,
+                    "Bad Back to My Mac domain in dynamic store!");
+}
+#  endif /* __APPLE__ */
+
+
+/*
+ * 'dnssdBuildTxtRecord()' - Build a TXT record from printer info.
+ */
+
+static cupsd_txt_t			/* O - TXT record */
+dnssdBuildTxtRecord(
+    cupsd_printer_t *p,			/* I - Printer information */
+    int             for_lpd)		/* I - 1 = LPD, 0 = IPP */
+{
+  int		i,			/* Looping var */
+		count;			/* Count of key/value pairs */
+  char		admin_hostname[256],	/* .local hostname for admin page */
+		adminurl_str[256],	/* URL for the admin page */
+		type_str[32],		/* Type to string buffer */
+		state_str[32],		/* State to string buffer */
+		rp_str[1024],		/* Queue name string buffer */
+		air_str[1024],		/* auth-info-required string buffer */
+		*keyvalue[32][2];	/* Table of key/value pairs */
+  cupsd_txt_t	txt;			/* TXT record */
+
+
+ /*
+  * Load up the key value pairs...
+  */
+
+  count = 0;
+
+  if (!for_lpd || (BrowseLocalProtocols & BROWSE_LPD))
+  {
+    keyvalue[count  ][0] = "txtvers";
+    keyvalue[count++][1] = "1";
+
+    keyvalue[count  ][0] = "qtotal";
+    keyvalue[count++][1] = "1";
+
+    keyvalue[count  ][0] = "rp";
+    keyvalue[count++][1] = rp_str;
+    if (for_lpd)
+      strlcpy(rp_str, p->name, sizeof(rp_str));
+    else
+      snprintf(rp_str, sizeof(rp_str), "%s/%s",
+	       (p->type & CUPS_PRINTER_CLASS) ? "classes" : "printers",
+	       p->name);
+
+    keyvalue[count  ][0] = "ty";
+    keyvalue[count++][1] = p->make_model ? p->make_model : "Unknown";
+
+    if (strstr(DNSSDHostName, ".local"))
+      strlcpy(admin_hostname, DNSSDHostName, sizeof(admin_hostname));
+    else
+      snprintf(admin_hostname, sizeof(admin_hostname), "%s.local.",
+               DNSSDHostName);
+    httpAssembleURIf(HTTP_URI_CODING_ALL, adminurl_str, sizeof(adminurl_str),
+#  ifdef HAVE_SSL
+		     "https",
+#  else
+		     "http",
+#  endif /* HAVE_SSL */
+		     NULL, admin_hostname, DNSSDPort, "/%s/%s",
+		     (p->type & CUPS_PRINTER_CLASS) ? "classes" : "printers",
+		     p->name);
+    keyvalue[count  ][0] = "adminurl";
+    keyvalue[count++][1] = adminurl_str;
+
+    if (p->location)
+    {
+      keyvalue[count  ][0] = "note";
+      keyvalue[count++][1] = p->location;
+    }
+
+    keyvalue[count  ][0] = "priority";
+    keyvalue[count++][1] = for_lpd ? "100" : "0";
+
+    keyvalue[count  ][0] = "product";
+    keyvalue[count++][1] = p->pc && p->pc->product ? p->pc->product : "Unknown";
+
+    keyvalue[count  ][0] = "pdl";
+    keyvalue[count++][1] = p->pdl ? p->pdl : "application/postscript";
+
+    /* iOS 6 does not accept this printer as AirPrint printer if there is
+       no URF txt record or "URF=none", "DM3" is the minimum needed found
+       by try and error */
+    keyvalue[count  ][0] = "URF";
+    keyvalue[count++][1] = "DM3";
+
+    if (get_auth_info_required(p, air_str, sizeof(air_str)))
+    {
+      keyvalue[count  ][0] = "air";
+      keyvalue[count++][1] = air_str;
+    }
+
+    keyvalue[count  ][0] = "UUID";
+    keyvalue[count++][1] = p->uuid + 9;
+
+  #ifdef HAVE_SSL
+    keyvalue[count  ][0] = "TLS";
+    keyvalue[count++][1] = "1.2";
+  #endif /* HAVE_SSL */
+
+    if (p->type & CUPS_PRINTER_FAX)
+    {
+      keyvalue[count  ][0] = "Fax";
+      keyvalue[count++][1] = (p->type & CUPS_PRINTER_FAX) ? "T" : "F";
+    }
+
+    if (p->type & CUPS_PRINTER_COLOR)
+    {
+      keyvalue[count  ][0] = "Color";
+      keyvalue[count++][1] = (p->type & CUPS_PRINTER_COLOR) ? "T" : "F";
+    }
+
+    if (p->type & CUPS_PRINTER_DUPLEX)
+    {
+      keyvalue[count  ][0] = "Duplex";
+      keyvalue[count++][1] = (p->type & CUPS_PRINTER_DUPLEX) ? "T" : "F";
+    }
+
+    if (p->type & CUPS_PRINTER_STAPLE)
+    {
+      keyvalue[count  ][0] = "Staple";
+      keyvalue[count++][1] = (p->type & CUPS_PRINTER_STAPLE) ? "T" : "F";
+    }
+
+    if (p->type & CUPS_PRINTER_COPIES)
+    {
+      keyvalue[count  ][0] = "Copies";
+      keyvalue[count++][1] = (p->type & CUPS_PRINTER_COPIES) ? "T" : "F";
+    }
+
+    if (p->type & CUPS_PRINTER_COLLATE)
+    {
+      keyvalue[count  ][0] = "Collate";
+      keyvalue[count++][1] = (p->type & CUPS_PRINTER_COLLATE) ? "T" : "F";
+    }
+
+    if (p->type & CUPS_PRINTER_PUNCH)
+    {
+      keyvalue[count  ][0] = "Punch";
+      keyvalue[count++][1] = (p->type & CUPS_PRINTER_PUNCH) ? "T" : "F";
+    }
+
+    if (p->type & CUPS_PRINTER_BIND)
+    {
+      keyvalue[count  ][0] = "Bind";
+      keyvalue[count++][1] = (p->type & CUPS_PRINTER_BIND) ? "T" : "F";
+    }
+
+    if (p->type & CUPS_PRINTER_SORT)
+    {
+      keyvalue[count  ][0] = "Sort";
+      keyvalue[count++][1] = (p->type & CUPS_PRINTER_SORT) ? "T" : "F";
+    }
+
+    if (p->type & CUPS_PRINTER_MFP)
+    {
+      keyvalue[count  ][0] = "Scan";
+      keyvalue[count++][1] = (p->type & CUPS_PRINTER_MFP) ? "T" : "F";
+    }
+
+    snprintf(type_str, sizeof(type_str), "0x%X", p->type | CUPS_PRINTER_REMOTE);
+    snprintf(state_str, sizeof(state_str), "%d", p->state);
+
+    keyvalue[count  ][0] = "printer-state";
+    keyvalue[count++][1] = state_str;
+
+    keyvalue[count  ][0] = "printer-type";
+    keyvalue[count++][1] = type_str;
+  }
+
+ /*
+  * Then pack them into a proper txt record...
+  */
+
+#  ifdef HAVE_DNSSD
+  TXTRecordCreate(&txt, 0, NULL);
+
+  for (i = 0; i < count; i ++)
+  {
+    size_t len = strlen(keyvalue[i][1]);
+
+    if (len < 256)
+      TXTRecordSetValue(&txt, keyvalue[i][0], (uint8_t)len, keyvalue[i][1]);
+  }
+
+#  else
+  for (i = 0, txt = NULL; i < count; i ++)
+    txt = avahi_string_list_add_printf(txt, "%s=%s", keyvalue[i][0],
+                                       keyvalue[i][1]);
+#  endif /* HAVE_DNSSD */
+
+  return (txt);
+}
+
+
+/*
+ * 'dnssdComparePrinters()' - Compare the registered names of two printers.
+ */
+
+static int				/* O - Result of comparison */
+dnssdComparePrinters(cupsd_printer_t *a,/* I - First printer */
+                     cupsd_printer_t *b)/* I - Second printer */
+{
+  if (!a || !a->reg_name)
+    if (!b || !b->reg_name)
+      return 0;
+    else
+      return -1;
+  else
+    if (!b || !b->reg_name)
+      return 1;
+    else
+      return (_cups_strcasecmp(a->reg_name, b->reg_name));
+}
+
+
+/*
+ * 'dnssdDeregisterInstance()' - Deregister a DNS-SD service instance.
+ */
+
+static void
+dnssdDeregisterInstance(
+    cupsd_srv_t     *srv)		/* I - Service */
+{
+  if (!srv || !*srv)
+    return;
+
+#  ifdef HAVE_DNSSD
+  DNSServiceRefDeallocate(*srv);
+
+#  else /* HAVE_AVAHI */
+  avahi_threaded_poll_lock(DNSSDMaster);
+  avahi_entry_group_free(*srv);
+  avahi_threaded_poll_unlock(DNSSDMaster);
+#  endif /* HAVE_DNSSD */
+
+  *srv = NULL;
+}
+
+
+/*
+ * 'dnssdDeregisterPrinter()' - Deregister all services for a printer.
+ */
+
+static void
+dnssdDeregisterPrinter(
+    cupsd_printer_t *p,			/* I - Printer */
+    int             clear_name)		/* I - Clear the name? */
+
+{
+  cupsdLogMessage(CUPSD_LOG_DEBUG2,
+                  "dnssdDeregisterPrinter(p=%p(%s), clear_name=%d)", p, p->name,
+                  clear_name);
+
+  if (p->ipp_srv)
+  {
+    dnssdDeregisterInstance(&p->ipp_srv);
+
+#  ifdef HAVE_DNSSD
+#    ifdef HAVE_SSL
+    dnssdDeregisterInstance(&p->ipps_srv);
+#    endif /* HAVE_SSL */
+    dnssdDeregisterInstance(&p->printer_srv);
+#  endif /* HAVE_DNSSD */
+  }
+
+ /*
+  * Remove the printer from the array of DNS-SD printers but keep the
+  * registered name...
+  */
+
+  cupsArrayRemove(DNSSDPrinters, p);
+
+ /*
+  * Optionally clear the service name...
+  */
+
+  if (clear_name)
+    cupsdClearString(&p->reg_name);
+}
+
+
+/*
+ * 'dnssdErrorString()' - Return an error string for an error code.
+ */
+
+static const char *			/* O - Error message */
+dnssdErrorString(int error)		/* I - Error number */
+{
+#  ifdef HAVE_DNSSD
+  switch (error)
+  {
+    case kDNSServiceErr_NoError :
+        return ("OK.");
+
+    default :
+    case kDNSServiceErr_Unknown :
+        return ("Unknown error.");
+
+    case kDNSServiceErr_NoSuchName :
+        return ("Service not found.");
+
+    case kDNSServiceErr_NoMemory :
+        return ("Out of memory.");
+
+    case kDNSServiceErr_BadParam :
+        return ("Bad parameter.");
+
+    case kDNSServiceErr_BadReference :
+        return ("Bad service reference.");
+
+    case kDNSServiceErr_BadState :
+        return ("Bad state.");
+
+    case kDNSServiceErr_BadFlags :
+        return ("Bad flags.");
+
+    case kDNSServiceErr_Unsupported :
+        return ("Unsupported.");
+
+    case kDNSServiceErr_NotInitialized :
+        return ("Not initialized.");
+
+    case kDNSServiceErr_AlreadyRegistered :
+        return ("Already registered.");
+
+    case kDNSServiceErr_NameConflict :
+        return ("Name conflict.");
+
+    case kDNSServiceErr_Invalid :
+        return ("Invalid name.");
+
+    case kDNSServiceErr_Firewall :
+        return ("Firewall prevents registration.");
+
+    case kDNSServiceErr_Incompatible :
+        return ("Client library incompatible.");
+
+    case kDNSServiceErr_BadInterfaceIndex :
+        return ("Bad interface index.");
+
+    case kDNSServiceErr_Refused :
+        return ("Server prevents registration.");
+
+    case kDNSServiceErr_NoSuchRecord :
+        return ("Record not found.");
+
+    case kDNSServiceErr_NoAuth :
+        return ("Authentication required.");
+
+    case kDNSServiceErr_NoSuchKey :
+        return ("Encryption key not found.");
+
+    case kDNSServiceErr_NATTraversal :
+        return ("Unable to traverse NAT boundary.");
+
+    case kDNSServiceErr_DoubleNAT :
+        return ("Unable to traverse double-NAT boundary.");
+
+    case kDNSServiceErr_BadTime :
+        return ("Bad system time.");
+
+    case kDNSServiceErr_BadSig :
+        return ("Bad signature.");
+
+    case kDNSServiceErr_BadKey :
+        return ("Bad encryption key.");
+
+    case kDNSServiceErr_Transient :
+        return ("Transient error occurred - please try again.");
+
+    case kDNSServiceErr_ServiceNotRunning :
+        return ("Server not running.");
+
+    case kDNSServiceErr_NATPortMappingUnsupported :
+        return ("NAT doesn't support NAT-PMP or UPnP.");
+
+    case kDNSServiceErr_NATPortMappingDisabled :
+        return ("NAT supports NAT-PNP or UPnP but it is disabled.");
+
+    case kDNSServiceErr_NoRouter :
+        return ("No Internet/default router configured.");
+
+    case kDNSServiceErr_PollingMode :
+        return ("Service polling mode error.");
+
+    case kDNSServiceErr_Timeout :
+        return ("Service timeout.");
+  }
+
+#  else /* HAVE_AVAHI */
+  return (avahi_strerror(error));
+#  endif /* HAVE_DNSSD */
+}
+
+
+/*
+ * 'dnssdRegisterCallback()' - Free a TXT record.
+ */
+
+static void
+dnssdFreeTxtRecord(cupsd_txt_t *txt)	/* I - TXT record */
+{
+#  ifdef HAVE_DNSSD
+  TXTRecordDeallocate(txt);
+
+#  else /* HAVE_AVAHI */
+  avahi_string_list_free(*txt);
+  *txt = NULL;
+#  endif /* HAVE_DNSSD */
+}
+
+
+/*
+ * 'dnssdRegisterCallback()' - DNSServiceRegister callback.
+ */
+
+#  ifdef HAVE_DNSSD
+static void
+dnssdRegisterCallback(
+    DNSServiceRef	sdRef,		/* I - DNS Service reference */
+    DNSServiceFlags	flags,		/* I - Reserved for future use */
+    DNSServiceErrorType	errorCode,	/* I - Error code */
+    const char		*name,     	/* I - Service name */
+    const char		*regtype,  	/* I - Service type */
+    const char		*domain,   	/* I - Domain. ".local" for now */
+    void		*context)	/* I - Printer */
+{
+  cupsd_printer_t *p = (cupsd_printer_t *)context;
+					/* Current printer */
+
+
+  (void)sdRef;
+  (void)flags;
+  (void)domain;
+
+  cupsdLogMessage(CUPSD_LOG_DEBUG2, "dnssdRegisterCallback(%s, %s) for %s (%s)",
+                  name, regtype, p ? p->name : "Web Interface",
+		  p ? (p->reg_name ? p->reg_name : "(null)") : "NA");
+
+  if (errorCode)
+  {
+    cupsdLogMessage(CUPSD_LOG_ERROR,
+		    "DNSServiceRegister failed with error %d", (int)errorCode);
+    return;
+  }
+  else if (p && (!p->reg_name || _cups_strcasecmp(name, p->reg_name)))
+  {
+    cupsdLogMessage(CUPSD_LOG_INFO, "Using service name \"%s\" for \"%s\"",
+                    name, p->name);
+
+    cupsArrayRemove(DNSSDPrinters, p);
+    cupsdSetString(&p->reg_name, name);
+    cupsArrayAdd(DNSSDPrinters, p);
+
+    LastEvent |= CUPSD_EVENT_PRINTER_MODIFIED;
+  }
+}
+
+#  else /* HAVE_AVAHI */
+static void
+dnssdRegisterCallback(
+    AvahiEntryGroup      *srv,		/* I - Service */
+    AvahiEntryGroupState state,		/* I - Registration state */
+    void                 *context)	/* I - Printer */
+{
+  cupsd_printer_t *p = (cupsd_printer_t *)context;
+					/* Current printer */
+
+  cupsdLogMessage(CUPSD_LOG_DEBUG2,
+                  "dnssdRegisterCallback(srv=%p, state=%d, context=%p) "
+                  "for %s (%s)", srv, state, context,
+                  p ? p->name : "Web Interface",
+		  p ? (p->reg_name ? p->reg_name : "(null)") : "NA");
+
+  /* TODO: Handle collisions with avahi_alternate_service_name(p->reg_name)? */
+}
+#  endif /* HAVE_DNSSD */
+
+
+/*
+ * 'dnssdRegisterInstance()' - Register an instance of a printer service.
+ */
+
+static int				/* O - 1 on success, 0 on failure */
+dnssdRegisterInstance(
+    cupsd_srv_t     *srv,		/* O - Service */
+    cupsd_printer_t *p,			/* I - Printer */
+    char            *name,		/* I - DNS-SD service name */
+    const char      *type,		/* I - DNS-SD service type */
+    const char      *subtypes,		/* I - Subtypes to register or NULL */
+    int             port,		/* I - Port number or 0 */
+    cupsd_txt_t     *txt,		/* I - TXT record */
+    int             commit)		/* I - Commit registration? */
+{
+  char	temp[256],			/* Temporary string */
+	*ptr;				/* Pointer into string */
+  int	error;				/* Any error */
+
+
+  cupsdLogMessage(CUPSD_LOG_DEBUG,
+		  "Registering \"%s\" with DNS-SD type \"%s\".", name, type);
+
+  if (p && !srv)
+  {
+   /*
+    * Assign the correct pointer for "srv"...
+    */
+
+#  ifdef HAVE_DNSSD
+    if (!strcmp(type, "_printer._tcp"))
+      srv = &p->printer_srv;		/* Target LPD service */
+#    ifdef HAVE_SSL
+    else if (!strcmp(type, "_ipps._tcp"))
+      srv = &p->ipps_srv;		/* Target IPPS service */
+#    endif /* HAVE_SSL */
+    else
+      srv = &p->ipp_srv;		/* Target IPP service */
+
+#  else /* HAVE_AVAHI */
+    srv = &p->ipp_srv;			/* Target service group */
+#  endif /* HAVE_DNSSD */
+  }
+
+#  ifdef HAVE_DNSSD
+  (void)commit;
+
+#  else /* HAVE_AVAHI */
+  avahi_threaded_poll_lock(DNSSDMaster);
+
+  if (!*srv)
+    *srv = avahi_entry_group_new(DNSSDClient, dnssdRegisterCallback, NULL);
+  if (!*srv)
+  {
+    avahi_threaded_poll_unlock(DNSSDMaster);
+
+    cupsdLogMessage(CUPSD_LOG_WARN, "DNS-SD registration of \"%s\" failed: %s",
+                    name, dnssdErrorString(avahi_client_errno(DNSSDClient)));
+    return (0);
+  }
+#  endif /* HAVE_DNSSD */
+
+ /*
+  * Make sure the name is <= 63 octets, and when we truncate be sure to
+  * properly truncate any UTF-8 characters...
+  */
+
+  ptr = name + strlen(name);
+  while ((ptr - name) > 63)
+  {
+    do
+    {
+      ptr --;
+    }
+    while (ptr > name && (*ptr & 0xc0) == 0x80);
+
+    if (ptr > name)
+      *ptr = '\0';
+  }
+
+ /*
+  * Register the service...
+  */
+
+#  ifdef HAVE_DNSSD
+  if (subtypes)
+    snprintf(temp, sizeof(temp), "%s,%s", type, subtypes);
+  else
+    strlcpy(temp, type, sizeof(temp));
+
+  *srv  = DNSSDMaster;
+  error = DNSServiceRegister(srv, kDNSServiceFlagsShareConnection,
+			     0, name, temp, NULL, NULL, htons(port),
+			     txt ? TXTRecordGetLength(txt) : 0,
+			     txt ? TXTRecordGetBytesPtr(txt) : NULL,
+			     dnssdRegisterCallback, p);
+
+#  else /* HAVE_AVAHI */
+  if (txt)
+  {
+    AvahiStringList *temptxt;
+    for (temptxt = *txt; temptxt; temptxt = temptxt->next)
+      cupsdLogMessage(CUPSD_LOG_DEBUG, "DNS_SD \"%s\" %s", name, temptxt->text);
+  }
+
+  error = avahi_entry_group_add_service_strlst(*srv, AVAHI_IF_UNSPEC,
+                                               AVAHI_PROTO_UNSPEC, 0, name,
+                                               type, NULL, NULL, port,
+                                               txt ? *txt : NULL);
+  if (error)
+    cupsdLogMessage(CUPSD_LOG_DEBUG, "DNS-SD service add for \"%s\" failed.",
+                    name);
+
+  if (!error && subtypes)
+  {
+   /*
+    * Register all of the subtypes...
+    */
+
+    char	*start,			/* Start of subtype */
+		subtype[256];		/* Subtype string */
+
+    strlcpy(temp, subtypes, sizeof(temp));
+
+    for (start = temp; *start; start = ptr)
+    {
+     /*
+      * Skip leading whitespace...
+      */
+
+      while (*start && isspace(*start & 255))
+        start ++;
+
+     /*
+      * Grab everything up to the next comma or the end of the string...
+      */
+
+      for (ptr = start; *ptr && *ptr != ','; ptr ++);
+
+      if (*ptr)
+        *ptr++ = '\0';
+
+      if (!*start)
+        break;
+
+     /*
+      * Register the subtype...
+      */
+
+      snprintf(subtype, sizeof(subtype), "%s._sub.%s", start, type);
+
+      error = avahi_entry_group_add_service_subtype(*srv, AVAHI_IF_UNSPEC,
+                                                    AVAHI_PROTO_UNSPEC, 0,
+                                                    name, type, NULL, subtype);
+      if (error)
+      {
+        cupsdLogMessage(CUPSD_LOG_DEBUG,
+                        "DNS-SD subtype %s registration for \"%s\" failed." ,
+                        subtype, name);
+        break;
+      }
+    }
+  }
+
+  if (!error && commit)
+  {
+    if ((error = avahi_entry_group_commit(*srv)) != 0)
+      cupsdLogMessage(CUPSD_LOG_DEBUG, "DNS-SD commit of \"%s\" failed.",
+                      name);
+  }
+
+  avahi_threaded_poll_unlock(DNSSDMaster);
+#  endif /* HAVE_DNSSD */
+
+  if (error)
+  {
+    cupsdLogMessage(CUPSD_LOG_WARN, "DNS-SD registration of \"%s\" failed: %s",
+                    name, dnssdErrorString(error));
+    cupsdLogMessage(CUPSD_LOG_DEBUG, "DNS-SD type: %s", type);
+    if (subtypes)
+      cupsdLogMessage(CUPSD_LOG_DEBUG, "DNS-SD sub-types: %s", subtypes);
+  }
+
+  return (!error);
+}
+
+
+/*
+ * 'dnssdRegisterPrinter()' - Start sending broadcast information for a printer
+ *		              or update the broadcast contents.
+ */
+
+static void
+dnssdRegisterPrinter(cupsd_printer_t *p)/* I - Printer */
+{
+  char		name[256];		/* Service name */
+  int		printer_port;		/* LPD port number */
+  int		status;			/* Registration status */
+  cupsd_txt_t	ipp_txt,		/* IPP(S) TXT record */
+ 		printer_txt;		/* LPD TXT record */
+
+  cupsdLogMessage(CUPSD_LOG_DEBUG2, "dnssdRegisterPrinter(%s) %s", p->name,
+                  !p->ipp_srv ? "new" : "update");
+
+ /*
+  * Remove the current registrations if we have them and then return if
+  * per-printer sharing was just disabled...
+  */
+
+  dnssdDeregisterPrinter(p, 0);
+
+  if (!p->shared)
+    return;
+
+ /*
+  * Set the registered name as needed; the registered name takes the form of
+  * "<printer-info> @ <computer name>"...
+  */
+
+  if (!p->reg_name)
+  {
+    if (p->info && strlen(p->info) > 0)
+    {
+      if (DNSSDComputerName)
+	snprintf(name, sizeof(name), "%s @ %s", p->info, DNSSDComputerName);
+      else
+	strlcpy(name, p->info, sizeof(name));
+    }
+    else if (DNSSDComputerName)
+      snprintf(name, sizeof(name), "%s @ %s", p->name, DNSSDComputerName);
+    else
+      strlcpy(name, p->name, sizeof(name));
+  }
+  else
+    strlcpy(name, p->reg_name, sizeof(name));
+
+ /*
+  * Register IPP and LPD...
+  *
+  * We always must register the "_printer" service type in order to reserve
+  * our name, but use port number 0 if we haven't actually configured cups-lpd
+  * to share via LPD...
+  */
+
+  ipp_txt     = dnssdBuildTxtRecord(p, 0);
+  printer_txt = dnssdBuildTxtRecord(p, 1);
+
+  if (BrowseLocalProtocols & BROWSE_LPD)
+    printer_port = 515;
+  else
+    printer_port = 0;
+
+  status = dnssdRegisterInstance(NULL, p, name, "_printer._tcp", NULL,
+                                 printer_port, &printer_txt, 0);
+
+#  ifdef HAVE_SSL
+  if (status)
+    dnssdRegisterInstance(NULL, p, name, "_ipps._tcp", DNSSDSubTypes,
+			  DNSSDPort, &ipp_txt, 0);
+#  endif /* HAVE_SSL */
+
+  if (status)
+  {
+   /*
+    * Use the "_fax-ipp" service type for fax queues, otherwise use "_ipp"...
+    */
+
+    if (p->type & CUPS_PRINTER_FAX)
+      status = dnssdRegisterInstance(NULL, p, name, "_fax-ipp._tcp",
+                                     DNSSDSubTypes, DNSSDPort, &ipp_txt, 1);
+    else
+      status = dnssdRegisterInstance(NULL, p, name, "_ipp._tcp", DNSSDSubTypes,
+                                     DNSSDPort, &ipp_txt, 1);
+  }
+
+  dnssdFreeTxtRecord(&ipp_txt);
+  dnssdFreeTxtRecord(&printer_txt);
+
+  if (status)
+  {
+   /*
+    * Save the registered name and add the printer to the array of DNS-SD
+    * printers...
+    */
+
+    cupsdSetString(&p->reg_name, name);
+    cupsArrayAdd(DNSSDPrinters, p);
+  }
+  else
+  {
+   /*
+    * Registration failed for this printer...
+    */
 
-    if (p->type & CUPS_PRINTER_COLLATE)
-    {
-      keyvalue[count  ][0] = "Collate";
-      keyvalue[count++][1] = (p->type & CUPS_PRINTER_COLLATE) ? "T" : "F";
-    }
+    dnssdDeregisterInstance(&p->ipp_srv);
 
-    if (p->type & CUPS_PRINTER_PUNCH)
-    {
-      keyvalue[count  ][0] = "Punch";
-      keyvalue[count++][1] = (p->type & CUPS_PRINTER_PUNCH) ? "T" : "F";
-    }
+#  ifdef HAVE_DNSSD
+#    ifdef HAVE_SSL
+    dnssdDeregisterInstance(&p->ipps_srv);
+#    endif /* HAVE_SSL */
+    dnssdDeregisterInstance(&p->printer_srv);
+#  endif /* HAVE_DNSSD */
+  }
+}
 
-    if (p->type & CUPS_PRINTER_BIND)
-    {
-      keyvalue[count  ][0] = "Bind";
-      keyvalue[count++][1] = (p->type & CUPS_PRINTER_BIND) ? "T" : "F";
-    }
 
-    if (p->type & CUPS_PRINTER_SORT)
-    {
-      keyvalue[count  ][0] = "Sort";
-      keyvalue[count++][1] = (p->type & CUPS_PRINTER_SORT) ? "T" : "F";
-    }
+/*
+ * 'dnssdStop()' - Stop all DNS-SD registrations.
+ */
 
-    if (p->type & CUPS_PRINTER_MFP)
-    {
-      keyvalue[count  ][0] = "Scan";
-      keyvalue[count++][1] = (p->type & CUPS_PRINTER_MFP) ? "T" : "F";
-    }
+static void
+dnssdStop(void)
+{
+  cupsd_printer_t	*p;		/* Current printer */
 
-    snprintf(type_str, sizeof(type_str), "0x%X", p->type | CUPS_PRINTER_REMOTE);
-    snprintf(state_str, sizeof(state_str), "%d", p->state);
 
-    keyvalue[count  ][0] = "printer-state";
-    keyvalue[count++][1] = state_str;
+ /*
+  * De-register the individual printers
+  */
 
-    keyvalue[count  ][0] = "printer-type";
-    keyvalue[count++][1] = type_str;
-  }
+  for (p = (cupsd_printer_t *)cupsArrayFirst(Printers);
+       p;
+       p = (cupsd_printer_t *)cupsArrayNext(Printers))
+    dnssdDeregisterPrinter(p, 1);
 
  /*
-  * Then pack them into a proper txt record...
+  * Shutdown the rest of the service refs...
   */
 
+  dnssdDeregisterInstance(&WebIFSrv);
+
 #  ifdef HAVE_DNSSD
-  TXTRecordCreate(&txt, 0, NULL);
+  cupsdRemoveSelect(DNSServiceRefSockFD(DNSSDMaster));
 
-  for (i = 0; i < count; i ++)
-  {
-    size_t len = strlen(keyvalue[i][1]);
+  DNSServiceRefDeallocate(DNSSDMaster);
+  DNSSDMaster = NULL;
 
-    if (len < 256)
-      TXTRecordSetValue(&txt, keyvalue[i][0], (uint8_t)len, keyvalue[i][1]);
-  }
+#  else /* HAVE_AVAHI */
+  avahi_client_free(DNSSDClient);
+  DNSSDClient = NULL;
 
-#  else
-  for (i = 0, txt = NULL; i < count; i ++)
-    txt = avahi_string_list_add_printf(txt, "%s=%s", keyvalue[i][0],
-                                       keyvalue[i][1]);
+  avahi_threaded_poll_free(DNSSDMaster);
+  DNSSDMaster = NULL;
 #  endif /* HAVE_DNSSD */
 
-  return (txt);
+  cupsArrayDelete(DNSSDPrinters);
+  DNSSDPrinters = NULL;
+
+  DNSSDPort = 0;
 }
 
 
+#  ifdef HAVE_DNSSD
 /*
- * 'dnssdDeregisterInstance()' - Deregister a DNS-SD service instance.
+ * 'dnssdUpdate()' - Handle DNS-SD queries.
  */
 
 static void
-dnssdDeregisterInstance(
-    cupsd_srv_t     *srv)		/* I - Service */
+dnssdUpdate(void)
 {
-  if (!srv || !*srv)
-    return;
-
-#  ifdef HAVE_DNSSD
-  DNSServiceRefDeallocate(*srv);
+  DNSServiceErrorType	sdErr;		/* Service discovery error */
 
-#  else /* HAVE_AVAHI */
-  avahi_threaded_poll_lock(DNSSDMaster);
-  avahi_entry_group_free(*srv);
-  avahi_threaded_poll_unlock(DNSSDMaster);
-#  endif /* HAVE_DNSSD */
 
-  *srv = NULL;
+  if ((sdErr = DNSServiceProcessResult(DNSSDMaster)) != kDNSServiceErr_NoError)
+  {
+    cupsdLogMessage(CUPSD_LOG_ERROR,
+                    "DNS Service Discovery registration error %d!",
+	            sdErr);
+    dnssdStop();
+  }
 }
+#  endif /* HAVE_DNSSD */
+#endif /* HAVE_DNSSD || HAVE_AVAHI */
 
 
 /*
- * 'dnssdDeregisterPrinter()' - Deregister all services for a printer.
+ * 'get_auth_info_required()' - Get the auth-info-required value to advertise.
  */
 
-static void
-dnssdDeregisterPrinter(
+static char *				/* O - String or NULL if none */
+get_auth_info_required(
     cupsd_printer_t *p,			/* I - Printer */
-    int             clear_name)		/* I - Clear the name? */
-
+    char            *buffer,		/* I - Value buffer */
+    size_t          bufsize)		/* I - Size of value buffer */
 {
-  cupsdLogMessage(CUPSD_LOG_DEBUG2,
-                  "dnssdDeregisterPrinter(p=%p(%s), clear_name=%d)", p, p->name,
-                  clear_name);
+  cupsd_location_t *auth;		/* Pointer to authentication element */
+  char		resource[1024];		/* Printer/class resource path */
 
-  if (p->ipp_srv)
+
+ /*
+  * If auth-info-required is set for this printer, return that...
+  */
+
+  if (p->num_auth_info_required > 0 && strcmp(p->auth_info_required[0], "none"))
   {
-    dnssdDeregisterInstance(&p->ipp_srv);
+    int		i;			/* Looping var */
+    char	*bufptr;		/* Pointer into buffer */
 
-#  ifdef HAVE_DNSSD
-#    ifdef HAVE_SSL
-    dnssdDeregisterInstance(&p->ipps_srv);
-#    endif /* HAVE_SSL */
-    dnssdDeregisterInstance(&p->printer_srv);
-#  endif /* HAVE_DNSSD */
+    for (i = 0, bufptr = buffer; i < p->num_auth_info_required; i ++)
+    {
+      if (bufptr >= (buffer + bufsize - 2))
+	break;
+
+      if (i)
+	*bufptr++ = ',';
+
+      strlcpy(bufptr, p->auth_info_required[i], bufsize - (bufptr - buffer));
+      bufptr += strlen(bufptr);
+    }
+
+    return (buffer);
   }
 
  /*
-  * Remove the printer from the array of DNS-SD printers but keep the
-  * registered name...
+  * Figure out the authentication data requirements to advertise...
   */
 
-  cupsArrayRemove(DNSSDPrinters, p);
+  if (p->type & CUPS_PRINTER_CLASS)
+    snprintf(resource, sizeof(resource), "/classes/%s", p->name);
+  else
+    snprintf(resource, sizeof(resource), "/printers/%s", p->name);
 
- /*
-  * Optionally clear the service name...
-  */
+  if ((auth = cupsdFindBest(resource, HTTP_POST)) == NULL ||
+      auth->type == CUPSD_AUTH_NONE)
+    auth = cupsdFindPolicyOp(p->op_policy_ptr, IPP_PRINT_JOB);
 
-  if (clear_name)
-    cupsdClearString(&p->reg_name);
+  if (auth)
+  {
+    int	auth_type;			/* Authentication type */
+
+    if ((auth_type = auth->type) == CUPSD_AUTH_DEFAULT)
+      auth_type = cupsdDefaultAuthType();
+
+    switch (auth_type)
+    {
+      case CUPSD_AUTH_NONE :
+          return (NULL);
+
+      case CUPSD_AUTH_NEGOTIATE :
+	  strlcpy(buffer, "negotiate", bufsize);
+	  break;
+
+      default :
+	  strlcpy(buffer, "username,password", bufsize);
+	  break;
+    }
+
+    return (buffer);
+  }
+
+  return ("none");
 }
 
 
+#ifdef __APPLE__
 /*
- * 'dnssdErrorString()' - Return an error string for an error code.
+ * 'get_hostconfig()' - Get an /etc/hostconfig service setting.
  */
 
-static const char *			/* O - Error message */
-dnssdErrorString(int error)		/* I - Error number */
+static int				/* O - 1 for YES or AUTOMATIC, 0 for NO */
+get_hostconfig(const char *name)	/* I - Name of service */
 {
-#  ifdef HAVE_DNSSD
-  switch (error)
-  {
-    case kDNSServiceErr_NoError :
-        return ("OK.");
-
-    default :
-    case kDNSServiceErr_Unknown :
-        return ("Unknown error.");
+  cups_file_t	*fp;			/* Hostconfig file */
+  char		line[1024],		/* Line from file */
+		*ptr;			/* Pointer to value */
+  int		state = 1;		/* State of service */
 
-    case kDNSServiceErr_NoSuchName :
-        return ("Service not found.");
 
-    case kDNSServiceErr_NoMemory :
-        return ("Out of memory.");
+ /*
+  * Try opening the /etc/hostconfig file; if we can't open it, assume that
+  * the service is enabled/auto.
+  */
 
-    case kDNSServiceErr_BadParam :
-        return ("Bad parameter.");
+  if ((fp = cupsFileOpen("/etc/hostconfig", "r")) != NULL)
+  {
+   /*
+    * Read lines from the file until we find the service...
+    */
 
-    case kDNSServiceErr_BadReference :
-        return ("Bad service reference.");
+    while (cupsFileGets(fp, line, sizeof(line)))
+    {
+      if (line[0] == '#' || (ptr = strchr(line, '=')) == NULL)
+        continue;
 
-    case kDNSServiceErr_BadState :
-        return ("Bad state.");
+      *ptr++ = '\0';
 
-    case kDNSServiceErr_BadFlags :
-        return ("Bad flags.");
+      if (!_cups_strcasecmp(line, name))
+      {
+       /*
+        * Found the service, see if it is set to "-NO-"...
+	*/
 
-    case kDNSServiceErr_Unsupported :
-        return ("Unsupported.");
+	if (!_cups_strncasecmp(ptr, "-NO-", 4))
+	  state = 0;
+        break;
+      }
+    }
 
-    case kDNSServiceErr_NotInitialized :
-        return ("Not initialized.");
+    cupsFileClose(fp);
+  }
 
-    case kDNSServiceErr_AlreadyRegistered :
-        return ("Already registered.");
+  return (state);
+}
+#endif /* __APPLE__ */
 
-    case kDNSServiceErr_NameConflict :
-        return ("Name conflict.");
 
-    case kDNSServiceErr_Invalid :
-        return ("Invalid name.");
+/*
+ * 'is_local_queue()' - Determine whether the URI points at a local queue.
+ */
 
-    case kDNSServiceErr_Firewall :
-        return ("Firewall prevents registration.");
+static int				/* O - 1 = local, 0 = remote, -1 = bad URI */
+is_local_queue(const char *uri,		/* I - Printer URI */
+               char       *host,	/* O - Host string */
+	       int        hostlen,	/* I - Length of host buffer */
+               char       *resource,	/* O - Resource string */
+	       int        resourcelen)	/* I - Length of resource buffer */
+{
+  char		scheme[32],		/* Scheme portion of URI */
+		username[HTTP_MAX_URI];	/* Username portion of URI */
+  int		port;			/* Port portion of URI */
+  cupsd_netif_t	*iface;			/* Network interface */
 
-    case kDNSServiceErr_Incompatible :
-        return ("Client library incompatible.");
 
-    case kDNSServiceErr_BadInterfaceIndex :
-        return ("Bad interface index.");
+ /*
+  * Pull the URI apart to see if this is a local or remote printer...
+  */
 
-    case kDNSServiceErr_Refused :
-        return ("Server prevents registration.");
+  if (httpSeparateURI(HTTP_URI_CODING_ALL, uri, scheme, sizeof(scheme),
+                      username, sizeof(username), host, hostlen, &port,
+		      resource, resourcelen) < HTTP_URI_OK)
+    return (-1);
 
-    case kDNSServiceErr_NoSuchRecord :
-        return ("Record not found.");
+  DEBUG_printf(("host=\"%s\", ServerName=\"%s\"\n", host, ServerName));
 
-    case kDNSServiceErr_NoAuth :
-        return ("Authentication required.");
+ /*
+  * Check for local server addresses...
+  */
 
-    case kDNSServiceErr_NoSuchKey :
-        return ("Encryption key not found.");
+  if (!_cups_strcasecmp(host, ServerName) && port == LocalPort)
+    return (1);
 
-    case kDNSServiceErr_NATTraversal :
-        return ("Unable to traverse NAT boundary.");
+  cupsdNetIFUpdate();
 
-    case kDNSServiceErr_DoubleNAT :
-        return ("Unable to traverse double-NAT boundary.");
+  for (iface = (cupsd_netif_t *)cupsArrayFirst(NetIFList);
+       iface;
+       iface = (cupsd_netif_t *)cupsArrayNext(NetIFList))
+    if (!_cups_strcasecmp(host, iface->hostname) && port == iface->port)
+      return (1);
 
-    case kDNSServiceErr_BadTime :
-        return ("Bad system time.");
+ /*
+  * If we get here, the printer is remote...
+  */
 
-    case kDNSServiceErr_BadSig :
-        return ("Bad signature.");
+  return (0);
+}
 
-    case kDNSServiceErr_BadKey :
-        return ("Bad encryption key.");
 
-    case kDNSServiceErr_Transient :
-        return ("Transient error occurred - please try again.");
+/*
+ * 'process_browse_data()' - Process new browse data.
+ */
 
-    case kDNSServiceErr_ServiceNotRunning :
-        return ("Server not running.");
+static void
+process_browse_data(
+    const char    *uri,			/* I - URI of printer/class */
+    const char    *host,		/* I - Hostname */
+    const char    *resource,		/* I - Resource path */
+    cups_ptype_t  type,			/* I - Printer type */
+    ipp_pstate_t  state,		/* I - Printer state */
+    const char    *location,		/* I - Printer location */
+    const char    *info,		/* I - Printer information */
+    const char    *make_model,		/* I - Printer make and model */
+    int		  num_attrs,		/* I - Number of attributes */
+    cups_option_t *attrs)		/* I - Attributes */
+{
+  int		i;			/* Looping var */
+  int		update;			/* Update printer attributes? */
+  char		finaluri[HTTP_MAX_URI],	/* Final URI for printer */
+		name[IPP_MAX_NAME],	/* Name of printer */
+		newname[IPP_MAX_NAME],	/* New name of printer */
+		*hptr,			/* Pointer into hostname */
+		*sptr;			/* Pointer into ServerName */
+  const char	*shortname;		/* Short queue name (queue) */
+  char		local_make_model[IPP_MAX_NAME];
+					/* Local make and model */
+  cupsd_printer_t *p;			/* Printer information */
+  const char	*ipp_options,		/* ipp-options value */
+		*lease_duration,	/* lease-duration value */
+		*uuid;			/* uuid value */
+  int		is_class;		/* Is this queue a class? */
 
-    case kDNSServiceErr_NATPortMappingUnsupported :
-        return ("NAT doesn't support NAT-PMP or UPnP.");
 
-    case kDNSServiceErr_NATPortMappingDisabled :
-        return ("NAT supports NAT-PNP or UPnP but it is disabled.");
+  cupsdLogMessage(CUPSD_LOG_DEBUG2,
+                  "process_browse_data(uri=\"%s\", host=\"%s\", "
+		  "resource=\"%s\", type=%x, state=%d, location=\"%s\", "
+		  "info=\"%s\", make_model=\"%s\", num_attrs=%d, attrs=%p)",
+		  uri, host, resource, type, state,
+		  location ? location : "(nil)", info ? info : "(nil)",
+		  make_model ? make_model : "(nil)", num_attrs, attrs);
 
-    case kDNSServiceErr_NoRouter :
-        return ("No Internet/default router configured.");
+ /*
+  * Determine if the URI contains any illegal characters in it...
+  */
 
-    case kDNSServiceErr_PollingMode :
-        return ("Service polling mode error.");
+  if (strncmp(uri, "ipp://", 6) || !host[0] ||
+      (strncmp(resource, "/printers/", 10) &&
+       strncmp(resource, "/classes/", 9)))
+  {
+    cupsdLogMessage(CUPSD_LOG_ERROR, "Bad printer URI in browse data: %s", uri);
+    return;
+  }
 
-    case kDNSServiceErr_Timeout :
-        return ("Service timeout.");
+  if (strchr(resource, '?') ||
+      (!strncmp(resource, "/printers/", 10) && strchr(resource + 10, '/')) ||
+      (!strncmp(resource, "/classes/", 9) && strchr(resource + 9, '/')))
+  {
+    cupsdLogMessage(CUPSD_LOG_ERROR, "Bad resource in browse data: %s",
+                    resource);
+    return;
   }
 
-#  else /* HAVE_AVAHI */
-  return (avahi_strerror(error));
-#  endif /* HAVE_DNSSD */
-}
+ /*
+  * OK, this isn't a local printer; add any remote options...
+  */
 
+  ipp_options = cupsGetOption("ipp-options", num_attrs, attrs);
 
-/*
- * 'dnssdRegisterCallback()' - Free a TXT record.
- */
+  if (BrowseRemoteOptions)
+  {
+    if (BrowseRemoteOptions[0] == '?')
+    {
+     /*
+      * Override server-supplied options...
+      */
 
-static void
-dnssdFreeTxtRecord(cupsd_txt_t *txt)	/* I - TXT record */
-{
-#  ifdef HAVE_DNSSD
-  TXTRecordDeallocate(txt);
+      snprintf(finaluri, sizeof(finaluri), "%s%s", uri, BrowseRemoteOptions);
+    }
+    else if (ipp_options)
+    {
+     /*
+      * Combine the server and local options...
+      */
 
-#  else /* HAVE_AVAHI */
-  avahi_string_list_free(*txt);
-  *txt = NULL;
-#  endif /* HAVE_DNSSD */
-}
+      snprintf(finaluri, sizeof(finaluri), "%s?%s+%s", uri, ipp_options,
+               BrowseRemoteOptions);
+    }
+    else
+    {
+     /*
+      * Just use the local options...
+      */
 
+      snprintf(finaluri, sizeof(finaluri), "%s?%s", uri, BrowseRemoteOptions);
+    }
 
-/*
- * 'dnssdRegisterCallback()' - DNSServiceRegister callback.
- */
+    uri = finaluri;
+  }
+  else if (ipp_options)
+  {
+   /*
+    * Just use the server-supplied options...
+    */
 
-#  ifdef HAVE_DNSSD
-static void
-dnssdRegisterCallback(
-    DNSServiceRef	sdRef,		/* I - DNS Service reference */
-    DNSServiceFlags	flags,		/* I - Reserved for future use */
-    DNSServiceErrorType	errorCode,	/* I - Error code */
-    const char		*name,     	/* I - Service name */
-    const char		*regtype,  	/* I - Service type */
-    const char		*domain,   	/* I - Domain. ".local" for now */
-    void		*context)	/* I - Printer */
-{
-  cupsd_printer_t *p = (cupsd_printer_t *)context;
-					/* Current printer */
+    snprintf(finaluri, sizeof(finaluri), "%s?%s", uri, ipp_options);
+    uri = finaluri;
+  }
 
+ /*
+  * See if we already have it listed in the Printers list, and add it if not...
+  */
 
-  (void)sdRef;
-  (void)flags;
-  (void)domain;
+  type     |= CUPS_PRINTER_REMOTE | CUPS_PRINTER_DISCOVERED;
+  type     &= ~CUPS_PRINTER_IMPLICIT;
+  update   = 0;
+  hptr     = strchr(host, '.');
+  sptr     = strchr(ServerName, '.');
+  is_class = type & CUPS_PRINTER_CLASS;
+  uuid     = cupsGetOption("uuid", num_attrs, attrs);
 
-  cupsdLogMessage(CUPSD_LOG_DEBUG2, "dnssdRegisterCallback(%s, %s) for %s (%s)",
-                  name, regtype, p ? p->name : "Web Interface",
-		  p ? (p->reg_name ? p->reg_name : "(null)") : "NA");
+  if (!ServerNameIsIP && sptr != NULL && hptr != NULL)
+  {
+   /*
+    * Strip the common domain name components...
+    */
 
-  if (errorCode)
+    while (hptr != NULL)
+    {
+      if (!_cups_strcasecmp(hptr, sptr))
+      {
+        *hptr = '\0';
+	break;
+      }
+      else
+        hptr = strchr(hptr + 1, '.');
+    }
+  }
+
+  if (is_class)
   {
-    cupsdLogMessage(CUPSD_LOG_ERROR,
-		    "DNSServiceRegister failed with error %d", (int)errorCode);
-    return;
+   /*
+    * Remote destination is a class...
+    */
+
+    if (!strncmp(resource, "/classes/", 9))
+      snprintf(name, sizeof(name), "%s@%s", resource + 9, host);
+    else
+      return;
+
+    shortname = resource + 9;
   }
-  else if (p && (!p->reg_name || _cups_strcasecmp(name, p->reg_name)))
+  else
   {
-    cupsdLogMessage(CUPSD_LOG_INFO, "Using service name \"%s\" for \"%s\"",
-                    name, p->name);
+   /*
+    * Remote destination is a printer...
+    */
 
-    cupsArrayRemove(DNSSDPrinters, p);
-    cupsdSetString(&p->reg_name, name);
-    cupsArrayAdd(DNSSDPrinters, p);
+    if (!strncmp(resource, "/printers/", 10))
+      snprintf(name, sizeof(name), "%s@%s", resource + 10, host);
+    else
+      return;
 
-    LastEvent |= CUPSD_EVENT_PRINTER_MODIFIED;
+    shortname = resource + 10;
   }
-}
 
-#  else /* HAVE_AVAHI */
-static void
-dnssdRegisterCallback(
-    AvahiEntryGroup      *srv,		/* I - Service */
-    AvahiEntryGroupState state,		/* I - Registration state */
-    void                 *context)	/* I - Printer */
-{
-  cupsd_printer_t *p = (cupsd_printer_t *)context;
-					/* Current printer */
+  if (hptr && !*hptr)
+    *hptr = '.';			/* Resource FQDN */
 
-  cupsdLogMessage(CUPSD_LOG_DEBUG2,
-                  "dnssdRegisterCallback(srv=%p, state=%d, context=%p) "
-                  "for %s (%s)", srv, state, context,
-                  p ? p->name : "Web Interface",
-		  p ? (p->reg_name ? p->reg_name : "(null)") : "NA");
+  if ((p = cupsdFindDest(name)) == NULL && BrowseShortNames)
+  {
+   /*
+    * Long name doesn't exist, try short name...
+    */
 
-  /* TODO: Handle collisions with avahi_alternate_service_name(p->reg_name)? */
-}
-#  endif /* HAVE_DNSSD */
+    cupsdLogMessage(CUPSD_LOG_DEBUG, "process_browse_data: %s not found...",
+                    name);
 
+    if ((p = cupsdFindDest(shortname)) == NULL)
+    {
+     /*
+      * Short name doesn't exist, use it for this shared queue.
+      */
 
-/*
- * 'dnssdRegisterInstance()' - Register an instance of a printer service.
- */
+      cupsdLogMessage(CUPSD_LOG_DEBUG2, "process_browse_data: %s not found...",
+		      shortname);
+      strlcpy(name, shortname, sizeof(name));
+    }
+    else
+    {
+     /*
+      * Short name exists...
+      */
 
-static int				/* O - 1 on success, 0 on failure */
-dnssdRegisterInstance(
-    cupsd_srv_t     *srv,		/* O - Service */
-    cupsd_printer_t *p,			/* I - Printer */
-    char            *name,		/* I - DNS-SD service name */
-    const char      *type,		/* I - DNS-SD service type */
-    const char      *subtypes,		/* I - Subtypes to register or NULL */
-    int             port,		/* I - Port number or 0 */
-    cupsd_txt_t     *txt,		/* I - TXT record */
-    int             commit)		/* I - Commit registration? */
-{
-  char	temp[256],			/* Temporary string */
-	*ptr;				/* Pointer into string */
-  int	error;				/* Any error */
+      cupsdLogMessage(CUPSD_LOG_DEBUG2,
+                      "process_browse_data: %s found, type=%x, hostname=%s...",
+		      shortname, p->type, p->hostname ? p->hostname : "(nil)");
+
+      if (p->type & CUPS_PRINTER_IMPLICIT)
+        p = NULL;			/* Don't replace implicit classes */
+      else if (p->hostname && _cups_strcasecmp(p->hostname, host))
+      {
+       /*
+	* Short name exists but is for a different host.  If this is a remote
+	* queue, rename it and use the long name...
+	*/
 
+	if (p->type & CUPS_PRINTER_REMOTE)
+	{
+	  cupsdLogMessage(CUPSD_LOG_DEBUG,
+			  "Renamed remote %s \"%s\" to \"%s@%s\"...",
+			  is_class ? "class" : "printer", p->name, p->name,
+			  p->hostname);
+	  cupsdAddEvent(CUPSD_EVENT_PRINTER_DELETED, p, NULL,
+			"%s \'%s\' deleted by directory services.",
+			is_class ? "Class" : "Printer", p->name);
+
+	  snprintf(newname, sizeof(newname), "%s@%s", p->name, p->hostname);
+	  cupsdRenamePrinter(p, newname);
+
+	  cupsdAddEvent(CUPSD_EVENT_PRINTER_ADDED, p, NULL,
+			"%s \'%s\' added by directory services.",
+			is_class ? "Class" : "Printer", p->name);
+	}
 
-  cupsdLogMessage(CUPSD_LOG_DEBUG,
-		  "Registering \"%s\" with DNS-SD type \"%s\".", name, type);
+       /*
+        * Force creation with long name...
+	*/
 
-  if (p && !srv)
+	p = NULL;
+      }
+    }
+  }
+  else if (p)
+    cupsdLogMessage(CUPSD_LOG_DEBUG2,
+		    "process_browse_data: %s found, type=%x, hostname=%s...",
+		    name, p->type, p->hostname ? p->hostname : "(nil)");
+
+  if (!p)
   {
    /*
-    * Assign the correct pointer for "srv"...
+    * Queue doesn't exist; add it...
     */
 
-#  ifdef HAVE_DNSSD
-    if (!strcmp(type, "_printer._tcp"))
-      srv = &p->printer_srv;		/* Target LPD service */
-#    ifdef HAVE_SSL
-    else if (!strcmp(type, "_ipps._tcp"))
-      srv = &p->ipps_srv;		/* Target IPPS service */
-#    endif /* HAVE_SSL */
+    if (is_class)
+      p = cupsdAddClass(name);
     else
-      srv = &p->ipp_srv;		/* Target IPP service */
+      p = cupsdAddPrinter(name);
 
-#  else /* HAVE_AVAHI */
-    srv = &p->ipp_srv;			/* Target service group */
-#  endif /* HAVE_DNSSD */
-  }
+    if (!p)
+      return;
 
-#  ifdef HAVE_DNSSD
-  (void)commit;
+    cupsdClearString(&(p->hostname));
 
-#  else /* HAVE_AVAHI */
-  avahi_threaded_poll_lock(DNSSDMaster);
+    cupsdLogMessage(CUPSD_LOG_DEBUG, "Added remote %s \"%s\"...",
+                    is_class ? "class" : "printer", name);
 
-  if (!*srv)
-    *srv = avahi_entry_group_new(DNSSDClient, dnssdRegisterCallback, NULL);
-  if (!*srv)
+    cupsdAddEvent(CUPSD_EVENT_PRINTER_ADDED, p, NULL,
+		  "%s \'%s\' added by directory services.",
+		  is_class ? "Class" : "Printer", name);
+
+   /*
+    * Force the URI to point to the real server...
+    */
+
+    p->type      = type & ~CUPS_PRINTER_REJECTING;
+    p->accepting = 1;
+
+    cupsdMarkDirty(CUPSD_DIRTY_PRINTCAP);
+  }
+
+  if (!p->hostname)
   {
-    avahi_threaded_poll_unlock(DNSSDMaster);
+   /*
+    * Hostname not set, so this must be a cached remote printer
+    * that was created for a pending print job...
+    */
 
-    cupsdLogMessage(CUPSD_LOG_WARN, "DNS-SD registration of \"%s\" failed: %s",
-                    name, dnssdErrorString(avahi_client_errno(DNSSDClient)));
-    return (0);
+    cupsdSetString(&p->hostname, host);
+    cupsdSetString(&p->uri, uri);
+    cupsdSetString(&p->device_uri, uri);
+    update = 1;
+
+    cupsdMarkDirty(CUPSD_DIRTY_REMOTE);
   }
-#  endif /* HAVE_DNSSD */
 
  /*
-  * Make sure the name is <= 63 octets, and when we truncate be sure to
-  * properly truncate any UTF-8 characters...
+  * Update the state...
   */
 
-  ptr = name + strlen(name);
-  while ((ptr - name) > 63)
+  p->state       = state;
+  p->browse_time = time(NULL);
+
+  if ((lease_duration = cupsGetOption("lease-duration", num_attrs,
+                                      attrs)) != NULL)
   {
-    do
-    {
-      ptr --;
-    }
-    while (ptr > name && (*ptr & 0xc0) == 0x80);
+   /*
+    * Grab the lease-duration for the browse data; anything less then 1
+    * second or more than 1 week gets the default BrowseTimeout...
+    */
 
-    if (ptr > name)
-      *ptr = '\0';
+    i = atoi(lease_duration);
+    if (i < 1 || i > 604800)
+      i = BrowseTimeout;
+
+    p->browse_expire = p->browse_time + i;
   }
+  else
+    p->browse_expire = p->browse_time + BrowseTimeout;
 
- /*
-  * Register the service...
-  */
+  if (type & CUPS_PRINTER_REJECTING)
+  {
+    type &= ~CUPS_PRINTER_REJECTING;
 
-#  ifdef HAVE_DNSSD
-  if (subtypes)
-    snprintf(temp, sizeof(temp), "%s,%s", type, subtypes);
-  else
-    strlcpy(temp, type, sizeof(temp));
+    if (p->accepting)
+    {
+      update       = 1;
+      p->accepting = 0;
+    }
+  }
+  else if (!p->accepting)
+  {
+    update       = 1;
+    p->accepting = 1;
+  }
 
-  *srv  = DNSSDMaster;
-  error = DNSServiceRegister(srv, kDNSServiceFlagsShareConnection,
-			     0, name, temp, NULL, NULL, htons(port),
-			     txt ? TXTRecordGetLength(txt) : 0,
-			     txt ? TXTRecordGetBytesPtr(txt) : NULL,
-			     dnssdRegisterCallback, p);
+  if (p->type != type)
+  {
+    p->type = type;
+    update  = 1;
+  }
 
-#  else /* HAVE_AVAHI */
-  if (txt)
+  if (uuid && strcmp(p->uuid, uuid))
   {
-    AvahiStringList *temptxt;
-    for (temptxt = *txt; temptxt; temptxt = temptxt->next)
-      cupsdLogMessage(CUPSD_LOG_DEBUG, "DNS_SD \"%s\" %s", name, temptxt->text);
+    cupsdSetString(&p->uuid, uuid);
+    update = 1;
   }
 
-  error = avahi_entry_group_add_service_strlst(*srv, AVAHI_IF_UNSPEC,
-                                               AVAHI_PROTO_UNSPEC, 0, name,
-                                               type, NULL, NULL, port,
-                                               txt ? *txt : NULL);
-  if (error)
-    cupsdLogMessage(CUPSD_LOG_DEBUG, "DNS-SD service add for \"%s\" failed.",
-                    name);
+  if (location && (!p->location || strcmp(p->location, location)))
+  {
+    cupsdSetString(&p->location, location);
+    update = 1;
+  }
 
-  if (!error && subtypes)
+  if (info && (!p->info || strcmp(p->info, info)))
   {
-   /*
-    * Register all of the subtypes...
-    */
+    cupsdSetString(&p->info, info);
+    update = 1;
 
-    char	*start,			/* Start of subtype */
-		subtype[256];		/* Subtype string */
+    cupsdMarkDirty(CUPSD_DIRTY_PRINTCAP | CUPSD_DIRTY_REMOTE);
+  }
 
-    strlcpy(temp, subtypes, sizeof(temp));
+  if (!make_model || !make_model[0])
+  {
+    if (is_class)
+      snprintf(local_make_model, sizeof(local_make_model),
+               "Remote Class on %s", host);
+    else
+      snprintf(local_make_model, sizeof(local_make_model),
+               "Remote Printer on %s", host);
+  }
+  else
+    snprintf(local_make_model, sizeof(local_make_model),
+             "%s on %s", make_model, host);
 
-    for (start = temp; *start; start = ptr)
+  if (!p->make_model || strcmp(p->make_model, local_make_model))
+  {
+    cupsdSetString(&p->make_model, local_make_model);
+    update = 1;
+  }
+
+  if (p->num_options)
+  {
+    if (!update && !(type & CUPS_PRINTER_DELETE))
     {
      /*
-      * Skip leading whitespace...
+      * See if we need to update the attributes...
       */
 
-      while (*start && isspace(*start & 255))
-        start ++;
-
-     /*
-      * Grab everything up to the next comma or the end of the string...
-      */
+      if (p->num_options != num_attrs)
+	update = 1;
+      else
+      {
+	for (i = 0; i < num_attrs; i ++)
+          if (strcmp(attrs[i].name, p->options[i].name) ||
+	      (!attrs[i].value != !p->options[i].value) ||
+	      (attrs[i].value && strcmp(attrs[i].value, p->options[i].value)))
+          {
+	    update = 1;
+	    break;
+          }
+      }
+    }
 
-      for (ptr = start; *ptr && *ptr != ','; ptr ++);
+   /*
+    * Free the old options...
+    */
 
-      if (*ptr)
-        *ptr++ = '\0';
+    cupsFreeOptions(p->num_options, p->options);
+  }
 
-      if (!*start)
-        break;
+  p->num_options = num_attrs;
+  p->options     = attrs;
 
-     /*
-      * Register the subtype...
-      */
+  if (type & CUPS_PRINTER_DELETE)
+  {
+    cupsdAddEvent(CUPSD_EVENT_PRINTER_DELETED, p, NULL,
+                  "%s \'%s\' deleted by directory services.",
+		  is_class ? "Class" : "Printer", p->name);
 
-      snprintf(subtype, sizeof(subtype), "%s._sub.%s", start, type);
+    cupsdExpireSubscriptions(p, NULL);
 
-      error = avahi_entry_group_add_service_subtype(*srv, AVAHI_IF_UNSPEC,
-                                                    AVAHI_PROTO_UNSPEC, 0,
-                                                    name, type, NULL, subtype);
-      if (error)
-      {
-        cupsdLogMessage(CUPSD_LOG_DEBUG,
-                        "DNS-SD subtype %s registration for \"%s\" failed." ,
-                        subtype, name);
-        break;
-      }
-    }
+    cupsdDeletePrinter(p, 1);
+    cupsdUpdateImplicitClasses();
+    cupsdMarkDirty(CUPSD_DIRTY_PRINTCAP | CUPSD_DIRTY_REMOTE);
   }
-
-  if (!error && commit)
+  else if (update)
   {
-    if ((error = avahi_entry_group_commit(*srv)) != 0)
-      cupsdLogMessage(CUPSD_LOG_DEBUG, "DNS-SD commit of \"%s\" failed.",
-                      name);
+    cupsdSetPrinterAttrs(p);
+    cupsdUpdateImplicitClasses();
   }
 
-  avahi_threaded_poll_unlock(DNSSDMaster);
-#  endif /* HAVE_DNSSD */
+ /*
+  * See if we have a default printer...  If not, make the first network
+  * default printer the default.
+  */
 
-  if (error)
+  if (DefaultPrinter == NULL && Printers != NULL && UseNetworkDefault)
   {
-    cupsdLogMessage(CUPSD_LOG_WARN, "DNS-SD registration of \"%s\" failed: %s",
-                    name, dnssdErrorString(error));
-    cupsdLogMessage(CUPSD_LOG_DEBUG, "DNS-SD type: %s", type);
-    if (subtypes)
-      cupsdLogMessage(CUPSD_LOG_DEBUG, "DNS-SD sub-types: %s", subtypes);
+   /*
+    * Find the first network default printer and use it...
+    */
+
+    for (p = (cupsd_printer_t *)cupsArrayFirst(Printers);
+         p;
+	 p = (cupsd_printer_t *)cupsArrayNext(Printers))
+      if (p->type & CUPS_PRINTER_DEFAULT)
+      {
+        DefaultPrinter = p;
+        cupsdMarkDirty(CUPSD_DIRTY_PRINTCAP | CUPSD_DIRTY_REMOTE);
+	break;
+      }
   }
 
-  return (!error);
+ /*
+  * Do auto-classing if needed...
+  */
+
+  process_implicit_classes();
 }
 
 
 /*
- * 'dnssdRegisterPrinter()' - Start sending broadcast information for a printer
- *		              or update the broadcast contents.
+ * 'process_implicit_classes()' - Create/update implicit classes as needed.
  */
 
 static void
-dnssdRegisterPrinter(cupsd_printer_t *p)/* I - Printer */
+process_implicit_classes(void)
 {
-  char		name[256];		/* Service name */
-  int		printer_port;		/* LPD port number */
-  int		status;			/* Registration status */
-  cupsd_txt_t	ipp_txt,		/* IPP(S) TXT record */
- 		printer_txt;		/* LPD TXT record */
-
-  cupsdLogMessage(CUPSD_LOG_DEBUG2, "dnssdRegisterPrinter(%s) %s", p->name,
-                  !p->ipp_srv ? "new" : "update");
-
- /*
-  * Remove the current registrations if we have them and then return if
-  * per-printer sharing was just disabled...
-  */
+  int		i;			/* Looping var */
+  int		update;			/* Update printer attributes? */
+  char		name[IPP_MAX_NAME],	/* Name of printer */
+		*hptr;			/* Pointer into hostname */
+  cupsd_printer_t *p,			/* Printer information */
+		*pclass,		/* Printer class */
+		*first;			/* First printer in class */
+  int		offset,			/* Offset of name */
+		len;			/* Length of name */
 
-  dnssdDeregisterPrinter(p, 0);
 
-  if (!p->shared)
+  if (!ImplicitClasses || !Printers)
     return;
 
  /*
-  * Set the registered name as needed; the registered name takes the form of
-  * "<printer-info> @ <computer name>"...
+  * Loop through all available printers and create classes as needed...
   */
 
-  if (!p->reg_name)
+  for (p = (cupsd_printer_t *)cupsArrayFirst(Printers), len = 0, offset = 0,
+           update = 0, pclass = NULL, first = NULL;
+       p != NULL;
+       p = (cupsd_printer_t *)cupsArrayNext(Printers))
   {
-    if (p->info && strlen(p->info) > 0)
+   /*
+    * Skip implicit classes...
+    */
+
+    if (p->type & CUPS_PRINTER_IMPLICIT)
     {
-      if (DNSSDComputerName)
-	snprintf(name, sizeof(name), "%s @ %s", p->info, DNSSDComputerName);
-      else
-	strlcpy(name, p->info, sizeof(name));
+      len = 0;
+      continue;
     }
-    else if (DNSSDComputerName)
-      snprintf(name, sizeof(name), "%s @ %s", p->name, DNSSDComputerName);
-    else
-      strlcpy(name, p->name, sizeof(name));
-  }
-  else
-    strlcpy(name, p->reg_name, sizeof(name));
 
- /*
-  * Register IPP and LPD...
-  *
-  * We always must register the "_printer" service type in order to reserve
-  * our name, but use port number 0 if we haven't actually configured cups-lpd
-  * to share via LPD...
-  */
+   /*
+    * If len == 0, get the length of this printer name up to the "@"
+    * sign (if any).
+    */
 
-  ipp_txt     = dnssdBuildTxtRecord(p, 0);
-  printer_txt = dnssdBuildTxtRecord(p, 1);
+    cupsArraySave(Printers);
 
-  if (BrowseLocalProtocols & BROWSE_LPD)
-    printer_port = 515;
-  else
-    printer_port = 0;
+    if (len > 0 &&
+	!_cups_strncasecmp(p->name, name + offset, len) &&
+	(p->name[len] == '\0' || p->name[len] == '@'))
+    {
+     /*
+      * We have more than one printer with the same name; see if
+      * we have a class, and if this printer is a member...
+      */
 
-  status = dnssdRegisterInstance(NULL, p, name, "_printer._tcp", NULL,
-                                 printer_port, &printer_txt, 0);
+      if (pclass && _cups_strcasecmp(pclass->name, name))
+      {
+	if (update)
+	  cupsdSetPrinterAttrs(pclass);
 
-#  ifdef HAVE_SSL
-  if (status)
-    dnssdRegisterInstance(NULL, p, name, "_ipps._tcp", DNSSDSubTypes,
-			  DNSSDPort, &ipp_txt, 0);
-#  endif /* HAVE_SSL */
+	update = 0;
+	pclass = NULL;
+      }
 
-  if (status)
-  {
-   /*
-    * Use the "_fax-ipp" service type for fax queues, otherwise use "_ipp"...
-    */
+      if (!pclass && (pclass = cupsdFindDest(name)) == NULL)
+      {
+       /*
+	* Need to add the class...
+	*/
 
-    if (p->type & CUPS_PRINTER_FAX)
-      status = dnssdRegisterInstance(NULL, p, name, "_fax-ipp._tcp",
-                                     DNSSDSubTypes, DNSSDPort, &ipp_txt, 1);
+	pclass = cupsdAddPrinter(name);
+	cupsArrayAdd(ImplicitPrinters, pclass);
+
+	pclass->type      |= CUPS_PRINTER_IMPLICIT;
+	pclass->accepting = 1;
+	pclass->state     = IPP_PRINTER_IDLE;
+
+        cupsdSetString(&pclass->location, p->location);
+        cupsdSetString(&pclass->info, p->info);
+
+        cupsdSetString(&pclass->job_sheets[0], p->job_sheets[0]);
+        cupsdSetString(&pclass->job_sheets[1], p->job_sheets[1]);
+
+        update = 1;
+
+	cupsdMarkDirty(CUPSD_DIRTY_PRINTCAP | CUPSD_DIRTY_REMOTE);
+
+        cupsdLogMessage(CUPSD_LOG_DEBUG, "Added implicit class \"%s\"...",
+	                name);
+	cupsdAddEvent(CUPSD_EVENT_PRINTER_ADDED, p, NULL,
+                      "Implicit class \'%s\' added by directory services.",
+		      name);
+      }
+
+      if (first != NULL)
+      {
+        for (i = 0; i < pclass->num_printers; i ++)
+	  if (pclass->printers[i] == first)
+	    break;
+
+        if (i >= pclass->num_printers)
+	{
+	  first->in_implicit_class = 1;
+	  cupsdAddPrinterToClass(pclass, first);
+        }
+
+	first = NULL;
+      }
+
+      for (i = 0; i < pclass->num_printers; i ++)
+	if (pclass->printers[i] == p)
+	  break;
+
+      if (i >= pclass->num_printers)
+      {
+	p->in_implicit_class = 1;
+	cupsdAddPrinterToClass(pclass, p);
+	update = 1;
+      }
+    }
     else
-      status = dnssdRegisterInstance(NULL, p, name, "_ipp._tcp", DNSSDSubTypes,
-                                     DNSSDPort, &ipp_txt, 1);
-  }
+    {
+     /*
+      * First time around; just get name length and mark it as first
+      * in the list...
+      */
 
-  dnssdFreeTxtRecord(&ipp_txt);
-  dnssdFreeTxtRecord(&printer_txt);
+      if ((hptr = strchr(p->name, '@')) != NULL)
+	len = hptr - p->name;
+      else
+	len = strlen(p->name);
 
-  if (status)
-  {
-   /*
-    * Save the registered name and add the printer to the array of DNS-SD
-    * printers...
-    */
+      if (len >= sizeof(name))
+      {
+       /*
+	* If the printer name length somehow is greater than we normally allow,
+	* skip this printer...
+	*/
+
+	len = 0;
+	cupsArrayRestore(Printers);
+	continue;
+      }
+
+      strncpy(name, p->name, len);
+      name[len] = '\0';
+      offset    = 0;
+
+      if ((first = (hptr ? cupsdFindDest(name) : p)) != NULL &&
+	  !(first->type & CUPS_PRINTER_IMPLICIT))
+      {
+       /*
+	* Can't use same name as a local printer; add "Any" to the
+	* front of the name, unless we have explicitly disabled
+	* the "ImplicitAnyClasses"...
+	*/
 
-    cupsdSetString(&p->reg_name, name);
-    cupsArrayAdd(DNSSDPrinters, p);
-  }
-  else
-  {
-   /*
-    * Registration failed for this printer...
-    */
+        if (ImplicitAnyClasses && len < (sizeof(name) - 4))
+	{
+	 /*
+	  * Add "Any" to the class name...
+	  */
+
+          strcpy(name, "Any");
+          strncpy(name + 3, p->name, len);
+	  name[len + 3] = '\0';
+	  offset        = 3;
+	}
+	else
+	{
+	 /*
+	  * Don't create an implicit class if we have a local printer
+	  * with the same name...
+	  */
+
+	  len = 0;
+          cupsArrayRestore(Printers);
+	  continue;
+	}
+      }
 
-    dnssdDeregisterInstance(&p->ipp_srv);
+      first = p;
+    }
 
-#  ifdef HAVE_DNSSD
-#    ifdef HAVE_SSL
-    dnssdDeregisterInstance(&p->ipps_srv);
-#    endif /* HAVE_SSL */
-    dnssdDeregisterInstance(&p->printer_srv);
-#  endif /* HAVE_DNSSD */
+    cupsArrayRestore(Printers);
   }
+
+ /*
+  * Update the last printer class as needed...
+  */
+
+  if (pclass && update)
+    cupsdSetPrinterAttrs(pclass);
 }
 
 
 /*
- * 'dnssdStop()' - Stop all DNS-SD registrations.
+ * 'send_cups_browse()' - Send new browsing information using the CUPS
+ *                        protocol.
  */
 
 static void
-dnssdStop(void)
+send_cups_browse(cupsd_printer_t *p)	/* I - Printer to send */
 {
-  cupsd_printer_t	*p;		/* Current printer */
+  int			i;		/* Looping var */
+  cups_ptype_t		type;		/* Printer type */
+  cupsd_dirsvc_addr_t	*b;		/* Browse address */
+  int			bytes;		/* Length of packet */
+  char			packet[1453],	/* Browse data packet */
+			uri[1024],	/* Printer URI */
+			location[1024],	/* printer-location */
+			info[1024],	/* printer-info */
+			make_model[1024],
+					/* printer-make-and-model */
+			air[1024];	/* auth-info-required */
+  cupsd_netif_t		*iface;		/* Network interface */
 
 
  /*
-  * De-register the individual printers
+  * Figure out the printer type value...
   */
 
-  for (p = (cupsd_printer_t *)cupsArrayFirst(Printers);
-       p;
-       p = (cupsd_printer_t *)cupsArrayNext(Printers))
-    dnssdDeregisterPrinter(p, 1);
+  type = p->type | CUPS_PRINTER_REMOTE;
+
+  if (!p->accepting)
+    type |= CUPS_PRINTER_REJECTING;
+
+  if (p == DefaultPrinter)
+    type |= CUPS_PRINTER_DEFAULT;
 
  /*
-  * Shutdown the rest of the service refs...
+  * Remove quotes from printer-info, printer-location, and
+  * printer-make-and-model attributes...
   */
 
-  dnssdDeregisterInstance(&WebIFSrv);
+  dequote(location, p->location, sizeof(location));
+  dequote(info, p->info, sizeof(info));
 
-#  ifdef HAVE_DNSSD
-  cupsdRemoveSelect(DNSServiceRefSockFD(DNSSDMaster));
+  if (p->make_model)
+    dequote(make_model, p->make_model, sizeof(make_model));
+  else if (p->type & CUPS_PRINTER_CLASS)
+  {
+    if (p->num_printers > 0 && p->printers[0]->make_model)
+      strlcpy(make_model, p->printers[0]->make_model, sizeof(make_model));
+    else
+      strlcpy(make_model, "Local Printer Class", sizeof(make_model));
+  }
+  else if (p->raw)
+    strlcpy(make_model, "Local Raw Printer", sizeof(make_model));
+  else
+    strlcpy(make_model, "Local System V Printer", sizeof(make_model));
 
-  DNSServiceRefDeallocate(DNSSDMaster);
-  DNSSDMaster = NULL;
+  if (get_auth_info_required(p, packet, sizeof(packet)))
+    snprintf(air, sizeof(air), " auth-info-required=%s", packet);
+  else
+    air[0] = '\0';
 
-#  else /* HAVE_AVAHI */
-  avahi_client_free(DNSSDClient);
-  DNSSDClient = NULL;
+ /*
+  * Send a packet to each browse address...
+  */
 
-  avahi_threaded_poll_free(DNSSDMaster);
-  DNSSDMaster = NULL;
-#  endif /* HAVE_DNSSD */
+  for (i = NumBrowsers, b = Browsers; i > 0; i --, b ++)
+    if (b->iface[0])
+    {
+     /*
+      * Send the browse packet to one or more interfaces...
+      */
 
-  cupsArrayDelete(DNSSDPrinters);
-  DNSSDPrinters = NULL;
+      if (!strcmp(b->iface, "*"))
+      {
+       /*
+        * Send to all local interfaces...
+	*/
 
-  DNSSDPort = 0;
-}
+        cupsdNetIFUpdate();
+
+	for (iface = (cupsd_netif_t *)cupsArrayFirst(NetIFList);
+	     iface;
+	     iface = (cupsd_netif_t *)cupsArrayNext(NetIFList))
+	{
+	 /*
+	  * Only send to local, IPv4 interfaces...
+	  */
+
+	  if (!iface->is_local || !iface->port ||
+	      iface->address.addr.sa_family != AF_INET)
+	    continue;
+
+	  httpAssembleURIf(HTTP_URI_CODING_ALL, uri, sizeof(uri), "ipp", NULL,
+	                   iface->hostname, iface->port,
+			   (p->type & CUPS_PRINTER_CLASS) ? "/classes/%s" :
+			                                    "/printers/%s",
+			   p->name);
+	  snprintf(packet, sizeof(packet),
+	           "%x %x %s \"%s\" \"%s\" \"%s\" %s%s uuid=%s\n",
+        	   type, p->state, uri, location, info, make_model,
+		   p->browse_attrs ? p->browse_attrs : "", air, p->uuid);
+
+	  bytes = strlen(packet);
+
+	  cupsdLogMessage(CUPSD_LOG_DEBUG2,
+	                  "cupsdSendBrowseList: (%d bytes to \"%s\") %s", bytes,
+        	          iface->name, packet);
+
+          iface->broadcast.ipv4.sin_port = htons(BrowsePort);
+
+	  sendto(BrowseSocket, packet, bytes, 0,
+		 (struct sockaddr *)&(iface->broadcast),
+		 httpAddrLength(&(iface->broadcast)));
+        }
+      }
+      else if ((iface = cupsdNetIFFind(b->iface)) != NULL)
+      {
+       /*
+        * Send to the named interface using the IPv4 address...
+	*/
 
+        while (iface)
+	  if (strcmp(b->iface, iface->name))
+	  {
+	    iface = NULL;
+	    break;
+	  }
+	  else if (iface->address.addr.sa_family == AF_INET && iface->port)
+	    break;
+	  else
+            iface = (cupsd_netif_t *)cupsArrayNext(NetIFList);
+
+        if (iface)
+	{
+	  httpAssembleURIf(HTTP_URI_CODING_ALL, uri, sizeof(uri), "ipp", NULL,
+	                   iface->hostname, iface->port,
+			   (p->type & CUPS_PRINTER_CLASS) ? "/classes/%s" :
+			                                    "/printers/%s",
+			   p->name);
+	  snprintf(packet, sizeof(packet),
+	           "%x %x %s \"%s\" \"%s\" \"%s\" %s%s uuid=%s\n",
+        	   type, p->state, uri, location, info, make_model,
+		   p->browse_attrs ? p->browse_attrs : "", air, p->uuid);
+
+	  bytes = strlen(packet);
+
+	  cupsdLogMessage(CUPSD_LOG_DEBUG2,
+	                  "cupsdSendBrowseList: (%d bytes to \"%s\") %s", bytes,
+        	          iface->name, packet);
+
+          iface->broadcast.ipv4.sin_port = htons(BrowsePort);
+
+	  sendto(BrowseSocket, packet, bytes, 0,
+		 (struct sockaddr *)&(iface->broadcast),
+		 httpAddrLength(&(iface->broadcast)));
+        }
+      }
+    }
+    else
+    {
+     /*
+      * Send the browse packet to the indicated address using
+      * the default server name...
+      */
 
-#  ifdef HAVE_DNSSD
-/*
- * 'dnssdUpdate()' - Handle DNS-SD queries.
- */
+      snprintf(packet, sizeof(packet),
+               "%x %x %s \"%s\" \"%s\" \"%s\" %s%s uuid=%s\n",
+       	       type, p->state, p->uri, location, info, make_model,
+	       p->browse_attrs ? p->browse_attrs : "", air, p->uuid);
+
+      bytes = strlen(packet);
+      cupsdLogMessage(CUPSD_LOG_DEBUG2,
+                      "cupsdSendBrowseList: (%d bytes) %s", bytes, packet);
+
+      if (sendto(BrowseSocket, packet, bytes, 0,
+		 (struct sockaddr *)&(b->to),
+		 httpAddrLength(&(b->to))) <= 0)
+      {
+       /*
+        * Unable to send browse packet, so remove this address from the
+	* list...
+	*/
 
-static void
-dnssdUpdate(void)
-{
-  DNSServiceErrorType	sdErr;		/* Service discovery error */
+	cupsdLogMessage(CUPSD_LOG_ERROR,
+	                "cupsdSendBrowseList: sendto failed for browser "
+			"%d - %s.",
+	                (int)(b - Browsers + 1), strerror(errno));
 
+        if (i > 1)
+	  memmove(b, b + 1, (i - 1) * sizeof(cupsd_dirsvc_addr_t));
 
-  if ((sdErr = DNSServiceProcessResult(DNSSDMaster)) != kDNSServiceErr_NoError)
-  {
-    cupsdLogMessage(CUPSD_LOG_ERROR,
-                    "DNS Service Discovery registration error %d!",
-	            sdErr);
-    dnssdStop();
-  }
+	b --;
+	NumBrowsers --;
+      }
+    }
 }
-#  endif /* HAVE_DNSSD */
 
 
 /*
- * 'get_auth_info_required()' - Get the auth-info-required value to advertise.
+ * 'update_cups_browse()' - Update the browse lists using the CUPS protocol.
  */
 
-static char *				/* O - String or NULL if none */
-get_auth_info_required(
-    cupsd_printer_t *p,			/* I - Printer */
-    char            *buffer,		/* I - Value buffer */
-    size_t          bufsize)		/* I - Size of value buffer */
+static void
+update_cups_browse(void)
 {
-  cupsd_location_t *auth;		/* Pointer to authentication element */
-  char		resource[1024];		/* Printer/class resource path */
+  int		i;			/* Looping var */
+  int		auth;			/* Authorization status */
+  int		len;			/* Length of name string */
+  int		bytes;			/* Number of bytes left */
+  char		packet[1541],		/* Broadcast packet */
+		*pptr;			/* Pointer into packet */
+  socklen_t	srclen;			/* Length of source address */
+  http_addr_t	srcaddr;		/* Source address */
+  char		srcname[1024];		/* Source hostname */
+  unsigned	address[4];		/* Source address */
+  unsigned	type;			/* Printer type */
+  unsigned	state;			/* Printer state */
+  char		uri[HTTP_MAX_URI],	/* Printer URI */
+		host[HTTP_MAX_URI],	/* Host portion of URI */
+		resource[HTTP_MAX_URI],	/* Resource portion of URI */
+		info[IPP_MAX_NAME],	/* Information string */
+		location[IPP_MAX_NAME],	/* Location string */
+		make_model[IPP_MAX_NAME];/* Make and model string */
+  int		num_attrs;		/* Number of attributes */
+  cups_option_t	*attrs;			/* Attributes */
 
 
  /*
-  * If auth-info-required is set for this printer, return that...
-  */
-
-  if (p->num_auth_info_required > 0 && strcmp(p->auth_info_required[0], "none"))
+  * Read a packet from the browse socket...
+  */
+
+  srclen = sizeof(srcaddr);
+  if ((bytes = recvfrom(BrowseSocket, packet, sizeof(packet) - 1, 0,
+                        (struct sockaddr *)&srcaddr, &srclen)) < 0)
   {
-    int		i;			/* Looping var */
-    char	*bufptr;		/* Pointer into buffer */
+   /*
+    * "Connection refused" is returned under Linux if the destination port
+    * or address is unreachable from a previous sendto(); check for the
+    * error here and ignore it for now...
+    */
 
-    for (i = 0, bufptr = buffer; i < p->num_auth_info_required; i ++)
+    if (errno != ECONNREFUSED && errno != EAGAIN)
     {
-      if (bufptr >= (buffer + bufsize - 2))
-	break;
+      cupsdLogMessage(CUPSD_LOG_ERROR, "Browse recv failed - %s.",
+                      strerror(errno));
+      cupsdLogMessage(CUPSD_LOG_ERROR, "CUPS browsing turned off.");
+
+#ifdef WIN32
+      closesocket(BrowseSocket);
+#else
+      close(BrowseSocket);
+#endif /* WIN32 */
 
-      if (i)
-	*bufptr++ = ',';
+      cupsdRemoveSelect(BrowseSocket);
+      BrowseSocket = -1;
 
-      strlcpy(bufptr, p->auth_info_required[i], bufsize - (bufptr - buffer));
-      bufptr += strlen(bufptr);
+      BrowseLocalProtocols  &= ~BROWSE_CUPS;
+      BrowseRemoteProtocols &= ~BROWSE_CUPS;
     }
 
-    return (buffer);
+    return;
   }
 
+  packet[bytes] = '\0';
+
  /*
-  * Figure out the authentication data requirements to advertise...
+  * If we're about to sleep, ignore incoming browse packets.
   */
 
-  if (p->type & CUPS_PRINTER_CLASS)
-    snprintf(resource, sizeof(resource), "/classes/%s", p->name);
-  else
-    snprintf(resource, sizeof(resource), "/printers/%s", p->name);
+  if (Sleeping)
+    return;
 
-  if ((auth = cupsdFindBest(resource, HTTP_POST)) == NULL ||
-      auth->type == CUPSD_AUTH_NONE)
-    auth = cupsdFindPolicyOp(p->op_policy_ptr, IPP_PRINT_JOB);
+ /*
+  * Figure out where it came from...
+  */
 
-  if (auth)
+#ifdef AF_INET6
+  if (srcaddr.addr.sa_family == AF_INET6)
   {
-    int	auth_type;			/* Authentication type */
+    address[0] = ntohl(srcaddr.ipv6.sin6_addr.s6_addr32[0]);
+    address[1] = ntohl(srcaddr.ipv6.sin6_addr.s6_addr32[1]);
+    address[2] = ntohl(srcaddr.ipv6.sin6_addr.s6_addr32[2]);
+    address[3] = ntohl(srcaddr.ipv6.sin6_addr.s6_addr32[3]);
+  }
+  else
+#endif /* AF_INET6 */
+  {
+    address[0] = 0;
+    address[1] = 0;
+    address[2] = 0;
+    address[3] = ntohl(srcaddr.ipv4.sin_addr.s_addr);
+  }
 
-    if ((auth_type = auth->type) == CUPSD_AUTH_DEFAULT)
-      auth_type = cupsdDefaultAuthType();
+  if (HostNameLookups)
+    httpAddrLookup(&srcaddr, srcname, sizeof(srcname));
+  else
+    httpAddrString(&srcaddr, srcname, sizeof(srcname));
 
-    switch (auth_type)
-    {
-      case CUPSD_AUTH_NONE :
-          return (NULL);
+  len = strlen(srcname);
 
-      case CUPSD_AUTH_NEGOTIATE :
-	  strlcpy(buffer, "negotiate", bufsize);
-	  break;
+ /*
+  * Do ACL stuff...
+  */
 
-      default :
-	  strlcpy(buffer, "username,password", bufsize);
-	  break;
+  if (BrowseACL)
+  {
+    if (httpAddrLocalhost(&srcaddr) || !_cups_strcasecmp(srcname, "localhost"))
+    {
+     /*
+      * Access from localhost (127.0.0.1) is always allowed...
+      */
+
+      auth = CUPSD_AUTH_ALLOW;
     }
+    else
+    {
+     /*
+      * Do authorization checks on the domain/address...
+      */
 
-    return (buffer);
-  }
+      switch (BrowseACL->order_type)
+      {
+        default :
+	    auth = CUPSD_AUTH_DENY;	/* anti-compiler-warning-code */
+	    break;
 
-  return ("none");
-}
-#endif /* HAVE_DNSSD || HAVE_AVAHI */
+	case CUPSD_AUTH_ALLOW : /* Order Deny,Allow */
+            auth = CUPSD_AUTH_ALLOW;
 
+            if (cupsdCheckAuth(address, srcname, len, BrowseACL->deny))
+	      auth = CUPSD_AUTH_DENY;
 
-#ifdef __APPLE__
-/*
- * 'get_hostconfig()' - Get an /etc/hostconfig service setting.
- */
+            if (cupsdCheckAuth(address, srcname, len, BrowseACL->allow))
+	      auth = CUPSD_AUTH_ALLOW;
+	    break;
 
-static int				/* O - 1 for YES or AUTOMATIC, 0 for NO */
-get_hostconfig(const char *name)	/* I - Name of service */
-{
-  cups_file_t	*fp;			/* Hostconfig file */
-  char		line[1024],		/* Line from file */
-		*ptr;			/* Pointer to value */
-  int		state = 1;		/* State of service */
+	case CUPSD_AUTH_DENY : /* Order Allow,Deny */
+            auth = CUPSD_AUTH_DENY;
+
+            if (cupsdCheckAuth(address, srcname, len, BrowseACL->allow))
+	      auth = CUPSD_AUTH_ALLOW;
+
+            if (cupsdCheckAuth(address, srcname, len, BrowseACL->deny))
+	      auth = CUPSD_AUTH_DENY;
+	    break;
+      }
+    }
+  }
+  else
+    auth = CUPSD_AUTH_ALLOW;
+
+  if (auth == CUPSD_AUTH_DENY)
+  {
+    cupsdLogMessage(CUPSD_LOG_DEBUG,
+                    "update_cups_browse: Refused %d bytes from %s", bytes,
+                    srcname);
+    return;
+  }
 
+  cupsdLogMessage(CUPSD_LOG_DEBUG2,
+                  "update_cups_browse: (%d bytes from %s) %s", bytes,
+		  srcname, packet);
 
  /*
-  * Try opening the /etc/hostconfig file; if we can't open it, assume that
-  * the service is enabled/auto.
+  * Parse packet...
   */
 
-  if ((fp = cupsFileOpen("/etc/hostconfig", "r")) != NULL)
+  if (sscanf(packet, "%x%x%1023s", &type, &state, uri) < 3)
+  {
+    cupsdLogMessage(CUPSD_LOG_WARN,
+                    "update_cups_browse: Garbled browse packet - %s", packet);
+    return;
+  }
+
+  strcpy(location, "Location Unknown");
+  strcpy(info, "No Information Available");
+  make_model[0] = '\0';
+  num_attrs     = 0;
+  attrs         = NULL;
+
+  if ((pptr = strchr(packet, '\"')) != NULL)
   {
    /*
-    * Read lines from the file until we find the service...
+    * Have extended information; can't use sscanf for it because not all
+    * sscanf's allow empty strings with %[^\"]...
     */
 
-    while (cupsFileGets(fp, line, sizeof(line)))
+    for (i = 0, pptr ++;
+         i < (sizeof(location) - 1) && *pptr && *pptr != '\"';
+         i ++, pptr ++)
+      location[i] = *pptr;
+
+    if (i)
+      location[i] = '\0';
+
+    if (*pptr == '\"')
+      pptr ++;
+
+    while (*pptr && isspace(*pptr & 255))
+      pptr ++;
+
+    if (*pptr == '\"')
     {
-      if (line[0] == '#' || (ptr = strchr(line, '=')) == NULL)
-        continue;
+      for (i = 0, pptr ++;
+           i < (sizeof(info) - 1) && *pptr && *pptr != '\"';
+           i ++, pptr ++)
+	info[i] = *pptr;
 
-      *ptr++ = '\0';
+      info[i] = '\0';
 
-      if (!_cups_strcasecmp(line, name))
+      if (*pptr == '\"')
+	pptr ++;
+
+      while (*pptr && isspace(*pptr & 255))
+	pptr ++;
+
+      if (*pptr == '\"')
       {
-       /*
-        * Found the service, see if it is set to "-NO-"...
-	*/
+	for (i = 0, pptr ++;
+             i < (sizeof(make_model) - 1) && *pptr && *pptr != '\"';
+             i ++, pptr ++)
+	  make_model[i] = *pptr;
 
-	if (!_cups_strncasecmp(ptr, "-NO-", 4))
-	  state = 0;
-        break;
+	if (*pptr == '\"')
+	  pptr ++;
+
+	make_model[i] = '\0';
+
+        if (*pptr)
+	  num_attrs = cupsParseOptions(pptr, num_attrs, &attrs);
       }
     }
+  }
 
-    cupsFileClose(fp);
+  DEBUG_puts(packet);
+  DEBUG_printf(("type=%x, state=%x, uri=\"%s\"\n"
+                "location=\"%s\", info=\"%s\", make_model=\"%s\"\n",
+	        type, state, uri, location, info, make_model));
+
+ /*
+  * Pull the URI apart to see if this is a local or remote printer...
+  */
+
+  if (is_local_queue(uri, host, sizeof(host), resource, sizeof(resource)))
+  {
+    cupsFreeOptions(num_attrs, attrs);
+    return;
   }
 
-  return (state);
+ /*
+  * Do relaying...
+  */
+
+  for (i = 0; i < NumRelays; i ++)
+    if (cupsdCheckAuth(address, srcname, len, Relays[i].from))
+      if (sendto(BrowseSocket, packet, bytes, 0,
+                 (struct sockaddr *)&(Relays[i].to),
+		 httpAddrLength(&(Relays[i].to))) <= 0)
+      {
+	cupsdLogMessage(CUPSD_LOG_ERROR,
+	                "update_cups_browse: sendto failed for relay %d - %s.",
+	                i + 1, strerror(errno));
+	cupsFreeOptions(num_attrs, attrs);
+	return;
+      }
+
+ /*
+  * Process the browse data...
+  */
+
+  process_browse_data(uri, host, resource, (cups_ptype_t)type,
+                      (ipp_pstate_t)state, location, info, make_model,
+		      num_attrs, attrs);
 }
-#endif /* __APPLE__ */
 
 
 /*
@@ -1604,6 +3808,41 @@
 }
 
 
+/*
+ * 'update_polling()' - Read status messages from the poll daemons.
+ */
+
+static void
+update_polling(void)
+{
+  char		*ptr,			/* Pointer to end of line in buffer */
+		message[1024];		/* Pointer to message text */
+  int		loglevel;		/* Log level for message */
+
+
+  while ((ptr = cupsdStatBufUpdate(PollStatusBuffer, &loglevel,
+                                   message, sizeof(message))) != NULL)
+  {
+    if (loglevel == CUPSD_LOG_INFO)
+      cupsdLogMessage(CUPSD_LOG_INFO, "%s", message);
+
+    if (!strchr(PollStatusBuffer->buffer, '\n'))
+      break;
+  }
+
+  if (ptr == NULL && !PollStatusBuffer->bufused)
+  {
+   /*
+    * All polling processes have died; stop polling...
+    */
+
+    cupsdLogMessage(CUPSD_LOG_ERROR,
+                    "update_polling: all polling processes have exited!");
+    cupsdStopPolling();
+  }
+}
+
+
 /*
  * 'update_smb()' - Update the SMB configuration as needed.
  */
--- a/scheduler/classes.c
+++ b/scheduler/classes.c
@@ -22,6 +22,8 @@
  *   cupsdFindClass()                - Find the named class.
  *   cupsdLoadAllClasses()           - Load classes from the classes.conf file.
  *   cupsdSaveAllClasses()           - Save classes to the classes.conf file.
+ *   cupsdUpdateImplicitClasses()    - Update the accepting state of implicit
+ *                                     classes.
  */
 
 /*
@@ -182,9 +184,24 @@
   for (c = (cupsd_printer_t *)cupsArrayFirst(Printers);
        c;
        c = (cupsd_printer_t *)cupsArrayNext(Printers))
-    if (c->type & CUPS_PRINTER_CLASS)
+    if (c->type & (CUPS_PRINTER_CLASS | CUPS_PRINTER_IMPLICIT))
       changed |= cupsdDeletePrinterFromClass(c, p);
 
+ /*
+  * Then clean out any empty implicit classes...
+  */
+
+  for (c = (cupsd_printer_t *)cupsArrayFirst(ImplicitPrinters);
+       c;
+       c = (cupsd_printer_t *)cupsArrayNext(ImplicitPrinters))
+    if (c->num_printers == 0)
+    {
+      cupsdLogMessage(CUPSD_LOG_DEBUG, "Deleting implicit class \"%s\"...",
+                      c->name);
+      cupsdDeletePrinter(c, 0);
+      changed = 1;
+    }
+
   return (changed);
 }
 
@@ -262,7 +279,8 @@
   cupsd_printer_t	*c;		/* Current class/printer */
 
 
-  if ((c = cupsdFindDest(name)) != NULL && (c->type & CUPS_PRINTER_CLASS))
+  if ((c = cupsdFindDest(name)) != NULL &&
+      (c->type & (CUPS_PRINTER_CLASS | CUPS_PRINTER_IMPLICIT)))
     return (c);
   else
     return (NULL);
@@ -425,8 +443,9 @@
 	{
 	  cupsdSetString(&temp->make_model, "Remote Printer on unknown");
 
-          temp->state = IPP_PRINTER_STOPPED;
-	  temp->type  |= CUPS_PRINTER_REMOTE;
+          temp->state       = IPP_PRINTER_STOPPED;
+	  temp->type        |= CUPS_PRINTER_REMOTE;
+	  temp->browse_time = 2147483647;
 
 	  cupsdSetString(&temp->location, "Location Unknown");
 	  cupsdSetString(&temp->info, "No Information Available");
@@ -714,6 +733,7 @@
     */
 
     if ((pclass->type & CUPS_PRINTER_REMOTE) ||
+        (pclass->type & CUPS_PRINTER_IMPLICIT) ||
         !(pclass->type & CUPS_PRINTER_CLASS))
       continue;
 
@@ -813,6 +833,36 @@
 }
 
 
+/*
+ * 'cupsdUpdateImplicitClasses()' - Update the accepting state of implicit
+ *                                  classes.
+ */
+
+void
+cupsdUpdateImplicitClasses(void)
+{
+  int			i;		/* Looping var */
+  cupsd_printer_t	*pclass;	/* Current class */
+  int			accepting;	/* printer-is-accepting-jobs value */
+
+
+  for (pclass = (cupsd_printer_t *)cupsArrayFirst(ImplicitPrinters);
+       pclass;
+       pclass = (cupsd_printer_t *)cupsArrayNext(ImplicitPrinters))
+  {
+   /*
+    * Loop through the printers to come up with a composite state...
+    */
+
+    for (i = 0, accepting = 0; i < pclass->num_printers; i ++)
+      if ((accepting = pclass->printers[i]->accepting) != 0)
+	break;
+
+    pclass->accepting = accepting;
+  }
+}
+
+
 /*
  * End of "$Id: classes.c 10104 2011-11-04 06:37:03Z mike $".
  */
--- a/scheduler/main.c
+++ b/scheduler/main.c
@@ -122,6 +122,7 @@
   cupsd_listener_t	*lis;		/* Current listener */
   time_t		current_time,	/* Current time */
 			activity,	/* Client activity timer */
+			browse_time,	/* Next browse send time */
 			senddoc_time,	/* Send-Document time */
 			expire_time,	/* Subscription expire time */
 			report_time,	/* Malloc/client/job report time */
@@ -656,6 +657,7 @@
   */
 
   current_time  = time(NULL);
+  browse_time   = current_time;
   event_time    = current_time;
   expire_time   = current_time;
   fds           = 1;
@@ -771,9 +773,11 @@
     * inactivity...
     */
 
-    if (timeout == 86400 && Launchd && LaunchdTimeout &&
+    if (timeout == 86400 && Launchd && LaunchdTimeout && !NumPolled &&
         !cupsArrayCount(ActiveJobs) &&
-	(!Browsing || !BrowseLocalProtocols || !cupsArrayCount(Printers)))
+	(!Browsing ||
+	 (!BrowseRemoteProtocols &&
+	  (!BrowseLocalProtocols || !cupsArrayCount(Printers)))))
     {
       timeout		= LaunchdTimeout;
       launchd_idle_exit = 1;
@@ -815,6 +819,8 @@
 	   i ++, lis = (cupsd_listener_t *)cupsArrayNext(Listeners))
         cupsdLogMessage(CUPSD_LOG_EMERG, "Listeners[%d] = %d", i, lis->fd);
 
+      cupsdLogMessage(CUPSD_LOG_EMERG, "BrowseSocket = %d", BrowseSocket);
+
       cupsdLogMessage(CUPSD_LOG_EMERG, "CGIPipes[0] = %d", CGIPipes[0]);
 
 #ifdef __APPLE__
@@ -915,6 +921,16 @@
       expire_time = current_time;
     }
 
+   /*
+    * Update the browse list as needed...
+    */
+
+    if (Browsing && current_time > browse_time)
+    {
+      cupsdSendBrowseList();
+      browse_time = current_time;
+    }
+
 #ifndef HAVE_AUTHORIZATION_H
    /*
     * Update the root certificate once every 5 minutes if we have client
@@ -1013,6 +1029,8 @@
                       cupsArrayCount(ActiveJobs));
       cupsdLogMessage(CUPSD_LOG_DEBUG, "Report: printers=%d",
                       cupsArrayCount(Printers));
+      cupsdLogMessage(CUPSD_LOG_DEBUG, "Report: printers-implicit=%d",
+                      cupsArrayCount(ImplicitPrinters));
 
       string_count = _cupsStrStatistics(&alloc_bytes, &total_bytes);
       cupsdLogMessage(CUPSD_LOG_DEBUG,
@@ -1523,8 +1541,10 @@
   * shared printers to advertise...
   */
 
-  if (cupsArrayCount(ActiveJobs) ||
-      (Browsing && BrowseLocalProtocols && cupsArrayCount(Printers)))
+  if (cupsArrayCount(ActiveJobs) || NumPolled ||
+      (Browsing &&
+       (BrowseRemoteProtocols ||
+        (BrowseLocalProtocols && cupsArrayCount(Printers)))))
   {
     cupsdLogMessage(CUPSD_LOG_DEBUG,
                     "Creating launchd keepalive file \"" CUPS_KEEPALIVE
@@ -1806,6 +1826,7 @@
   long			timeout;	/* Timeout for select */
   time_t		now;		/* Current time */
   cupsd_client_t	*con;		/* Client information */
+  cupsd_printer_t	*p;		/* Printer information */
   cupsd_job_t		*job;		/* Job information */
   cupsd_subscription_t	*sub;		/* Subscription information */
   const char		*why;		/* Debugging aid */
@@ -1883,6 +1904,38 @@
     }
 
  /*
+  * Update the browse list as needed...
+  */
+
+  if (Browsing && BrowseLocalProtocols)
+  {
+    if ((BrowseLocalProtocols & BROWSE_CUPS) && NumBrowsers)
+    {
+      for (p = (cupsd_printer_t *)cupsArrayFirst(Printers);
+           p;
+	   p = (cupsd_printer_t *)cupsArrayNext(Printers))
+      {
+	if (p->type & CUPS_PRINTER_REMOTE)
+	{
+	  if ((p->browse_time + BrowseTimeout) < timeout)
+	  {
+	    timeout = p->browse_time + BrowseTimeout;
+	    why     = "browse timeout a printer";
+	  }
+	}
+	else if (p->shared && !(p->type & CUPS_PRINTER_IMPLICIT))
+	{
+	  if (BrowseInterval && (p->browse_time + BrowseInterval) < timeout)
+	  {
+	    timeout = p->browse_time + BrowseInterval;
+	    why     = "send browse update";
+	  }
+	}
+      }
+    }
+  }
+
+ /*
   * Write out changes to configuration and state files...
   */
 
--- a/scheduler/job.c
+++ b/scheduler/job.c
@@ -387,7 +387,8 @@
       printer = cupsdFindDest(job->dest);
       pclass  = NULL;
 
-      while (printer && (printer->type & CUPS_PRINTER_CLASS))
+      while (printer &&
+             (printer->type & (CUPS_PRINTER_IMPLICIT | CUPS_PRINTER_CLASS)))
       {
        /*
         * If the class is remote, just pass it to the remote server...
@@ -439,7 +440,10 @@
           cupsdMarkDirty(CUPSD_DIRTY_JOBS);
 	}
 
-        if (!printer->job && printer->state == IPP_PRINTER_IDLE)
+        if ((!(printer->type & CUPS_PRINTER_DISCOVERED) && /* Printer is local */
+	     printer->state == IPP_PRINTER_IDLE) ||	/* and idle, OR */
+	    ((printer->type & CUPS_PRINTER_DISCOVERED) && /* Printer is remote */
+	     !printer->job))				/* and not printing */
         {
 	 /*
 	  * Start the job...
@@ -812,7 +816,7 @@
                 job->job_sheets->values[0].string.text,
                 job->job_sheets->values[1].string.text);
 
-  if (job->printer->type & CUPS_PRINTER_REMOTE)
+  if (job->printer->type & (CUPS_PRINTER_REMOTE | CUPS_PRINTER_IMPLICIT))
     banner_page = 0;
   else if (job->job_sheets == NULL)
     banner_page = 0;
@@ -1070,7 +1074,7 @@
     envp[envc ++] = classification;
   }
 
-  if (job->dtype & CUPS_PRINTER_CLASS)
+  if (job->dtype & (CUPS_PRINTER_CLASS | CUPS_PRINTER_IMPLICIT))
   {
     snprintf(class_name, sizeof(class_name), "CLASS=%s", job->dest);
     envp[envc ++] = class_name;
@@ -2046,7 +2050,8 @@
 		p->name);
 
   cupsdSetString(&job->dest, p->name);
-  job->dtype = p->type & (CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE);
+  job->dtype = p->type & (CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE |
+                          CUPS_PRINTER_IMPLICIT);
 
   if ((attr = ippFindAttribute(job->attrs, "job-printer-uri",
                                IPP_TAG_URI)) != NULL)
@@ -3098,7 +3103,7 @@
 	  * act...
 	  */
 
-          if (job->dtype & CUPS_PRINTER_CLASS)
+          if (job->dtype & (CUPS_PRINTER_CLASS | CUPS_PRINTER_IMPLICIT))
 	  {
 	   /*
 	    * Queued on a class - mark the job as pending and we'll retry on
@@ -4745,7 +4750,10 @@
         cupsdSetAuthInfoRequired(job->printer, attr, NULL);
 	cupsdSetPrinterAttrs(job->printer);
 
-	cupsdMarkDirty(CUPSD_DIRTY_PRINTERS);
+	if (job->printer->type & CUPS_PRINTER_DISCOVERED)
+	  cupsdMarkDirty(CUPSD_DIRTY_REMOTE);
+	else
+	  cupsdMarkDirty(CUPSD_DIRTY_PRINTERS);
       }
 
       if ((attr = cupsGetOption("job-media-progress", num_attrs,
--- a/scheduler/Makefile
+++ b/scheduler/Makefile
@@ -53,6 +53,8 @@
 		cups-deviced.o \
 		cups-exec.o \
 		cups-lpd.o \
+		cups-polld.o \
+		testdirsvc.o \
 		testlpd.o \
 		testmime.o \
 		testspeed.o \
@@ -68,6 +70,7 @@
 		libcupsmime.a
 
 UNITTARGETS =	\
+		testdirsvc \
 		testlpd \
 		testmime \
 		testspeed \
@@ -79,7 +82,8 @@
 		cups-deviced \
 		cups-driverd \
 		cups-exec \
-		cups-lpd
+		cups-lpd \
+		cups-polld
 
 TARGETS	=	\
 		$(LIBTARGETS) \
@@ -220,6 +224,7 @@
 	$(INSTALL_BIN) cups-driverd $(SERVERBIN)/daemon
 	$(INSTALL_BIN) cups-exec $(SERVERBIN)/daemon
 	$(INSTALL_BIN) cups-lpd $(SERVERBIN)/daemon
+	$(INSTALL_BIN) cups-polld $(SERVERBIN)/daemon
 	if test "x$(SYMROOT)" != "x"; then \
 		$(INSTALL_DIR) $(SYMROOT); \
 		for file in $(PROGRAMS); do \
@@ -277,6 +282,7 @@
 	$(RM) $(SERVERBIN)/daemon/cups-driverd
 	$(RM) $(SERVERBIN)/daemon/cups-exec
 	$(RM) $(SERVERBIN)/daemon/cups-lpd
+	$(RM) $(SERVERBIN)/daemon/cups-polld
 	$(RM) $(BUILDROOT)/System/Library/Printers/Libraries/convert
 	-$(RMDIR) $(STATEDIR)/certs
 	-$(RMDIR) $(STATEDIR)
@@ -433,6 +439,15 @@
 
 
 #
+# Make the polling daemon, "cups-polld".
+#
+
+cups-polld:	cups-polld.o ../cups/$(LIBCUPS)
+	echo Linking $@...
+	$(CC) $(LDFLAGS) -o cups-polld cups-polld.o $(LIBS)
+
+
+#
 # libcupsmime.so.1, libcupsmime.sl.1
 #
 
@@ -492,6 +507,15 @@
 
 
 #
+# Make the test program, "testdirsvc".
+#
+
+testdirsvc:	testdirsvc.o
+	echo Linking $@...
+	$(CC) $(LDFLAGS) -o testdirsvc testdirsvc.o $(COMMONLIBS) $(NETLIBS)
+
+
+#
 # Make the test program, "testlpd".
 #
 
@@ -540,7 +564,7 @@
 
 sloc:
 	echo "cupsd: \c"
-	sloccount $(CUPSDOBJS:.o=.c) $(LIBOBJS:.o=.c) cups-driverd.cxx cups-lpd.c 2>/dev/null | grep "Total Physical" | awk '{print $$9}'
+	sloccount $(CUPSDOBJS:.o=.c) $(LIBOBJS:.o=.c) cups-driverd.cxx cups-polld.c cups-lpd.c 2>/dev/null | grep "Total Physical" | awk '{print $$9}'
 
 
 #
--- a/scheduler/conf.h
+++ b/scheduler/conf.h
@@ -195,6 +195,12 @@
 					/* Support the Keep-Alive option? */
 			KeepAliveTimeout	VALUE(DEFAULT_KEEPALIVE),
 					/* Timeout between requests */
+			ImplicitClasses		VALUE(TRUE),
+					/* Are classes implicitly created? */
+			ImplicitAnyClasses	VALUE(FALSE),
+					/* Create AnyPrinter classes? */
+			HideImplicitMembers	VALUE(TRUE),
+					/* Hide implicit class members? */
 			FileDevice		VALUE(FALSE),
 					/* Allow file: devices? */
 			FilterLimit		VALUE(0),
--- a/scheduler/printers.h
+++ b/scheduler/printers.h
@@ -80,6 +80,9 @@
   time_t	state_time;		/* Time at this state */
   char		*job_sheets[2];		/* Banners/job sheets */
   cups_ptype_t	type;			/* Printer type (color, small, etc.) */
+  char		*browse_attrs;		/* Attributes sent with browse data */
+  time_t	browse_expire;		/* Expiration time for printer */
+  time_t	browse_time;		/* Last time update was sent/received */
   char		*device_uri;		/* Device URI */
   char		*sanitized_device_uri;	/* Sanitized device URI */
   char		*port_monitor;		/* Port monitor */
@@ -133,8 +136,10 @@
 					/* Common printer object attrs */
 VAR cups_array_t	*CommonDefaults	VALUE(NULL);
 					/* Common -default option names */
-VAR cups_array_t	*Printers	VALUE(NULL);
+VAR cups_array_t	*Printers	VALUE(NULL),
 					/* Printer list */
+			*ImplicitPrinters VALUE(NULL);
+					/* Implicit class printers */
 VAR cupsd_printer_t	*DefaultPrinter	VALUE(NULL);
 					/* Default printer */
 VAR char		*DefaultPolicy	VALUE(NULL);
--- a/scheduler/dirsvc.h
+++ b/scheduler/dirsvc.h
@@ -17,10 +17,47 @@
  * Browse protocols...
  */
 
-#define BROWSE_DNSSD	1		/* DNS Service Discovery (aka Bonjour) */
-#define BROWSE_SMB	2		/* SMB/Samba */
-#define BROWSE_LPD	4		/* LPD via xinetd or launchd */
-#define BROWSE_ALL	7		/* All protocols */
+#define BROWSE_CUPS	1		/* CUPS */
+#define	BROWSE_SLP	2		/* SLPv2 */
+#define BROWSE_LDAP	4		/* LDAP */
+#define BROWSE_DNSSD	8		/* DNS Service Discovery (aka Bonjour) */
+#define BROWSE_SMB	16		/* SMB/Samba */
+#define BROWSE_LPD	32		/* LPD via xinetd or launchd */
+#define BROWSE_ALL	63		/* All protocols */
+
+
+/*
+ * Browse address...
+ */
+
+typedef struct
+{
+  char			iface[32];	/* Destination interface */
+  http_addr_t		to;		/* Destination address */
+} cupsd_dirsvc_addr_t;
+
+
+/*
+ * Relay structure...
+ */
+
+typedef struct
+{
+  cups_array_t		*from;		/* Source address/name mask(s) */
+  http_addr_t		to;		/* Destination address */
+} cupsd_dirsvc_relay_t;
+
+
+/*
+ * Polling structure...
+ */
+
+typedef struct
+{
+  char			hostname[64];	/* Hostname (actually, IP address) */
+  int			port;		/* Port number */
+  int			pid;		/* Current poll server PID */
+} cupsd_dirsvc_poll_t;
 
 
 /*
@@ -32,8 +69,50 @@
 			BrowseWebIF	VALUE(FALSE),
 					/* Whether the web interface is advertised */
 			BrowseLocalProtocols
-					VALUE(BROWSE_ALL);
+					VALUE(BROWSE_ALL),
 					/* Protocols to support for local printers */
+			BrowseRemoteProtocols
+					VALUE(BROWSE_ALL),
+					/* Protocols to support for remote printers */
+			BrowseShortNames VALUE(TRUE),
+					/* Short names for remote printers? */
+			BrowseSocket	VALUE(-1),
+					/* Socket for browsing */
+			BrowsePort	VALUE(IPP_PORT),
+					/* Port number for broadcasts */
+			BrowseInterval	VALUE(DEFAULT_INTERVAL),
+					/* Broadcast interval in seconds */
+			BrowseTimeout	VALUE(DEFAULT_TIMEOUT),
+					/* Time out for printers in seconds */
+			UseNetworkDefault VALUE(CUPS_DEFAULT_USE_NETWORK_DEFAULT),
+					/* Use the network default printer? */
+			NumBrowsers	VALUE(0);
+					/* Number of broadcast addresses */
+VAR char		*BrowseLocalOptions
+					VALUE(NULL),
+					/* Options to add to local printer URIs */
+			*BrowseRemoteOptions
+					VALUE(NULL);
+					/* Options to add to remote printer URIs */
+VAR cupsd_dirsvc_addr_t	*Browsers	VALUE(NULL);
+					/* Broadcast addresses */
+VAR cupsd_location_t	*BrowseACL	VALUE(NULL);
+					/* Browser access control list */
+VAR cupsd_printer_t	*BrowseNext	VALUE(NULL);
+					/* Next class/printer to broadcast */
+VAR int			NumRelays	VALUE(0);
+					/* Number of broadcast relays */
+VAR cupsd_dirsvc_relay_t *Relays	VALUE(NULL);
+					/* Broadcast relays */
+VAR int			NumPolled	VALUE(0);
+					/* Number of polled servers */
+VAR cupsd_dirsvc_poll_t	*Polled		VALUE(NULL);
+					/* Polled servers */
+VAR int			PollPipe	VALUE(0);
+					/* Status pipe for pollers */
+VAR cupsd_statbuf_t	*PollStatusBuffer VALUE(NULL);
+					/* Status buffer for pollers */
+
 #if defined(HAVE_DNSSD) || defined(HAVE_AVAHI)
 VAR char		*DNSSDComputerName VALUE(NULL),
 					/* Computer/server name */
@@ -71,9 +150,15 @@
  */
 
 extern void	cupsdDeregisterPrinter(cupsd_printer_t *p, int removeit);
+extern void	cupsdLoadRemoteCache(void);
 extern void	cupsdRegisterPrinter(cupsd_printer_t *p);
+extern void	cupsdRestartPolling(void);
+extern void	cupsdSaveRemoteCache(void);
+extern void	cupsdSendBrowseList(void);
 extern void	cupsdStartBrowsing(void);
+extern void	cupsdStartPolling(void);
 extern void	cupsdStopBrowsing(void);
+extern void	cupsdStopPolling(void);
 #if defined(HAVE_DNSSD) || defined(HAVE_AVAHI)
 extern void	cupsdUpdateDNSSDName(void);
 #endif /* HAVE_DNSSD || HAVE_AVAHI */
--- a/scheduler/sysman.h
+++ b/scheduler/sysman.h
@@ -20,9 +20,10 @@
 #define CUPSD_DIRTY_NONE	0	/* Nothing is dirty */
 #define CUPSD_DIRTY_PRINTERS	1	/* printers.conf is dirty */
 #define CUPSD_DIRTY_CLASSES	2	/* classes.conf is dirty */
-#define CUPSD_DIRTY_PRINTCAP	4	/* printcap is dirty */
-#define CUPSD_DIRTY_JOBS	8	/* jobs.cache or "c" file(s) are dirty */
-#define CUPSD_DIRTY_SUBSCRIPTIONS 16	/* subscriptions.conf is dirty */
+#define CUPSD_DIRTY_REMOTE	4	/* remote.cache is dirty */
+#define CUPSD_DIRTY_PRINTCAP	8	/* printcap is dirty */
+#define CUPSD_DIRTY_JOBS	16	/* jobs.cache or "c" file(s) are dirty */
+#define CUPSD_DIRTY_SUBSCRIPTIONS 32	/* subscriptions.conf is dirty */
 
 
 /*
--- a/scheduler/ipp.c
+++ b/scheduler/ipp.c
@@ -826,7 +826,8 @@
   printer = cupsdFindDest(job->dest);
   attr    = ippFindAttribute(job->attrs, "job-sheets", IPP_TAG_NAME);
 
-  if (printer && !(printer->type & CUPS_PRINTER_REMOTE) &&
+  if (printer &&
+      !(printer->type & (CUPS_PRINTER_REMOTE | CUPS_PRINTER_IMPLICIT)) &&
       attr && attr->num_values > 1)
   {
    /*
@@ -941,6 +942,7 @@
   cups_ptype_t	dtype;			/* Destination type */
   ipp_attribute_t *attr;		/* Printer attribute */
   int		modify;			/* Non-zero if we just modified */
+  char		newname[IPP_MAX_NAME];	/* New class name */
   int		need_restart_job;	/* Need to restart job? */
 
 
@@ -994,7 +996,8 @@
     * Class doesn't exist; see if we have a printer of the same name...
     */
 
-    if ((pclass = cupsdFindPrinter(resource + 9)) != NULL)
+    if ((pclass = cupsdFindPrinter(resource + 9)) != NULL &&
+        !(pclass->type & CUPS_PRINTER_DISCOVERED))
     {
      /*
       * Yes, return an error...
@@ -1019,6 +1022,56 @@
     pclass = cupsdAddClass(resource + 9);
     modify = 0;
   }
+  else if (pclass->type & CUPS_PRINTER_IMPLICIT)
+  {
+   /*
+    * Check the default policy, then rename the implicit class to "AnyClass"
+    * or remove it...
+    */
+
+    if ((status = cupsdCheckPolicy(DefaultPolicyPtr, con, NULL)) != HTTP_OK)
+    {
+      send_http_error(con, status, NULL);
+      return;
+    }
+
+    if (ImplicitAnyClasses)
+    {
+      snprintf(newname, sizeof(newname), "Any%s", resource + 9);
+      cupsdRenamePrinter(pclass, newname);
+    }
+    else
+      cupsdDeletePrinter(pclass, 1);
+
+   /*
+    * Add the class as a new local class...
+    */
+
+    pclass = cupsdAddClass(resource + 9);
+    modify = 0;
+  }
+  else if (pclass->type & CUPS_PRINTER_DISCOVERED)
+  {
+   /*
+    * Check the default policy, then rename the remote class to "Class"...
+    */
+
+    if ((status = cupsdCheckPolicy(DefaultPolicyPtr, con, NULL)) != HTTP_OK)
+    {
+      send_http_error(con, status, NULL);
+      return;
+    }
+
+    snprintf(newname, sizeof(newname), "%s@%s", resource + 9, pclass->hostname);
+    cupsdRenamePrinter(pclass, newname);
+
+   /*
+    * Add the class as a new local class...
+    */
+
+    pclass = cupsdAddClass(resource + 9);
+    modify = 0;
+  }
   else if ((status = cupsdCheckPolicy(pclass->op_policy_ptr, con,
                                       NULL)) != HTTP_OK)
   {
@@ -1550,7 +1603,8 @@
     return (NULL);
   }
 
-  job->dtype   = printer->type & (CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE);
+  job->dtype   = printer->type & (CUPS_PRINTER_CLASS | CUPS_PRINTER_IMPLICIT |
+                                  CUPS_PRINTER_REMOTE);
   job->attrs   = con->request;
   job->dirty   = 1;
   con->request = ippNewRequest(job->attrs->request.op.operation_id);
@@ -1741,7 +1795,8 @@
     ippSetString(job->attrs, &job->reasons, 0, "none");
   }
 
-  if (!(printer->type & CUPS_PRINTER_REMOTE) || Classification)
+  if (!(printer->type & (CUPS_PRINTER_REMOTE | CUPS_PRINTER_IMPLICIT)) ||
+      Classification)
   {
    /*
     * Add job sheets options...
@@ -1874,7 +1929,7 @@
     * See if we need to add the starting sheet...
     */
 
-    if (!(printer->type & CUPS_PRINTER_REMOTE))
+    if (!(printer->type & (CUPS_PRINTER_REMOTE | CUPS_PRINTER_IMPLICIT)))
     {
       cupsdLogJob(job, CUPSD_LOG_INFO, "Adding start banner page \"%s\".",
 		  attr->values[0].string.text);
@@ -2218,6 +2273,7 @@
   char		srcfile[1024],		/* Source Script/PPD file */
 		dstfile[1024];		/* Destination Script/PPD file */
   int		modify;			/* Non-zero if we are modifying */
+  char		newname[IPP_MAX_NAME];	/* New printer name */
   int		changed_driver,		/* Changed the PPD/interface script? */
 		need_restart_job,	/* Need to restart job? */
 		set_device_uri,		/* Did we set the device URI? */
@@ -2273,7 +2329,8 @@
     * Printer doesn't exist; see if we have a class of the same name...
     */
 
-    if ((printer = cupsdFindClass(resource + 10)) != NULL)
+    if ((printer = cupsdFindClass(resource + 10)) != NULL &&
+        !(printer->type & CUPS_PRINTER_DISCOVERED))
     {
      /*
       * Yes, return an error...
@@ -2298,6 +2355,58 @@
     printer = cupsdAddPrinter(resource + 10);
     modify  = 0;
   }
+  else if (printer->type & CUPS_PRINTER_IMPLICIT)
+  {
+   /*
+    * Check the default policy, then rename the implicit printer to
+    * "AnyPrinter" or delete it...
+    */
+
+    if ((status = cupsdCheckPolicy(DefaultPolicyPtr, con, NULL)) != HTTP_OK)
+    {
+      send_http_error(con, status, NULL);
+      return;
+    }
+
+    if (ImplicitAnyClasses)
+    {
+      snprintf(newname, sizeof(newname), "Any%s", resource + 10);
+      cupsdRenamePrinter(printer, newname);
+    }
+    else
+      cupsdDeletePrinter(printer, 1);
+
+   /*
+    * Add the printer as a new local printer...
+    */
+
+    printer = cupsdAddPrinter(resource + 10);
+    modify  = 0;
+  }
+  else if (printer->type & CUPS_PRINTER_DISCOVERED)
+  {
+   /*
+    * Check the default policy, then rename the remote printer to
+    * "Printer@server"...
+    */
+
+    if ((status = cupsdCheckPolicy(DefaultPolicyPtr, con, NULL)) != HTTP_OK)
+    {
+      send_http_error(con, status, NULL);
+      return;
+    }
+
+    snprintf(newname, sizeof(newname), "%s@%s", resource + 10,
+             printer->hostname);
+    cupsdRenamePrinter(printer, newname);
+
+   /*
+    * Add the printer as a new local printer...
+    */
+
+    printer = cupsdAddPrinter(resource + 10);
+    modify  = 0;
+  }
   else if ((status = cupsdCheckPolicy(printer->op_policy_ptr, con,
                                       NULL)) != HTTP_OK)
   {
@@ -4716,8 +4825,8 @@
   {
     httpAssembleURIf(HTTP_URI_CODING_ALL, job_uri, sizeof(job_uri), "ipp", NULL,
 		     con->servername, con->serverport,
-		     (job->dtype & CUPS_PRINTER_CLASS) ? "/classes/%s" :
-		                                         "/printers/%s",
+		     job->dtype & (CUPS_PRINTER_IMPLICIT | CUPS_PRINTER_CLASS) ?
+		         "/classes/%s" : "/printers/%s",
 		     job->dest);
     ippAddString(con->response, IPP_TAG_JOB, IPP_TAG_URI,
         	 "job-printer-uri", NULL, job_uri);
@@ -4839,7 +4948,7 @@
 		    "stop-printer"
 		  };
 
-    if (printer->type & CUPS_PRINTER_CLASS)
+    if (printer->type & (CUPS_PRINTER_IMPLICIT | CUPS_PRINTER_CLASS))
       ippAddString(con->response, IPP_TAG_PRINTER, IPP_TAG_NAME | IPP_TAG_COPY,
                    "printer-error-policy-supported", NULL, "retry-current-job");
     else
@@ -4866,7 +4975,8 @@
     ippAddBoolean(con->response, IPP_TAG_PRINTER, "printer-is-shared",
                   printer->shared);
 
-  if (!ra || cupsArrayFind(ra, "printer-more-info"))
+  if ((!ra || cupsArrayFind(ra, "printer-more-info")) &&
+      !(printer->type & CUPS_PRINTER_DISCOVERED))
   {
     httpAssembleURIf(HTTP_URI_CODING_ALL, printer_uri, sizeof(printer_uri),
                      "http", NULL, con->servername, con->serverport,
@@ -4922,7 +5032,8 @@
     ippAddInteger(con->response, IPP_TAG_PRINTER, IPP_TAG_INTEGER,
                   "printer-up-time", curtime);
 
-  if (!ra || cupsArrayFind(ra, "printer-uri-supported"))
+  if ((!ra || cupsArrayFind(ra, "printer-uri-supported")) &&
+      !(printer->type & CUPS_PRINTER_DISCOVERED))
   {
     httpAssembleURIf(HTTP_URI_CODING_ALL, printer_uri, sizeof(printer_uri),
                      "ipp", NULL, con->servername, con->serverport,
@@ -6873,10 +6984,11 @@
                    "printer-uri", NULL, dest->uri);
       return;
     }
-    else if (dtype & CUPS_PRINTER_CLASS)
+    else if (dtype & (CUPS_PRINTER_CLASS | CUPS_PRINTER_IMPLICIT))
     {
       for (i = 0; i < dest->num_printers; i ++)
-        if (!(dest->printers[i]->type & CUPS_PRINTER_CLASS))
+        if (!(dest->printers[i]->type &
+	      (CUPS_PRINTER_CLASS | CUPS_PRINTER_IMPLICIT)))
 	{
 	  snprintf(filename, sizeof(filename), "%s/ppd/%s.ppd", ServerRoot,
 		   dest->printers[i]->name);
@@ -7324,6 +7436,15 @@
 	 (printer->location && !_cups_strcasecmp(printer->location, location))))
     {
      /*
+      * If HideImplicitMembers is enabled, see if this printer or class
+      * is a member of an implicit class...
+      */
+
+      if (ImplicitClasses && HideImplicitMembers &&
+          printer->in_implicit_class)
+        continue;
+
+     /*
       * If a username is specified, see if it is allowed or denied
       * access...
       */
@@ -9950,7 +10071,7 @@
 		"%s is now the default printer.", printer->name);
 
   cupsdMarkDirty(CUPSD_DIRTY_PRINTERS | CUPSD_DIRTY_CLASSES |
-                 CUPSD_DIRTY_PRINTCAP);
+                 CUPSD_DIRTY_REMOTE | CUPSD_DIRTY_PRINTCAP);
 
   cupsdLogMessage(CUPSD_LOG_INFO,
                   "Default destination set to \"%s\" by \"%s\".",
@@ -10571,7 +10692,7 @@
         continue;
 
       if (strcmp(attr->values[0].string.text, "retry-current-job") &&
-          ((printer->type & CUPS_PRINTER_CLASS) ||
+          ((printer->type & (CUPS_PRINTER_IMPLICIT | CUPS_PRINTER_CLASS)) ||
 	   (strcmp(attr->values[0].string.text, "abort-job") &&
 	    strcmp(attr->values[0].string.text, "retry-job") &&
 	    strcmp(attr->values[0].string.text, "stop-printer"))))
--- a/scheduler/server.c
+++ b/scheduler/server.c
@@ -62,6 +62,7 @@
 
   cupsdStartListening();
   cupsdStartBrowsing();
+  cupsdStartPolling();
 
  /*
   * Create a pipe for CGI processes...
@@ -111,6 +112,7 @@
 
   cupsdCloseAllClients();
   cupsdStopListening();
+  cupsdStopPolling();
   cupsdStopBrowsing();
   cupsdStopAllNotifiers();
   cupsdDeleteAllCerts();
--- a/config-scripts/cups-defaults.m4
+++ b/config-scripts/cups-defaults.m4
@@ -96,16 +96,16 @@
 AC_SUBST(CUPS_BROWSING)
 
 dnl Default BrowseLocalProtocols
-AC_ARG_WITH(local_protocols, [  --with-local-protocols  set default BrowseLocalProtocols, default=""],
+AC_ARG_WITH(local_protocols, [  --with-local-protocols  set default BrowseLocalProtocols, default="CUPS"],
 	default_local_protocols="$withval",
 	default_local_protocols="default")
 
 if test "x$with_local_protocols" != "xno"; then
 	if test "x$default_local_protocols" = "xdefault"; then
 		if test "x$DNSSD_BACKEND" != "x"; then
-			CUPS_BROWSE_LOCAL_PROTOCOLS="dnssd"
+			CUPS_BROWSE_LOCAL_PROTOCOLS="CUPS dnssd"
 		else
-			CUPS_BROWSE_LOCAL_PROTOCOLS=""
+			CUPS_BROWSE_LOCAL_PROTOCOLS="CUPS"
 		fi
 	else
 		CUPS_BROWSE_LOCAL_PROTOCOLS="$default_local_protocols"
@@ -118,6 +118,41 @@
 AC_DEFINE_UNQUOTED(CUPS_DEFAULT_BROWSE_LOCAL_PROTOCOLS,
 	"$CUPS_BROWSE_LOCAL_PROTOCOLS")
 
+dnl Default BrowseRemoteProtocols
+AC_ARG_WITH(remote_protocols, [  --with-remote-protocols set default BrowseRemoteProtocols, default="CUPS"],
+	default_remote_protocols="$withval",
+	default_remote_protocols="default")
+
+if test "x$with_remote_protocols" != "xno"; then
+	if test "x$default_remote_protocols" = "xdefault"; then
+		if test "$uname" = "Darwin" -a $uversion -ge 90; then
+			CUPS_BROWSE_REMOTE_PROTOCOLS=""
+		else
+			CUPS_BROWSE_REMOTE_PROTOCOLS="CUPS"
+		fi
+	else
+		CUPS_BROWSE_REMOTE_PROTOCOLS="$default_remote_protocols"
+	fi
+else
+	CUPS_BROWSE_REMOTE_PROTOCOLS=""
+fi
+
+AC_SUBST(CUPS_BROWSE_REMOTE_PROTOCOLS)
+AC_DEFINE_UNQUOTED(CUPS_DEFAULT_BROWSE_REMOTE_PROTOCOLS,
+	"$CUPS_BROWSE_REMOTE_PROTOCOLS")
+
+dnl Default BrowseShortNames
+AC_ARG_ENABLE(browse_short, [  --disable-browse-short-names
+			  disable BrowseShortNames by default])
+if test "x$enable_browse_short" = xno; then
+	CUPS_BROWSE_SHORT_NAMES="No"
+	AC_DEFINE_UNQUOTED(CUPS_DEFAULT_BROWSE_SHORT_NAMES, 0)
+else
+	CUPS_BROWSE_SHORT_NAMES="Yes"
+	AC_DEFINE_UNQUOTED(CUPS_DEFAULT_BROWSE_SHORT_NAMES, 1)
+fi
+AC_SUBST(CUPS_BROWSE_SHORT_NAMES)
+
 dnl Default DefaultShared
 AC_ARG_ENABLE(default_shared, [  --disable-default-shared
 			  disable DefaultShared by default])
@@ -130,6 +165,38 @@
 fi
 AC_SUBST(CUPS_DEFAULT_SHARED)
 
+dnl Default ImplicitClasses
+AC_ARG_ENABLE(implicit, [  --disable-implicit-classes
+                          disable ImplicitClasses by default])
+if test "x$enable_implicit" = xno; then
+	CUPS_IMPLICIT_CLASSES="No"
+	AC_DEFINE_UNQUOTED(CUPS_DEFAULT_IMPLICIT_CLASSES, 0)
+else
+	CUPS_IMPLICIT_CLASSES="Yes"
+	AC_DEFINE_UNQUOTED(CUPS_DEFAULT_IMPLICIT_CLASSES, 1)
+fi
+AC_SUBST(CUPS_IMPLICIT_CLASSES)
+
+dnl Default UseNetworkDefault
+AC_ARG_ENABLE(use_network_default, [  --enable-use-network-default
+                          set UseNetworkDefault to Yes by default])
+if test "x$enable_use_network_default" != xno; then
+	AC_MSG_CHECKING(whether to use network default printers)
+	if test "x$enable_use_network_default" = xyes -o $uname != Darwin; then
+		CUPS_USE_NETWORK_DEFAULT="Yes"
+		AC_DEFINE_UNQUOTED(CUPS_DEFAULT_USE_NETWORK_DEFAULT, 1)
+		AC_MSG_RESULT(yes)
+	else
+		CUPS_USE_NETWORK_DEFAULT="No"
+		AC_DEFINE_UNQUOTED(CUPS_DEFAULT_USE_NETWORK_DEFAULT, 0)
+		AC_MSG_RESULT(no)
+	fi
+else
+	CUPS_USE_NETWORK_DEFAULT="No"
+	AC_DEFINE_UNQUOTED(CUPS_DEFAULT_USE_NETWORK_DEFAULT, 0)
+fi
+AC_SUBST(CUPS_USE_NETWORK_DEFAULT)
+
 dnl Determine the correct username and group for this OS...
 AC_ARG_WITH(cups_user, [  --with-cups-user        set default user for CUPS],
 	CUPS_USER="$withval",
--- a/cups/adminutil.h
+++ b/cups/adminutil.h
@@ -42,7 +42,7 @@
 #  define CUPS_SERVER_DEBUG_LOGGING	"_debug_logging"
 #  define CUPS_SERVER_REMOTE_ADMIN	"_remote_admin"
 #  define CUPS_SERVER_REMOTE_ANY	"_remote_any"
-/*#  define CUPS_SERVER_REMOTE_PRINTERS	"_remote_printers"*/
+#  define CUPS_SERVER_REMOTE_PRINTERS	"_remote_printers"
 #  define CUPS_SERVER_SHARE_PRINTERS	"_share_printers"
 #  define CUPS_SERVER_USER_CANCEL_ANY	"_user_cancel_any"
 
--- a/cups/adminutil.c
+++ b/cups/adminutil.c
@@ -970,6 +970,8 @@
 		remote_admin = 0,	/* Remote administration allowed? */
 		remote_any = 0,		/* Remote access from anywhere allowed? */
 		browsing = 1,		/* Browsing enabled? */
+		browse_allow = 1,	/* Browse address set? */
+		browse_address = 0,	/* Browse address set? */
 		cancel_policy = 1,	/* Cancel-job policy set? */
 		debug_logging = 0;	/* LogLevel debug set? */
     int		linenum = 0,		/* Line number in file */
@@ -1022,6 +1024,18 @@
 	           !_cups_strcasecmp(value, "on") ||
 	           !_cups_strcasecmp(value, "true");
       }
+      else if (!_cups_strcasecmp(line, "BrowseAddress"))
+      {
+	browse_address = 1;
+      }
+      else if (!_cups_strcasecmp(line, "BrowseAllow"))
+      {
+	browse_allow = 1;
+      }
+      else if (!_cups_strcasecmp(line, "BrowseOrder"))
+      {
+	browse_allow = !_cups_strncasecmp(value, "deny,", 5);
+      }
       else if (!_cups_strcasecmp(line, "LogLevel"))
       {
 	debug_logging = !_cups_strncasecmp(value, "debug", 5);
@@ -1125,9 +1139,15 @@
 					   cg->cupsd_num_settings,
 					   &(cg->cupsd_settings));
 
+    cg->cupsd_num_settings = cupsAddOption(CUPS_SERVER_REMOTE_PRINTERS,
+                                           (browsing && browse_allow) ? "1" :
+                                                                        "0",
+					   cg->cupsd_num_settings,
+					   &(cg->cupsd_settings));
+
     cg->cupsd_num_settings = cupsAddOption(CUPS_SERVER_SHARE_PRINTERS,
-                                           (remote_access && browsing) ? "1" :
-                                                                         "0",
+                                           (remote_access && browsing &&
+					    browse_address) ? "1" : "0",
 					   cg->cupsd_num_settings,
 					   &(cg->cupsd_settings));
 
@@ -1188,7 +1208,8 @@
 		in_conf_location,	/* In the /admin/conf location? */
 		in_root_location;	/* In the / location? */
   const char	*val;			/* Setting value */
-  int		share_printers,		/* Share local printers */
+  int		remote_printers,	/* Show remote printers */
+		share_printers,		/* Share local printers */
 		remote_admin,		/* Remote administration allowed? */
 		remote_any,		/* Remote access from anywhere? */
 		user_cancel_any,	/* Cancel-job policy set? */
@@ -1202,7 +1223,8 @@
 		wrote_root_location;	/* Wrote the / location? */
   int		indent;			/* Indentation */
   int		cupsd_num_settings;	/* New number of settings */
-  int		old_share_printers,	/* Share local printers */
+  int		old_remote_printers,	/* Show remote printers */
+		old_share_printers,	/* Share local printers */
 		old_remote_admin,	/* Remote administration allowed? */
 		old_user_cancel_any,	/* Cancel-job policy set? */
 		old_debug_logging;	/* LogLevel debug set? */
@@ -1276,6 +1298,15 @@
   DEBUG_printf(("1cupsAdminSetServerSettings: old remote_any=%d",
                 remote_any));
 
+  if ((val = cupsGetOption(CUPS_SERVER_REMOTE_PRINTERS, cupsd_num_settings,
+                           cupsd_settings)) != NULL)
+    old_remote_printers = atoi(val);
+  else
+    old_remote_printers = 1;
+
+  DEBUG_printf(("1cupsAdminSetServerSettings: old remote_printers=%d",
+                old_remote_printers));
+
   if ((val = cupsGetOption(CUPS_SERVER_SHARE_PRINTERS, cupsd_num_settings,
                            cupsd_settings)) != NULL)
     old_share_printers = atoi(val);
@@ -1347,6 +1378,26 @@
   DEBUG_printf(("1cupsAdminSetServerSettings: remote_admin=%d",
                 remote_admin));
 
+  if ((val = cupsGetOption(CUPS_SERVER_REMOTE_PRINTERS, num_settings,
+                           settings)) != NULL)
+  {
+    remote_printers = atoi(val);
+
+    if (remote_printers == old_remote_printers)
+    {
+     /*
+      * No change to this setting...
+      */
+
+      remote_printers = -1;
+    }
+  }
+  else
+    remote_printers = -1;
+
+  DEBUG_printf(("1cupsAdminSetServerSettings: remote_printers=%d",
+                remote_printers));
+
   if ((val = cupsGetOption(CUPS_SERVER_SHARE_PRINTERS, num_settings,
                            settings)) != NULL)
   {
@@ -1470,33 +1521,80 @@
         cupsFilePrintf(temp, "Listen %s\n", value);
     }
     else if ((!_cups_strcasecmp(line, "Browsing") ||
-              !_cups_strcasecmp(line, "BrowseLocalProtocols")) &&
-	     share_printers >= 0)
+              !_cups_strcasecmp(line, "BrowseAddress") ||
+              !_cups_strcasecmp(line, "BrowseAllow") ||
+              !_cups_strcasecmp(line, "BrowseDeny") ||
+              !_cups_strcasecmp(line, "BrowseLocalProtocols") ||
+              !_cups_strcasecmp(line, "BrowseRemoteProtocols") ||
+              !_cups_strcasecmp(line, "BrowseOrder")) &&
+	     (remote_printers >= 0 || share_printers >= 0))
     {
       if (!wrote_browsing)
       {
+	int new_remote_printers = (remote_printers > 0 ||
+				   (remote_printers == -1 &&
+				    old_remote_printers > 0));
 	int new_share_printers = (share_printers > 0 ||
 				  (share_printers == -1 &&
 				   old_share_printers > 0));
 
         wrote_browsing = 1;
 
-        if (new_share_printers)
+        if (new_remote_printers || new_share_printers)
 	{
 	  const char *localp = cupsGetOption("BrowseLocalProtocols",
 					     num_settings, settings);
+	  const char *remotep = cupsGetOption("BrowseRemoteProtocols",
+					      num_settings, settings);
 
           if (!localp || !localp[0])
 	    localp = cupsGetOption("BrowseLocalProtocols", cupsd_num_settings,
 	                           cupsd_settings);
 
-	  cupsFilePuts(temp, "# Share local printers on the local network.\n");
+          if (!remotep || !remotep[0])
+	    remotep = cupsGetOption("BrowseRemoteProtocols", cupsd_num_settings,
+	                            cupsd_settings);
+
+	  if (new_remote_printers && new_share_printers)
+	    cupsFilePuts(temp,
+	                 "# Enable printer sharing and shared printers.\n");
+	  else if (new_remote_printers)
+	    cupsFilePuts(temp,
+	                 "# Show shared printers on the local network.\n");
+	  else
+	    cupsFilePuts(temp,
+	                 "# Share local printers on the local network.\n");
+
 	  cupsFilePuts(temp, "Browsing On\n");
+	  cupsFilePuts(temp, "BrowseOrder allow,deny\n");
+
+	  if (new_remote_printers)
+	  {
+	    cupsFilePuts(temp, "BrowseAllow all\n");
+
+	    if (!remotep)
+	      remotep = CUPS_DEFAULT_BROWSE_REMOTE_PROTOCOLS;
+
+	    cupsFilePrintf(temp, "BrowseRemoteProtocols %s\n", remotep);
+          }
+	  else
+	    cupsFilePuts(temp, "BrowseRemoteProtocols\n");
+
+	  cupsd_num_settings = cupsAddOption("BrowseRemoteProtocols", remotep,
+					     cupsd_num_settings,
+					     &cupsd_settings);
 
-	  if (!localp)
-	    localp = CUPS_DEFAULT_BROWSE_LOCAL_PROTOCOLS;
+	  if (new_share_printers)
+	  {
+	    cupsFilePuts(temp, "BrowseAddress @LOCAL\n");
+
+	    if (!localp)
+	      localp = CUPS_DEFAULT_BROWSE_LOCAL_PROTOCOLS;
 
-	  cupsFilePrintf(temp, "BrowseLocalProtocols %s\n", localp);
+	    cupsFilePrintf(temp, "BrowseLocalProtocols %s\n", localp);
+	  }
+	  else
+	    cupsFilePuts(temp, "BrowseLocalProtocols\n");
 
 	  cupsd_num_settings = cupsAddOption("BrowseLocalProtocols", localp,
 					     cupsd_num_settings,
@@ -1504,7 +1602,8 @@
         }
 	else
 	{
-	  cupsFilePuts(temp, "# Disable printer sharing.\n");
+	  cupsFilePuts(temp,
+	               "# Disable printer sharing and shared printers.\n");
 	  cupsFilePuts(temp, "Browsing Off\n");
 	}
       }
@@ -1770,12 +1869,25 @@
   * Write any missing info...
   */
 
-  if (!wrote_browsing && share_printers >= 0)
+  if (!wrote_browsing && (remote_printers >= 0 || share_printers >= 0))
   {
-    if (share_printers > 0)
+    if (remote_printers > 0 || share_printers > 0)
     {
-      cupsFilePuts(temp, "# Share local printers on the local network.\n");
+      if (remote_printers > 0 && share_printers > 0)
+	cupsFilePuts(temp, "# Enable printer sharing and shared printers.\n");
+      else if (remote_printers > 0)
+	cupsFilePuts(temp, "# Show shared printers on the local network.\n");
+      else
+	cupsFilePuts(temp, "# Share local printers on the local network.\n");
+
       cupsFilePuts(temp, "Browsing On\n");
+      cupsFilePuts(temp, "BrowseOrder allow,deny\n");
+
+      if (remote_printers > 0)
+	cupsFilePuts(temp, "BrowseAllow all\n");
+
+      if (share_printers > 0)
+	cupsFilePuts(temp, "BrowseAddress @LOCAL\n");
     }
     else
     {
@@ -1982,6 +2094,15 @@
                                        remote_any ? "1" : "0",
 				       cupsd_num_settings, &cupsd_settings);
 
+    if (remote_printers >= 0)
+      cupsd_num_settings = cupsAddOption(CUPS_SERVER_REMOTE_PRINTERS,
+                                	 remote_printers ? "1" : "0",
+					 cupsd_num_settings, &cupsd_settings);
+    else
+      cupsd_num_settings = cupsAddOption(CUPS_SERVER_REMOTE_PRINTERS,
+                                	 old_remote_printers ? "1" : "0",
+					 cupsd_num_settings, &cupsd_settings);
+
     if (share_printers >= 0)
       cupsd_num_settings = cupsAddOption(CUPS_SERVER_SHARE_PRINTERS,
                                 	 share_printers ? "1" : "0",
--- a/scheduler/cupsd.h
+++ b/scheduler/cupsd.h
@@ -86,6 +86,7 @@
 #define DEFAULT_FILES		86400	/* Preserve job files? */
 #define DEFAULT_TIMEOUT		300	/* Timeout during requests/updates */
 #define DEFAULT_KEEPALIVE	30	/* Timeout between requests */
+#define DEFAULT_INTERVAL	30	/* Interval between browse updates */
 
 
 /*
